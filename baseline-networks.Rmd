---
title: "Network analyses"
---

```{r}

source("baseline-datasetup.R")

# # Packages specifically for network analysis
# pacman::p_install("EstimateGroupNetwork", "bootnet", "qgraph")
# pacman::p_install_gh("sachaepskamp/NetworkComparisonTest")

```

Clicking the "Code"-buttons on the right shows code for each chunk.

# UNDER CONSTRUCTION: Networks of psychosocial variables 

# BCTs

## Graph analysis

### Mixed model with binarised and continuous variables

#### BCT chunks

```{r}
bctdf_chunks <- df %>% dplyr::select(
#  id,
  intervention,
#  group,
#  school,
  girl,
  PA_agrbct_T1,
  PA_frqbct_T1,
  'MVPA' = paAccelerometer_T1,
  'intrinsic' = PA_intrinsic_T1,
  'identified' = PA_identified_T1,
  'introjected' = PA_introjected_T1,
  'extrinsic' = PA_extrinsic_T1,
  'controlled' = PA_controlled_T1) %>%
 rowwise() %>% 
 mutate(
  'BCTs' = mean(c(PA_agrbct_T1, PA_frqbct_T1), na.rm = TRUE),
  'autonomous' = mean(c(identified, intrinsic), na.rm = TRUE),
  'girl' = ifelse(girl == "girl", 1, 0),
#  'controlled' = ifelse(controlled < 3, 0, 1), # If "at least partly" or more true, input 1. Normality otherwise a problem. 
  'intervention' = ifelse(intervention == "1", 1, 0)) %>% 
#  select(-controlled) %>% # Not really gaussian at all 
  select(MVPA, girl, intervention, BCTs, autonomous, controlled) %>% 
  data.frame

bctdf_chunks$autonomous[is.nan(bctdf_chunks$autonomous)] <- NA

labs <- names(bctdf_chunks)

bctdf_chunks %>% 
  corrgram::corrgram( 
         cor.method = "spearman", 
         # diag.panel=panel.minmax, 
         # lower.panel=panel.shade, 
         # lower.panel=panel.ellipse,
         # lower.panel=panel.cor,
         upper.panel=panel.conf,
         lower.panel=panel.pie,
         outer.labels=list(
           bottom=list(labels=labs,cex=.75, srt=60),
           left=list(labels=labs,cex=.75, srt=30))
         )

nwBCT_chunks <- bootnet::estimateNetwork(bctdf_chunks, default="EBICglasso")

plot(nwBCT_chunks)


qgraph(cor_auto(bctdf_chunks), graph = "cor",
       labels = names(bctdf_chunks),
       edge.labels = TRUE)

```

```{r}
bctdf_mgm <- df %>% dplyr::select(
#  id,
  intervention,
#  group,
#  school,
  girl,
  'goal setting' = PA_agrbct_01_T1,
  'implementation plan' = PA_agrbct_02_T1,
  'plan by other' = PA_agrbct_03_T1,
  'reminder of plan' = PA_agrbct_04_T1,
  'subgoals' = PA_agrbct_05_T1,
  'new PA options' = PA_agrbct_06_T1,
  'barrier identification' = PA_agrbct_07_T1,
  'coping planning' = PA_agrbct_08_T1,
  'PA identity' = PA_agrbct_09_T1,
  'PA life values' = PA_agrbct_10_T1,
  'positive consequences' = PA_frqbct_01_T1,
  'log on paper' = PA_frqbct_02_T1,
  'smartphone' = PA_frqbct_03_T1,
#  'mnemonic cues' = PA_frqbct_04_T1,
  'goal contrast' = PA_frqbct_05_T1,
  'relevance of PA' = PA_frqbct_06_T1,
  'changes at home' = PA_frqbct_07_T1,
  'social support' = PA_frqbct_08_T1,
  'failure contemplated' = PA_frqbct_09_T1,
  'MVPA' = paAccelerometer_T1,
  'intrinsic' = PA_intrinsic_T1,
  'identified' = PA_identified_T1,
  'controlled' = PA_controlled_T1) %>%
 rowwise() %>% 
 mutate(
  'goal setting' = ifelse(`goal setting` == 1, 0, 1),
  'has plan' = ifelse(`implementation plan` == 1 & `plan by other` == 1, 0, 1),
  'implementation plan' = ifelse(`implementation plan` == 1, 0, 1),
  'reminder of plan' = ifelse(`reminder of plan` == 1, 0, 1),
  'subgoals' = ifelse(`subgoals` == 1, 0, 1),
  'new PA options' = ifelse(`new PA options` == 1, 0, 1),
#  'barrier identification' = ifelse(`barrier identification` == 1, 0, 1),
#  'coping planning' = ifelse(`coping planning` == 1, 0, 1),
  'barriers identified, planned for' = ifelse(`coping planning` == 1 & `barrier identification` == 1, 0, 1),
#  'PA identity' = ifelse(`PA identity` == 1, 0, 1),
#  'PA life values' = ifelse(`PA life values` == 1, 0, 1),
  'identity, life values' = ifelse(`PA identity` == 1 & `PA life values` == 1, 0, 1),
  'positive consequences' = ifelse(`positive consequences` == 1, 0, 1),
  'monitored PA' = ifelse(`log on paper` == 1 & `smartphone` == 1, 0, 1),
#  'mnemonic cues' = ifelse(`mnemonic cues` == 1, 0, 1),
  'goal contrast' = ifelse(`goal contrast` == 1, 0, 1),
  'relevance of PA' = ifelse(`relevance of PA` == 1, 0, 1),
  'changes at home' = ifelse(`changes at home` == 1, 0, 1),
  'social support' = ifelse(`social support` == 1, 0, 1),
  'failure contemplated' = ifelse(`failure contemplated` == 1, 0, 1),
  'autonomous' = mean(c(identified, intrinsic), na.rm = T),
  'girl' = ifelse(girl == "girl", 1, 0),
  'controlled' = ifelse(controlled < 3, 0, 1), # If "at least partly" or more true, input 1. Normality otherwise a problem. 
  'intervention' = ifelse(intervention == "1", 1, 0)) %>% 
  select(-`log on paper`, -`smartphone`, -`plan by other`, -`implementation plan`, -identified, -intrinsic,
         -`failure contemplated`, # only concerns those who haven't reached goals
         -`barrier identification`, -`coping planning`, # closely related
         -`PA identity`, -`PA life values`) %>% # closely related
#  select(-controlled) %>% # Not really gaussian at all 
  select(MVPA, girl, intervention, everything()) %>% 
  data.frame

bctdf_mgm$autonomous[is.nan(bctdf_mgm$autonomous)] <- NA

labs <- names(bctdf_mgm)
labs
bctdf_mgm %>% 
  corrgram::corrgram( 
         cor.method = "spearman", 
         # diag.panel=panel.minmax, 
         # lower.panel=panel.shade, 
         # lower.panel=panel.ellipse,
         # lower.panel=panel.cor,
         upper.panel=panel.conf,
         lower.panel=panel.pie,
         outer.labels=list(
           bottom=list(labels=labs,cex=.75, srt=60),
           left=list(labels=labs,cex=.75, srt=30))
         )

```

#### mgm estimation

```{r}
# devtools::install_github("jmbh/mgm")
# Restart R for the latest package
# .r.restartR()
library(mgm)

# mgm wants full data, see package missForest for imputation
bctdf_mgm <- bctdf_mgm %>% filter(complete.cases(.))
bctdf_mgm %>% names()
mgm_variable_types <- c("g", rep("c", 16), "g")
mgm_variable_levels <- c("1", rep("2", 16), "1")
data.frame(mgm_variable_types, mgm_variable_levels, names(bctdf_mgm))

mgm_obj <- mgm::mgm(data = bctdf_mgm,
  type = mgm_variable_types,
  level = mgm_variable_levels,
  lambdaSel = "CV",
  lambdaFolds = 10,
  pbar = FALSE, 
  binarySign = TRUE)

pred_obj <- predict(object = mgm_obj,
                         data = bctdf_mgm)

pred_obj$errors

# Take R2 from gaussian, CC from categorical variables 
pie_errors <- c(pred_obj$errors[1, 3],
                pred_obj$errors[2:17, 4],
                pred_obj$errors[18, 3])


```

#### mgm plotting

```{r}
library(qgraph)
library(igraph)

node_colors <- c(viridis::viridis(6, end = 0.8)[1], 
                 viridis::viridis(6, end = 0.8)[2],
                 viridis::viridis(6, end = 0.8)[3],
                 rep(viridis::viridis(6, end = 0.8)[4], 9),
                 viridis::viridis(6, end = 0.8)[5],   
                 rep(viridis::viridis(6, end = 0.8)[4], 4),
                 viridis::viridis(6, end = 0.8)[5])

BCT_mgm <- qgraph::qgraph(mgm_obj$pairwise$wadj, 
            layout = "spring",
            repulsion = 0.90, # To nudge the network from originally bad visual state
            title = "MGM: PA, BCTs & motivation",
            edge.color = ifelse(mgm_obj$pairwise$edgecolor == "darkgreen", "blue", mgm_obj$pairwise$edgecolor),
            pie = pie_errors,
            pieColor = viridis::viridis(6, end = 0.8)[6],
            color = node_colors,
            labels = names(bctdf_mgm),
            label.cex = 0.75,
            label.scale = FALSE,
            label.color = c(rep("white", 2), rep("black", 16)),
            theme = "colorblind")

```

```{r}
devtools::install_github("hfgolino/EGA")
library(EGA)

n1 <- qgraph(cor_auto(bctdf_mgm), graph="EBICglasso", sampleSize=nrow(bctdf_mgm), layout="spring")

g <- as.igraph(BCT_mgm)

matrix_spinglass <- matrix(NA, nrow=1,ncol=100)
 
for (i in 1:100) {
set.seed(i)
spinglass <- spinglass.community(g)
matrix_spinglass[1,i] <- max(spinglass$membership) 
}

matrix(spinglass$membership, 1:18)

# mean(as.vector(matrix_spinglass)) #5.87
# max(as.vector(matrix_spinglass)) #7
# min(as.vector(matrix_spinglass)) #5
# median(as.vector(matrix_spinglass)) #6

group_spinglass <- list(c(1:3, 17), c(4, 14, 18), c(5:7, 15:16), c(8:13))

spinglass_graph <- qgraph::qgraph(cor_auto(bctdf_mgm), 
            graph="EBICglasso", 
            sampleSize=nrow(bctdf_mgm), 
            layout = "spring",
            repulsion = 0.90, # To nudge the network from originally bad visual state
            title = "PA, BCTs & motivation in Spinglass groups",
            pie = pie_errors,
            pieColor = viridis::viridis(6, end = 0.8)[6],
            # color = node_colors,
            groups = group_spinglass,
            labels = names(bctdf_mgm),
            label.cex = 0.75,
            label.scale = FALSE,
            theme = "colorblind")

ega_graph <- EGA(bctdf_mgm)

ega_graph

group_ega <- list(c(8:13, 16:17), c(3:7, 14:15), c(1:2, 18))

ega_graph <- qgraph::qgraph(cor_auto(bctdf_mgm), 
            graph="EBICglasso", 
            sampleSize=nrow(bctdf_mgm), 
            layout = "spring",
            repulsion = 0.90, # To nudge the network from originally bad visual state
            title = "PA, BCTs & motivation in EGA groups",
            pie = pie_errors,
            pieColor = viridis::viridis(6, end = 0.8)[6],
            # color = node_colors,
            groups = group_ega,
            labels = names(bctdf_mgm),
            label.cex = 0.75,
            label.scale = FALSE,
            theme = "colorblind")

avlayout <- averageLayout(ega_graph, spinglass_graph)


par(mfrow = c(1, 2))

qgraph::qgraph(cor_auto(bctdf_mgm), 
            graph="EBICglasso", 
            sampleSize=nrow(bctdf_mgm), 
            layout = avlayout,
            repulsion = 0.90, # To nudge the network from originally bad visual state
            title = "PA, BCTs & motivation in EGA groups",
            pie = pie_errors,
            pieColor = viridis::viridis(6, end = 0.8)[6],
            # color = node_colors,
            groups = group_ega,
            labels = names(bctdf_mgm),
            label.cex = 0.75,
            label.scale = FALSE,
            theme = "colorblind")

qgraph::qgraph(cor_auto(bctdf_mgm), 
            graph="EBICglasso", 
            sampleSize=nrow(bctdf_mgm), 
            layout = avlayout,
            repulsion = 0.90, # To nudge the network from originally bad visual state
            title = "PA, BCTs & motivation in Spinglass groups",
            pie = pie_errors,
            pieColor = viridis::viridis(6, end = 0.8)[6],
            # color = node_colors,
            groups = group_spinglass,
            labels = names(bctdf_mgm),
            label.cex = 0.75,
            label.scale = FALSE,
            theme = "colorblind")

```


### ggm estimation & plotting

```{r}

bctdf_ggm <- df %>% dplyr::select(
#  id,
  intervention,
#  group,
#  school,
  girl,
  'goal setting' = PA_agrbct_01_T1,
  'implementation plan' = PA_agrbct_02_T1,
  'plan by other' = PA_agrbct_03_T1,
  'reminder of plan' = PA_agrbct_04_T1,
  'subgoals' = PA_agrbct_05_T1,
  'new PA options' = PA_agrbct_06_T1,
  'barrier identification' = PA_agrbct_07_T1,
  'coping planning' = PA_agrbct_08_T1,
  'PA identity' = PA_agrbct_09_T1,
  'PA life values' = PA_agrbct_10_T1,
  'positive consequences' = PA_frqbct_01_T1,
  'log on paper' = PA_frqbct_02_T1,
  'smartphone' = PA_frqbct_03_T1,
#  'mnemonic cues' = PA_frqbct_04_T1,
  'goal contrast' = PA_frqbct_05_T1,
  'relevance of PA' = PA_frqbct_06_T1,
  'changes at home' = PA_frqbct_07_T1,
  'social support' = PA_frqbct_08_T1,
  'failure contemplated' = PA_frqbct_09_T1,
  'MVPA' = paAccelerometer_T1,
  'intrinsic' = PA_intrinsic_T1,
  'identified' = PA_identified_T1,
  'controlled' = PA_controlled_T1) %>%
 rowwise() %>% 
 mutate(
  'has plan' = mean(c(`implementation plan`, `plan by other`), na.rm = TRUE),
  'barriers identified, planned for' = mean(c(`coping planning`, `barrier identification`), na.rm = TRUE),
  'identity, life values' = mean(c(`PA identity` == 1, `PA life values`), na.rm = TRUE),
  'monitored PA' = mean(c(`log on paper`, `smartphone`), na.rm = TRUE),
  'autonomous' = mean(c(identified, intrinsic), na.rm = T),
  'girl' = ifelse(girl == "girl", 1, 0),
  'intervention' = ifelse(intervention == "1", 1, 0)) %>% 
  select(-`log on paper`, -`smartphone`, -`plan by other`, -`implementation plan`, -identified, -intrinsic,
         -`failure contemplated`, # only concerns those who haven't reached goals
         -`barrier identification`, -`coping planning`, # closely related
         -`PA identity`, -`PA life values`) %>% # closely related
#  select(-controlled) %>% # Not really gaussian at all 
  select(MVPA, girl, intervention, everything()) %>% 
  data.frame

bctdf_mgm$autonomous[is.nan(bctdf_mgm$autonomous)] <- NA

# Network for all participants

S.total_ggm <- bctdf_ggm
nwBCT_ggm <- bootnet::estimateNetwork(S.total_ggm, default="EBICglasso")

labs_ggm <- colnames(S.total_ggm)

# Create means for filling nodes
piefill_ggm <- S.total_ggm %>% 
  select(-contains("MVPA"), -girl, -intervention) %>%
  summarise_all(funs(median(., na.rm = TRUE) / 6)) 

piefill_ggm$MVPA <- median(S.total_ggm$MVPA, na.rm = TRUE) / (60*24) 
piefill_ggm$girl <- mean(S.total_ggm$girl, na.rm = TRUE)
piefill_ggm$intervention <- mean(S.total_ggm$intervention, na.rm = TRUE)

piefill_ggm <- piefill_ggm %>% select(MVPA, girl, intervention, everything())

# Plot network

BCT_ggm <- plot(nwBCT_ggm, 
                layout = "spring", 
                repulsion = 0.90, # To nudge the network from originally bad visual state
                label.scale = FALSE, 
                title = "GGM: PA, BCTs & motivation", 
                label.cex = 0.75,
                pie = piefill_ggm, 
                color = "skyblue",
                pieBorder = 1)

```

### Plot bivariate correlations

```{r}
corMat <- cor_auto(bctdf_ggm)

qgraph(corMat, 
       graph = "cor", 
       label.scale = FALSE, 
       title = "Bivariate correlations: PA, BCTs & motivation", 
       label.cex = 0.75,
       pie = piefill_ggm, 
       color = "skyblue",
       pieBorder = 1,
       threshold = "holm",
       sampleSize = sum(complete.cases(bctdf_ggm)),
       minimum = 0.2,
       layout = layout_mgm_ggm,
       details = TRUE,
       edge.labels = TRUE)

```

### Centrality and stability check

```{r}
c1 <- qgraph::centralityPlot(BCT_ggm)

centrality(nwBCT_ggm)$InDegree
scale(centrality(nwBCT_ggm)$InDegree) # Normalised strength
centrality(nwBCT_ggm)$Closeness
centrality(nwBCT_ggm)$Betweenness

nwcors <- data.frame(centrality(nwBCT_ggm)$InDegree,
                     centrality(nwBCT_ggm)$Betweenness,
                     centrality(nwBCT_ggm)$Closeness)

names(nwcors) <- c("InDegree", "Betweenness", "Closeness")

labs <- names(nwcors)
corrgram::corrgram(nwcors, 
         cor.method = "spearman", 
         # diag.panel=panel.minmax, 
         # lower.panel=panel.shade, 
         # lower.panel=panel.ellipse,
         # lower.panel=panel.cor,
         upper.panel=panel.conf,
         lower.panel=panel.pie
         # outer.labels=list(
         #   bottom=list(labels=labs,cex=.75, srt=60),
         #   left=list(labels=labs,cex=.75, srt=30))
          )

BCT_ggm_bootnet_case <- bootnet::bootnet(nwBCT_ggm, boots=5000, type = "case", nCores=2)
BCT_ggm_bootnet <- bootnet::bootnet(nwBCT_ggm, boots=5000, nCores=2)

save(BCT_ggm_bootnet, file = "BCT_ggm_bootnet.Rdata")
save(BCT_ggm_bootnet_case, file = "BCT_ggm_bootnet_case.Rdata")

bootnet::corStability(BCT_ggm_bootnet_case)  

plot(BCT_ggm_bootnet, "strength")
plot(BCT_ggm_bootnet, "betweenness")
plot(BCT_ggm_bootnet, "closeness")

plot(BCT_ggm_bootnet, labels = FALSE, order = "sample") 

plot(BCT_ggm_bootnet, "edge", plot = "difference", onlyNonZero = TRUE, labels = FALSE, order = "sample")



```


## Visually compare ggm and mgm

```{r}

layout_mgm_ggm <- averageLayout(BCT_ggm, BCT_mgm)

layout(t(1:2))

plot(nwBCT_ggm, layout = layout_mgm_ggm, label.scale = FALSE, title = "GGM: PA, BCTs & motivation", label.cex = 0.75,
     pie = piefill_ggm, 
     color = "skyblue",
     pieBorder = 1)

qgraph::qgraph(mgm_obj$pairwise$wadj, 
            layout = layout_mgm_ggm,
            title = "MGM: PA, BCTs & motivation",
            edge.color = ifelse(mgm_obj$pairwise$edgecolor == "darkgreen", "blue", mgm_obj$pairwise$edgecolor),
            pie = pie_errors,
            pieColor = "darkorchid1",
            labels = names(bctdf_mgm),
            label.cex = 0.75,
            label.scale = FALSE,
            theme = "colorblind")
```


### Ising networks

Prepare and dichotomise data (lots of skew in distributions).

```{r}
nItems <- 19

bctdf <- df %>% dplyr::select(id,
  intervention,
  group,
  school,
  girl,
  'goal setting' = PA_agrbct_01_T1,
  'implementation plan' = PA_agrbct_02_T1,
  'plan by other' = PA_agrbct_03_T1,
  'reminder of plan' = PA_agrbct_04_T1,
  'subgoals' = PA_agrbct_05_T1,
  'new PA options' = PA_agrbct_06_T1,
  'barrier identification' = PA_agrbct_07_T1,
  'coping planning' = PA_agrbct_08_T1,
  'PA identity' = PA_agrbct_09_T1,
  'PA life values' = PA_agrbct_10_T1,
  'positive consequences' = PA_frqbct_01_T1,
  'log on paper' = PA_frqbct_02_T1,
  'smartphone' = PA_frqbct_03_T1,
  'mnemonic cues' = PA_frqbct_04_T1,
  'goal contrast' = PA_frqbct_05_T1,
  'relevance of PA' = PA_frqbct_06_T1,
  'changes at home' = PA_frqbct_07_T1,
  'social support' = PA_frqbct_08_T1,
  'failure contemplated' = PA_frqbct_09_T1) %>%
 mutate(
  'goal setting' = ifelse(`goal setting` == 1, 0, 1),
  'implementation plan' = ifelse(`implementation plan` == 1, 0, 1),
  'plan by other' = ifelse(`plan by other` == 1, 0, 1),
  'reminder of plan' = ifelse(`reminder of plan` == 1, 0, 1),
  'subgoals' = ifelse(`subgoals` == 1, 0, 1),
  'new PA options' = ifelse(`new PA options` == 1, 0, 1),
  'barrier identification' = ifelse(`barrier identification` == 1, 0, 1),
  'coping planning' = ifelse(`coping planning` == 1, 0, 1),
  'PA identity' = ifelse(`PA identity` == 1, 0, 1),
  'PA life values' = ifelse(`PA life values` == 1, 0, 1),
  'positive consequences' = ifelse(`positive consequences` == 1, 0, 1),
  'log on paper' = ifelse(`log on paper` == 1, 0, 1),
  'smartphone' = ifelse(`smartphone` == 1, 0, 1),
  'mnemonic cues' = ifelse(`mnemonic cues` == 1, 0, 1),
  'goal contrast' = ifelse(`goal contrast` == 1, 0, 1),
  'relevance of PA' = ifelse(`relevance of PA` == 1, 0, 1),
  'changes at home' = ifelse(`changes at home` == 1, 0, 1),
  'social support' = ifelse(`social support` == 1, 0, 1),
  'failure contemplated' = ifelse(`failure contemplated` == 1, 0, 1)) %>% 
  data.frame

S.boys <- bctdf %>% filter(girl == 0) %>% select(6:ncol(bctdf)) %>% na.omit(.) 
S.girls <- bctdf %>% filter(girl == 1) %>% select(6:ncol(bctdf)) %>% na.omit(.)
nwBoys <- bootnet::estimateNetwork(S.boys, default="IsingFit")
nwGirls <- bootnet::estimateNetwork(S.girls, default="IsingFit")

# Create means for filling nodes

girlmeans <- bctdf %>% group_by(girl) %>% 
  summarise_at(vars(5:(5+nItems-1)),
  funs(mean(., na.rm = TRUE))) %>% 
  filter(girl == 1) %>% 
  select(-1)

boymeans <- bctdf %>% group_by(girl) %>% 
  summarise_at(vars(5:(5+nItems-1)),
  funs(mean(., na.rm = TRUE))) %>% 
  filter(girl == 0) %>% 
  select(-1)

```

#### Plot BCT Ising-networks 

For girls and boys.

```{r}

# Find average layout for comparability and plot graphs next to each other

Layout <- averageLayout(nwGirls, nwBoys)

layout(t(1:2))

plot(nwGirls, layout = Layout, label.scale = FALSE, title = "Girls", label.cex = 0.75,
     pie = girlmeans, 
     color = "skyblue",
     pieBorder = 1)

plot(nwBoys, layout = Layout, label.scale = FALSE, title = "Boys", label.cex = 0.75, 
     pie = boymeans, 
     color = "skyblue",
     pieBorder = 1)

```

For all participants.

```{r}

S.total <- bctdf %>% select(6:ncol(bctdf))
nwBCT <- bootnet::estimateNetwork(S.total, default="IsingFit")

# smallworldIndex(plot(nwBCT))

# Create means for filling nodes
piefill <- S.total %>%
  summarise_all(funs(mean(., na.rm = TRUE))) 

# Plot network
plot(nwBCT, layout = "spring", label.scale = FALSE, title = "Ising fit", label.cex = 0.75,
     pie = piefill, 
     color = "skyblue",
     pieBorder = 1)

# Estimate ising network without regularisation
nwBCT_nonreg <- bootnet::estimateNetwork(S.total, default="IsingSampler")

plot(nwBCT_nonreg, layout = "spring", label.scale = FALSE, title = "Non-regularised Ising model", label.cex = 0.75,
     pie = piefill, 
     color = "skyblue",
     pieBorder = 1)
```



```{r}

nItems <- 19

bctdf <- df %>% dplyr::select(id,
  intervention,
  group,
  school,
  girl,
  'goal setting' = PA_agrbct_01_T1,
  'implementation plan' = PA_agrbct_02_T1,
  'plan by other' = PA_agrbct_03_T1,
  'reminder of plan' = PA_agrbct_04_T1,
  'subgoals' = PA_agrbct_05_T1,
  'new PA options' = PA_agrbct_06_T1,
  'barrier identification' = PA_agrbct_07_T1,
  'coping planning' = PA_agrbct_08_T1,
  'PA identity' = PA_agrbct_09_T1,
  'PA life values' = PA_agrbct_10_T1,
  'positive consequences' = PA_frqbct_01_T1,
  'log on paper' = PA_frqbct_02_T1,
  'smartphone' = PA_frqbct_03_T1,
  'mnemonic cues' = PA_frqbct_04_T1,
  'goal contrast' = PA_frqbct_05_T1,
  'relevance of PA' = PA_frqbct_06_T1,
  'changes at home' = PA_frqbct_07_T1,
  'social support' = PA_frqbct_08_T1,
  'failure contemplated' = PA_frqbct_09_T1) %>%
 mutate(
  'goals' = ifelse(`goal setting` == 1, 0, 1),
  'implementation plan' = ifelse(`implementation plan` == 1, 0, 1),
  'plan by other' = ifelse(`plan by other` == 1, 0, 1),
  'reminder of plan' = ifelse(`reminder of plan` == 1, 0, 1),
  'subgoals' = ifelse(`subgoals` == 1, 0, 1),
  'new PA options' = ifelse(`new PA options` == 1, 0, 1),
  'barrier identification' = ifelse(`barrier identification` == 1, 0, 1),
  'coping planning' = ifelse(`coping planning` == 1, 0, 1),
  'PA identity' = ifelse(`PA identity` == 1, 0, 1),
  'PA life values' = ifelse(`PA life values` == 1, 0, 1),
  'positive consequences' = ifelse(`positive consequences` == 1, 0, 1),
  'log on paper' = ifelse(`log on paper` == 1, 0, 1),
  'smartphone' = ifelse(`smartphone` == 1, 0, 1),
  'mnemonic cues' = ifelse(`mnemonic cues` == 1, 0, 1),
  'goal contrast' = ifelse(`goal contrast` == 1, 0, 1),
  'relevance of PA' = ifelse(`relevance of PA` == 1, 0, 1),
  'changes at home' = ifelse(`changes at home` == 1, 0, 1),
  'social support' = ifelse(`social support` == 1, 0, 1),
  'failure contemplated' = ifelse(`failure contemplated` == 1, 0, 1)) %>% 
  data.frame

S.boys <- bctdf %>% filter(girl == 0) %>% select(6:ncol(bctdf)) %>% na.omit(.) 
S.girls <- bctdf %>% filter(girl == 1) %>% select(6:ncol(bctdf)) %>% na.omit(.)
nwBoys <- bootnet::estimateNetwork(S.boys, default="IsingFit")
nwGirls <- bootnet::estimateNetwork(S.girls, default="IsingFit")

# Create means for filling nodes

girlmeans <- bctdf %>% group_by(girl) %>% 
  summarise_at(vars(5:(5+nItems-1)),
  funs(mean(., na.rm = TRUE))) %>% 
  filter(girl == 1) %>% 
  select(-1)

boymeans <- bctdf %>% group_by(girl) %>% 
  summarise_at(vars(5:(5+nItems-1)),
  funs(mean(., na.rm = TRUE))) %>% 
  filter(girl == 0) %>% 
  select(-1)

# Find average layout for comparability and plot graphs next to each other

Layout <- averageLayout(nwGirls, nwBoys)

layout(t(1:2))
plot(nwGirls, layout = Layout, label.scale = FALSE, title = "Girls", label.cex = 0.75,
     pie = girlmeans, 
     color = "skyblue",
     pieBorder = 1)

plot(nwBoys, layout = Layout, label.scale = FALSE, title = "Boys", label.cex = 0.75, 
     pie = boymeans, 
     color = "skyblue",
     pieBorder = 1)

```

#### Combine items 

```{r}
nItems <- 17

bctdf <- df %>% dplyr::select(id,
  intervention,
  group,
  school,
  girl,
  'goal setting' = PA_agrbct_01_T1,
  'implementation plan' = PA_agrbct_02_T1,
  'plan by other' = PA_agrbct_03_T1,
  'reminder of plan' = PA_agrbct_04_T1,
  'subgoals' = PA_agrbct_05_T1,
  'new PA options' = PA_agrbct_06_T1,
  'barrier identification' = PA_agrbct_07_T1,
  'coping planning' = PA_agrbct_08_T1,
  'PA identity' = PA_agrbct_09_T1,
  'PA life values' = PA_agrbct_10_T1,
  'positive consequences' = PA_frqbct_01_T1,
  'log on paper' = PA_frqbct_02_T1,
  'smartphone' = PA_frqbct_03_T1,
#  'mnemonic cues' = PA_frqbct_04_T1,
  'goal contrast' = PA_frqbct_05_T1,
  'relevance of PA' = PA_frqbct_06_T1,
  'changes at home' = PA_frqbct_07_T1,
  'social support' = PA_frqbct_08_T1,
  'failure contemplated' = PA_frqbct_09_T1) %>%
 mutate(
  'goals' = ifelse(`goal setting` == 1, 0, 1),
  'implementation plan' = ifelse(`implementation plan` == 1 & `plan by other` == 1, 0, 1),
  'reminder of plan' = ifelse(`reminder of plan` == 1, 0, 1),
  'subgoals' = ifelse(`subgoals` == 1, 0, 1),
  'new PA options' = ifelse(`new PA options` == 1, 0, 1),
  'barrier identification' = ifelse(`barrier identification` == 1, 0, 1),
  'coping planning' = ifelse(`coping planning` == 1, 0, 1),
  'PA identity' = ifelse(`PA identity` == 1, 0, 1),
  'PA life values' = ifelse(`PA life values` == 1, 0, 1),
  'positive consequences' = ifelse(`positive consequences` == 1, 0, 1),
  'monitored PA' = ifelse(`log on paper` == 1 & `smartphone` == 1, 0, 1),
#  'mnemonic cues' = ifelse(`mnemonic cues` == 1, 0, 1),
  'goal contrast' = ifelse(`goal contrast` == 1, 0, 1),
  'relevance of PA' = ifelse(`relevance of PA` == 1, 0, 1),
  'changes at home' = ifelse(`changes at home` == 1, 0, 1),
  'social support' = ifelse(`social support` == 1, 0, 1),
  'failure contemplated' = ifelse(`failure contemplated` == 1, 0, 1)) %>%
  select(-`log on paper`, -`smartphone`, -`plan by other`) %>% 
  data.frame

# S.boys <- bctdf %>% filter(girl == 0) %>% select(6:ncol(bctdf)) %>% na.omit(.) 
# S.girls <- bctdf %>% filter(girl == 1) %>% select(6:ncol(bctdf)) %>% na.omit(.)
# nwBoys <- bootnet::estimateNetwork(S.boys, default="IsingFit")
# nwGirls <- bootnet::estimateNetwork(S.girls, default="IsingFit")
# 
# # Create means for filling nodes
# 
# girlmeans <- bctdf %>% group_by(girl) %>% 
#   summarise_at(vars(5:(5+nItems-1)),
#   funs(mean(., na.rm = TRUE))) %>% 
#   filter(girl == 1) %>% 
#   select(-1)
# 
# boymeans <- bctdf %>% group_by(girl) %>% 
#   summarise_at(vars(5:(5+nItems-1)),
#   funs(mean(., na.rm = TRUE))) %>% 
#   filter(girl == 0) %>% 
#   select(-1)
# 
# # Find average layout for comparability and plot graphs next to each other
# 
# Layout <- averageLayout(nwGirls, nwBoys)
# 
# layout(t(1:2))
# plot(nwGirls, layout = Layout, label.scale = FALSE, title = "Girls", label.cex = 0.75,
#      pie = girlmeans, 
#      color = "skyblue",
#      pieBorder = 1)
# 
# plot(nwBoys, layout = Layout, label.scale = FALSE, title = "Boys", label.cex = 0.75, 
#      pie = boymeans, 
#      color = "skyblue",
#      pieBorder = 1)

# Network for all participants

S.total <- bctdf %>% select(6:ncol(bctdf))
nwBCT <- bootnet::estimateNetwork(S.total, default="IsingFit")

# smallworldIndex(plot(nwBCT))

# Create means for filling nodes
piefill <- S.total %>%
  summarise_all(funs(mean(., na.rm = TRUE))) 

# Plot network
plot(nwBCT, layout = "spring", label.scale = FALSE, title = "Ising fit", label.cex = 0.75,
     pie = piefill, 
     color = "skyblue",
     pieBorder = 1)

# # Estimate ising network without regularisation
# nwBCT_nonreg <- bootnet::estimateNetwork(S.total, default="IsingSampler")
# 
# plot(nwBCT_nonreg, layout = "spring", label.scale = FALSE, title = "Non-regularised Ising model", label.cex = 0.75,
#      pie = piefill, 
#      color = "skyblue",
#      pieBorder = 1)
```

#### Centrality and stability

```{r BCTstability, cache = TRUE}
qgraph::centralityPlot(nwBCT)

boot2 <- bootnet::bootnet(nwBCT, nBoots = 2500, type = "case", nCores = 2)
bootnet::corStability(boot2)

plot(boot2)
plot(boot2, "strength")
plot(boot2, "betweenness")
plot(boot2, "closeness")

```


#### Network comparison test: boys vs. girls

```{r nctboysgirls, eval = FALSE, cache = TRUE}

nct_results <- NetworkComparisonTest::NCT(nwGirls, nwBoys, it=1000, binary.data=TRUE, paired=FALSE, test.edges=TRUE, edges='all', progressbar=TRUE)

nct_results$nwinv.pval  # p value of network structure diff test: 0.424
nct_results$glstrinv.pval  # p value of global connectivity diff test: 0.071
nct_results$einv.pvals     #p values testing diffs for all individual edges: lowest p-value 0.017, most = 1
sum(nct_results$einv.pvals$"p-value" < 0.05)  # how many edges are different0


```

### GGM BCTs & motivation 

```{r}
library(corrgram)

nItems <- 19

bctdf <- df %>% dplyr::select(id,
  intervention,
  group,
  school,
  girl,
  'Autonomous' = PA_autonomous_T1,
  'Controlled' = PA_controlled_T1,
  'goal setting' = PA_agrbct_01_T1,
  'implementation plan' = PA_agrbct_02_T1,
  'plan by other' = PA_agrbct_03_T1,
  'reminder of plan' = PA_agrbct_04_T1,
  'subgoals' = PA_agrbct_05_T1,
  'new PA options' = PA_agrbct_06_T1,
  'barrier identification' = PA_agrbct_07_T1,
  'coping planning' = PA_agrbct_08_T1,
  'PA identity' = PA_agrbct_09_T1,
  'PA life values' = PA_agrbct_10_T1,
  'positive consequences' = PA_frqbct_01_T1,
  'log on paper' = PA_frqbct_02_T1,
  'smartphone' = PA_frqbct_03_T1,
#  'mnemonic cues' = PA_frqbct_04_T1,
  'goal contrast' = PA_frqbct_05_T1,
  'relevance of PA' = PA_frqbct_06_T1,
  'changes at home' = PA_frqbct_07_T1,
  'social support' = PA_frqbct_08_T1,
  'failure contemplated' = PA_frqbct_09_T1) %>%
  rowwise() %>% 
  mutate( 
  #'has plan' = mean(c(`implementation plan`, `plan by other`), na.rm = TRUE),
  'monitored PA' = mean(c(`log on paper`, `smartphone`), na.rm = TRUE)) %>%
  select(-`log on paper`, -`smartphone`) %>% 
  data.frame %>% 
  mutate_all(as.numeric)

# Network for all participants

S.total <- bctdf %>% select(`Autonomous`:ncol(bctdf))
nwBCT <- bootnet::estimateNetwork(S.total, default="EBICglasso")

# Plot correlations (minmax crowds the diagonal as it plots the minimum and maximum values for each variable).
labs <- colnames(S.total)
corrgram::corrgram(S.total, 
         cor.method = "spearman", 
         # diag.panel=panel.minmax, 
         # lower.panel=panel.shade, 
         # lower.panel=panel.ellipse,
         # lower.panel=panel.cor,
         upper.panel=panel.conf,
         lower.panel=panel.pie,
         outer.labels=list(
           bottom=list(labels=labs,cex=.75, srt=60),
           left=list(labels=labs,cex=.75, srt=30))
         )

labs <- colnames(S.total)
corrgram::corrgram(S.total, 
         cor.method = "spearman",
         upper.panel=panel.ellipse,
         lower.panel=panel.pie,
         outer.labels=list(
           bottom=list(labels=labs,cex=.75, srt=60),
           left=list(labels=labs,cex=.75, srt=30))
         )

# Create means for filling nodes
piefill <- S.total %>%
  summarise_all(funs(median(., na.rm = TRUE) / 6)) 

# Plot network
plot(nwBCT, layout = "spring", label.scale = FALSE, title = "GGM, BCTs & motivation", label.cex = 0.75,
     pie = piefill, 
     color = "skyblue",
     pieBorder = 1)

# Combine items further:
bctdf2 <- bctdf %>% rowwise %>% 
  mutate('goals and plans' = mean(c(`goal.setting`, `implementation.plan`), na.rm = TRUE)) %>% 
  mutate('barriers identified\nand planned for' = mean(c(`barrier.identification`, `coping.planning`), na.rm = TRUE)) %>% 
  select(-`goal.setting`, -`implementation.plan`, -`barrier.identification`, -`coping.planning`) %>% 
  data.frame

S.total2 <- bctdf2 %>% select(`Autonomous`:ncol(bctdf2))
nwBCT2 <- bootnet::estimateNetwork(S.total2, default="EBICglasso")

# Create means for filling nodes
piefill2 <- S.total2 %>%
  mutate(Autonomous = Autonomous * 6/5, # Transform these from scale 1-5 to 1-6
         Controlled = Controlled * 6/5) %>% 
  summarise_all(funs(median(., na.rm = TRUE) / 6)) 

# Plot network
plot(nwBCT2, layout = "spring", label.scale = FALSE, title = "GGM, BCTs & motivation", label.cex = 0.75,
     pie = piefill2, 
     color = "skyblue",
     pieBorder = 1)

bctdf %>% dplyr::select(-girl, -Autonomous, -group, -id, -school, -Controlled) %>% skim()
```



#### Stability and robustness

Robustness test 

```{r bct-robustness}

qgraph::centralityPlot(nwBCT)
qgraph::centralityPlot(nwBCT2)

BCTboot1 <- bootnet::bootnet(nwBCT, nBoots = 2500)
BCTboot2 <- bootnet::bootnet(nwBCT2, nBoots = 2500)

# save(BCTboot1, file = "BCTboot1.Rdata")
# save(BCTboot2, file = "BCTboot2.Rdata")

load("BCTboot1.Rdata")

plot(BCTboot1, labels = TRUE, order = "sample")

plot(BCTboot2, labels = TRUE, order = "sample")

autEdges <- summary(BCTboot1, statistics = "edge", rank = TRUE) %>% 
  dplyr::arrange(mean) %>% 
  dplyr::filter(stringr::str_detect(node1, 'Autonomous')) %>% # str_detect(id, 'Autonomous|Controlled') for both
  dplyr::filter(!(node2 == 'Controlled')) %>% 
  data.frame() %>% 
  select(CIlower, mean, CIupper, node2)

contEdges <- summary(BCTboot1, statistics = "edge", rank = TRUE) %>% 
  dplyr::arrange(mean) %>% 
  dplyr::filter(stringr::str_detect(node1, 'Controlled')) %>% # str_detect(id, 'Autonomous|Controlled') for both
  data.frame() %>% 
  select(CIlower, mean, CIupper, node2)

diamondPlot(autEdges, 
            ciCols = c("CIlower", "mean", "CIupper"), 
            color = viridis::viridis(2, end = 0.8)[1], 
            alpha = 0.3, 
            yLabels = autEdges$node2, 
            fixedSize = 0.3, 
            xlab = NULL) +
  userfriendlyscience::diamondPlot(contEdges, 
              ciCols = c("CIlower", "mean", "CIupper"), 
              color = viridis::viridis(2, end = 0.8)[2], 
              alpha = 0.3, 
              yLabels = autEdges$node2, 
              fixedSize = 0.3, 
              xlab = NULL, 
              returnLayerOnly = TRUE) +
  geom_rect(aes(xmin=Inf, xmax=Inf, ymin=Inf, ymax=Inf, fill = "Controlled"), 
            colour=NA, alpha=0.05) + # Create invisible rectangle for legend
  geom_rect(aes(xmin=Inf, xmax=Inf, ymin=Inf, ymax=Inf, fill = "Autonomous"), 
            colour=NA, alpha=0.05) + # Create invisible rectangle for legend
  scale_fill_manual('Connected node',
                      values = viridis::viridis(2, end = 0.8)[1:2],  
                      guide = guide_legend(override.aes = list(alpha = 1))) +
  ggtitle("Relative strengths of edges containing autonomous \nor controlled motivation (all items)")
  
# Combined items

autEdges <- summary(BCTboot2, statistics = "edge", rank = TRUE) %>% 
  dplyr::arrange(mean) %>% 
  dplyr::filter(stringr::str_detect(node1, 'Autonomous')) %>% # str_detect(id, 'Autonomous|Controlled') for both
  dplyr::filter(!(node2 == 'Controlled')) %>% 
  data.frame() %>% 
  select(CIlower, mean, CIupper, node2)

contEdges <- summary(BCTboot2, statistics = "edge", rank = TRUE) %>% 
  dplyr::arrange(mean) %>% 
  dplyr::filter(stringr::str_detect(node1, 'Controlled')) %>% # str_detect(id, 'Autonomous|Controlled') for both
  data.frame() %>% 
  select(CIlower, mean, CIupper, node2)

diamondPlot(autEdges, 
            ciCols = c("CIlower", "mean", "CIupper"), 
            color = viridis::viridis(2, end = 0.8)[1], 
            alpha = 0.3, 
            yLabels = autEdges$node2, 
            fixedSize = 0.3, 
            xlab = NULL) +
  userfriendlyscience::diamondPlot(contEdges, 
              ciCols = c("CIlower", "mean", "CIupper"), 
              color = viridis::viridis(2, end = 0.8)[2], 
              alpha = 0.3, 
              yLabels = autEdges$node2, 
              fixedSize = 0.3, 
              xlab = NULL, 
              returnLayerOnly = TRUE) +
  geom_rect(aes(xmin=Inf, xmax=Inf, ymin=Inf, ymax=Inf, fill = "Controlled"), 
            colour=NA, alpha=0.05) + # Create invisible rectangle for legend
  geom_rect(aes(xmin=Inf, xmax=Inf, ymin=Inf, ymax=Inf, fill = "Autonomous"), 
            colour=NA, alpha=0.05) + # Create invisible rectangle for legend
  scale_fill_manual('Connected node',
                      values = viridis::viridis(2, end = 0.8)[1:2],  
                      guide = guide_legend(override.aes = list(alpha = 1))) +
  ggtitle("Relative strengths of edges containing autonomous \nor controlled motivation (combined items)")

# summary(BCTboot1, statistics = "edge", rank = TRUE) %>% 
#   dplyr::arrange(mean) %>% 
#   dplyr::filter(stringr::str_detect(id, 'Controlled')) %>%
#   data.frame() %>% 
#   select(CIlower, mean, CIupper, id) %>% 
#   userfriendlyscience::diamondPlot(ciCols = c("CIlower", "mean", "CIupper"), ylabels = id)

```

Sacha says this makes sense, you can also do the difference test (same as the plot with black and white squares) and look at Jonas Haslbeck's node importance R^2 thing. You can also just see what happens when you include PA (common effect). 

#### #### Add PA

```{r}
library(corrgram)

nItems_PA <- 20

bctdf_PA <- df %>% dplyr::select(id,
  intervention,
  group,
  school,
  girl,
  'MVPA' = paAccelerometer_T1,
  'Autonomous' = PA_autonomous_T1,
  'Controlled' = PA_controlled_T1,
  'goal setting' = PA_agrbct_01_T1,
  'implementation plan' = PA_agrbct_02_T1,
  'plan by other' = PA_agrbct_03_T1,
  'reminder of plan' = PA_agrbct_04_T1,
  'subgoals' = PA_agrbct_05_T1,
  'new PA options' = PA_agrbct_06_T1,
  'barrier identification' = PA_agrbct_07_T1,
  'coping planning' = PA_agrbct_08_T1,
  'PA identity' = PA_agrbct_09_T1,
  'PA life values' = PA_agrbct_10_T1,
  'positive consequences' = PA_frqbct_01_T1,
  'log on paper' = PA_frqbct_02_T1,
  'smartphone' = PA_frqbct_03_T1,
#  'mnemonic cues' = PA_frqbct_04_T1,
  'goal contrast' = PA_frqbct_05_T1,
  'relevance of PA' = PA_frqbct_06_T1,
  'changes at home' = PA_frqbct_07_T1,
  'social support' = PA_frqbct_08_T1,
  'failure contemplated' = PA_frqbct_09_T1) %>%
  rowwise() %>% 
  mutate( 
  #'has plan' = mean(c(`implementation plan`, `plan by other`), na.rm = TRUE),
  'monitored PA' = mean(c(`log on paper`, `smartphone`), na.rm = TRUE)) %>%
  select(-`log on paper`, -`smartphone`) %>% 
  data.frame %>% 
  mutate_all(as.numeric)

# Network for all participants

S.total_PA <- bctdf_PA %>% select(`MVPA`:ncol(bctdf))
nwBCT_PA <- bootnet::estimateNetwork(S.total_PA, default="EBICglasso")

labs <- colnames(S.total_PA)

# Create means for filling nodes
piefill <- S.total_PA %>% 
  select(-contains("MVPA")) %>% 
  summarise_all(funs(median(., na.rm = TRUE) / 6)) 

piefill$MVPA <- median(S.total_PA$MVPA, na.rm = TRUE) / (60*24) 

piefill <- piefill %>% select(MVPA, everything())

# Plot network
plot(nwBCT_PA, layout = "spring", label.scale = FALSE, title = "GGM: PA, BCTs & motivation", label.cex = 0.75,
     pie = piefill, 
     color = "skyblue",
     pieBorder = 1)

# Combine items further:
bctdf_PA2 <- bctdf_PA %>% rowwise %>% 
  mutate('goals and plans' = mean(c(`goal.setting`, `implementation.plan`), na.rm = TRUE)) %>% 
  mutate('barriers identified\nand planned for' = mean(c(`barrier.identification`, `coping.planning`), na.rm = TRUE)) %>% 
  select(-`goal.setting`, -`implementation.plan`, -`barrier.identification`, -`coping.planning`) %>% 
  data.frame

S.total_PA2 <- bctdf_PA2 %>% select(MVPA:ncol(bctdf_PA2))
nwBCT_PA2 <- bootnet::estimateNetwork(S.total_PA2, default="EBICglasso")

# Create means for filling nodes
piefill_PA2 <- S.total_PA2 %>% 
  select(-contains("MVPA")) %>%
  mutate(Autonomous = Autonomous * 6/5, # Transform these from scale 1-5 to 1-6
         Controlled = Controlled * 6/5) %>% 
  summarise_all(funs(median(., na.rm = TRUE) / 6)) 

piefill_PA2$MVPA <- median(S.total_PA2$MVPA, na.rm = TRUE) / (60*24) 

piefill_PA2 <- piefill_PA2 %>% select(MVPA, everything())


# Plot network
plot(nwBCT_PA2, layout = "spring", label.scale = FALSE, title = "GGM: PA BCTs & motivation", label.cex = 0.75,
     pie = piefill_PA2, 
     color = "skyblue",
     pieBorder = 1)


```


#### BCT-SDT Regression analyses

Here's the classical linear model.

```{r}
library(broom)

bctdf <- df %>% dplyr::select(id,
  intervention,
  group,
  school,
  girl,
  'Autonomous' = PA_autonomous_T1,
  'Controlled' = PA_controlled_T1,
  'Intrinsic' = PA_intrinsic_T1,
  'Identified' = PA_identified_T1,
  'Integrated' = PA_integrated_T1,
  'Introjected' = PA_introjected_T1,
  'Extrinsic' = PA_extrinsic_T1,
  'goal setting' = PA_agrbct_01_T1,
  'implementation plan' = PA_agrbct_02_T1,
  'plan by other' = PA_agrbct_03_T1,
  'reminder of plan' = PA_agrbct_04_T1,
  'subgoals' = PA_agrbct_05_T1,
  'new PA options' = PA_agrbct_06_T1,
  'barrier identification' = PA_agrbct_07_T1,
  'coping planning' = PA_agrbct_08_T1,
  'PA identity' = PA_agrbct_09_T1,
  'PA life values' = PA_agrbct_10_T1,
  'positive consequences' = PA_frqbct_01_T1,
  'log on paper' = PA_frqbct_02_T1,
  'smartphone' = PA_frqbct_03_T1,
#  'mnemonic cues' = PA_frqbct_04_T1,
  'goal contrast' = PA_frqbct_05_T1,
  'relevance of PA' = PA_frqbct_06_T1,
  'changes at home' = PA_frqbct_07_T1,
  'social support' = PA_frqbct_08_T1,
  'failure contemplated' = PA_frqbct_09_T1) %>%
  rowwise() %>% 
  mutate( 
  #'has plan' = mean(c(`implementation plan`, `plan by other`), na.rm = TRUE),
  'monitored PA' = mean(c(`log on paper`, `smartphone`), na.rm = TRUE)) %>%
  select(-`log on paper`, -`smartphone`) %>% 
  data.frame # %>% 
  # mutate_all(as.numeric)

outcomevars <- c('Autonomous', 
  'Controlled', 
  'Intrinsic',
  'Identified', 
  'Integrated', 
  'Introjected',
  'Extrinsic')

for (i in outcomevars) {
m <- lm(paste0(i, " ~ 
  goal.setting +
  implementation.plan +
  plan.by.other +
  reminder.of.plan +
  subgoals +
  new.PA.options +
  barrier.identification +
  coping.planning +
  PA.identity +
  PA.life.values +
  positive.consequences"), 
  data = bctdf)

cat("\n\nEstimates for", i, "regulation", sep = " ")
summary(m) %>% broom::tidy() %>% dplyr::arrange(desc(estimate)) %>% apa_table() 
}


```


## Centrality stability

```{r}
boot2 <- bootnet::bootnet(Network1, nBoots = 2500, type = "case")
bootnet::corStability(boot2)

plot(boot2)

differenceTest(boot1, "auton", "intent",  measure = c("strength", "closeness", "betweenness"))

plot(boot1, "edge", plot = "difference", onlyNonZero = TRUE, order = "sample")

plot(boot1, "strength")
plot(boot1, "betweenness")
plot(boot1, "closeness")
```

## PA determinants: unregularised correlations visualised

```{r}
# Network without motivation variables
data <- df %>% select('PA' = paAccelerometer_T1, 'SB' = sitLieAccelerometer_T1,
'fat%' = fatpct_T1,'action planning' = PA_actionplan_T1, 'coping planning' = PA_copingplan_T1, 'frequency-related BCTs' = PA_frqbct_T1, 'agreement-related BCTs' = PA_agrbct_T1, 'amotivation' = PA_amotivation_T1, 'autonomous motivation' = PA_autonomous_T1, 'controlled motivation' = PA_controlled_T1, 'descriptive norm' = PA_dnorm_T1, 'injunctive norm' = PA_inorm_T1, 'intention' = PA_intention_T1, 'outcome expectations' = PA_oexp_T1, 'self-efficacy / PBC' = PA_sePbc_T1, 'perceived opportunities' = PA_opportunities_T1) %>% 
  data.frame

names <- df %>% select('PA' = paAccelerometer_T1, 'SB' = sitLieAccelerometer_T1,
'fat%' = fatpct_T1,'action planning' = PA_actionplan_T1, 'coping planning' = PA_copingplan_T1, 'frequency-related BCTs' = PA_frqbct_T1, 'agreement-related BCTs' = PA_agrbct_T1, 'amotivation' = PA_amotivation_T1, 'autonomous motivation' = PA_autonomous_T1, 'controlled motivation' = PA_controlled_T1, 'descriptive norm' = PA_dnorm_T1, 'injunctive norm' = PA_inorm_T1, 'intention' = PA_intention_T1, 'outcome expectations' = PA_oexp_T1, 'self-efficacy / PBC' = PA_sePbc_T1, 'perceived opportunities' = PA_opportunities_T1) %>% names

# Spinglass algorithm detects communities. Tutorial here: http://psych-networks.com/r-tutorial-identify-communities-items-networks/

cormatrix <- cor_auto(data) 

graph1 <- qgraph(cormatrix, layout="spring", sampleSize = nrow(data),
              vsize=7, cut=0, maximum=.45, border.width=1.5)

g <- as.igraph(graph1, attributes = TRUE)

matrix_spinglass <- matrix(NA, nrow=1,ncol=100)
 
for (i in 1:100) {
set.seed(i)
spinglass <- spinglass.community(g)
matrix_spinglass[1,i] <- max(spinglass$membership) 
}

set.seed(1)

sgc <- spinglass.community(g)

communities <- data.frame(sgc$membership, 'node number' = 1:ncol(data))

group.spinglass <- list(communities$node.number[communities$sgc.membership == 1], 
                       communities$node.number[communities$sgc.membership == 2])

piefill <- data %>%
  summarise_all(funs(mean(., na.rm = TRUE))) %>% 
  mutate_at(vars(PA, SB),
            funs(. / (24*60))) %>% # proportion of day used doing the behaviour
  mutate_at(vars(action.planning, coping.planning),
            funs(. / 4)) %>% 
  mutate_at(vars(6:ncol(data)),
            funs(. / 7)) %>% 
  mutate_at(vars(fat.),
            funs(. / 100))  

qgraph(graph1, layout = "spring", labels = TRUE, groups = group.spinglass, 
     color=c("olivedrab2", "orange", "lightblue"),
     label.cex = 0.75,
     label.scale = TRUE,
     pie = piefill, 
     color = "skyblue",
     nodeNames = names,
     pieBorder = 1,
     legend.cex = 0.4)


# plot(nwAll, groups = itemGroups, nodeNames = itemNames, legend.cex = 0.25)



lmi %>% select(Kys0016.1, Kys0013.1) %>% group_by(Kys0016.1) %>% summarise(n = n())

lmi %>% count(Kys0016.1, Kys0013.1) %>% group_by(Kys0016.1)
```

<!-- Out of a hundred iterations, spinglass algorithm found `  table(matrix_spinglass)[[1]]` instances of ` table(matrix_spinglass)[1] %>% names` communities, `  table(matrix_spinglass)[[2]]` instances of `  table(matrix_spinglass)[2] %>% names` communities, and `  table(matrix_spinglass)[[3]]` instances of `  table(matrix_spinglass)[3] %>% names` communities. Thus, a random seed which found four communities was chosen.   -->

## Symptom network: all

```{r}

sympdf <- df %>% dplyr::select(id,
  intervention,
  group,
  school,
  girl,
  "Neck and shoulder pain" = symptom_neckShoulderPain_T1,
  "Lower back pain" = symptom_lowerBackPain_T1,
  "Stomach ache" = symptom_stomachAche_T1,
  "Tension or nervousness" = symptom_tensionNervousness_T1,
  "Irritability or anger bursts" = symptom_irritabilityAngerbursts_T1,
  "Difficulty with sleep" = symptom_sleepDifficulty_T1,
  "Headache" = symptom_headAche_T1,
  "Tiredness or faintness" = symptom_tirednessFaintness_T1,
  "Fat pct" = fatpct_T1,
  "PA" = paAccelerometer_T1,
  "SB" = sitLieAccelerometer_T1
) %>% 
  mutate(
    'Neck and shoulder pain' = ifelse(`Neck and shoulder pain` == 1, 0, 1),
    'Lower back pain' = ifelse(`Lower back pain` == 1, 0, 1),
    'Stomach ache' = ifelse(`Stomach ache` == 1, 0, 1),
    'Tension or nervousness' = ifelse(`Tension or nervousness` == 1, 0, 1),
    'Irritability or anger bursts' = ifelse(`Irritability or anger bursts` == 1, 0, 1),
    'Difficulty with sleep' = ifelse(`Difficulty with sleep` == 1, 0, 1),
    'Headache' = ifelse(`Headache` == 1, 0, 1),
    'Tiredness or faintness' = ifelse(`Tiredness or faintness` == 1, 0, 1),
    'Fat pct' = `Fat pct` / 100) %>% 
  data.frame

S.all <- sympdf %>% select(6:ncol(sympdf)) %>% na.omit(.) 

nwAll <- bootnet::estimateNetwork(S.all, default="mgm")

allmeans <- sympdf %>%  
  summarise_at(vars(6:16),
  funs(mean(., na.rm = TRUE))) %>%  
  mutate_at(vars(PA, SB),
            funs(. / (24*60)))  # proportion of day used doing the behaviour


plot(nwAll, label.scale = FALSE, title = "All", label.cex = 0.75, 
     pie = allmeans, 
     color = "skyblue",
     pieBorder = 1)


```


## Symptom network: boys and girls

```{r}

sympdf <- df %>% dplyr::select(id,
  intervention,
  group,
  school,
  girl,
  "Neck and shoulder pain" = symptom_neckShoulderPain_T1,
  "Lower back pain" = symptom_lowerBackPain_T1,
  "Stomach ache" = symptom_stomachAche_T1,
  "Tension or nervousness" = symptom_tensionNervousness_T1,
  "Irritability or anger bursts" = symptom_irritabilityAngerbursts_T1,
  "Difficulty with sleep" = symptom_sleepDifficulty_T1,
  "Headache" = symptom_headAche_T1,
  "Tiredness or faintness" = symptom_tirednessFaintness_T1,
  "Fat pct" = fatpct_T1,
  "PA" = paAccelerometer_T1,
  "SB" = sitLieAccelerometer_T1
) %>% 
  mutate(
    'Neck and shoulder pain' = ifelse(`Neck and shoulder pain` == 1, 0, 1),
    'Lower back pain' = ifelse(`Lower back pain` == 1, 0, 1),
    'Stomach ache' = ifelse(`Stomach ache` == 1, 0, 1),
    'Tension or nervousness' = ifelse(`Tension or nervousness` == 1, 0, 1),
    'Irritability or anger bursts' = ifelse(`Irritability or anger bursts` == 1, 0, 1),
    'Difficulty with sleep' = ifelse(`Difficulty with sleep` == 1, 0, 1),
    'Headache' = ifelse(`Headache` == 1, 0, 1),
    'Tiredness or faintness' = ifelse(`Tiredness or faintness` == 1, 0, 1),
    'Fat pct' = `Fat pct` / 100) %>% 
  data.frame

S.boys <- sympdf %>% filter(girl == 0) %>% select(6:ncol(sympdf)) %>% na.omit(.) 
S.girls <- sympdf %>% filter(girl == 1) %>% select(6:ncol(sympdf)) %>% na.omit(.)
nwBoys <- bootnet::estimateNetwork(S.boys, default="mgm")
nwGirls <- bootnet::estimateNetwork(S.girls, default="mgm")

girlmeans <- sympdf %>% group_by(girl) %>% 
  summarise_at(vars(5:15),
  funs(mean(., na.rm = TRUE))) %>% 
  filter(girl == 1) %>% 
  mutate_at(vars(PA, SB),
            funs(. / (24*60))) %>% # proportion of day used doing the behaviour
  select(-1)

boymeans <- sympdf %>% group_by(girl) %>% 
  summarise_at(vars(5:15),
  funs(mean(., na.rm = TRUE))) %>% 
  filter(girl == 0) %>% 
  mutate_at(vars(PA, SB),
            funs(. / (24*60))) %>% # proportion of day used doing the behaviour
  select(-1)


layout(t(1:2))
plot(nwGirls, label.scale = FALSE, title = "Girls", label.cex = 0.75,
     pie = girlmeans, 
     color = "skyblue",
     pieBorder = 1)

plot(nwBoys, label.scale = FALSE, title = "Boys", label.cex = 0.75, 
     pie = boymeans, 
     color = "skyblue",
     pieBorder = 1)


```

## symptom network: educational tracks

```{r}
library(bootnet)
library(qgraph)
library(tidyverse)

sympdf <- df %>% dplyr::select(id,
  intervention,
  track,
  school,
  girl,
  "Neck and shoulder pain" = symptom_neckShoulderPain_T1,
  "Lower back pain" = symptom_lowerBackPain_T1,
  "Stomach ache" = symptom_stomachAche_T1,
  "Tension or nervousness" = symptom_tensionNervousness_T1,
  "Irritability or anger bursts" = symptom_irritabilityAngerbursts_T1,
  "Difficulty with sleep" = symptom_sleepDifficulty_T1,
  "Headache" = symptom_headAche_T1,
  "Tiredness or faintness" = symptom_tirednessFaintness_T1,
  "Fat pct" = fatpct_T1,
  "PA" = paAccelerometer_T1,
  "SB" = sitLieAccelerometer_T1
) %>% 
  mutate(
    'Neck and shoulder pain' = ifelse(`Neck and shoulder pain` == 1, 0, 1),
    'Lower back pain' = ifelse(`Lower back pain` == 1, 0, 1),
    'Stomach ache' = ifelse(`Stomach ache` == 1, 0, 1),
    'Tension or nervousness' = ifelse(`Tension or nervousness` == 1, 0, 1),
    'Irritability or anger bursts' = ifelse(`Irritability or anger bursts` == 1, 0, 1),
    'Difficulty with sleep' = ifelse(`Difficulty with sleep` == 1, 0, 1),
    'Headache' = ifelse(`Headache` == 1, 0, 1),
    'Tiredness or faintness' = ifelse(`Tiredness or faintness` == 1, 0, 1),
    'Fat pct' = `Fat pct` / 100) %>% 
  data.frame

# S.other <- sympdf %>% filter(track == "Other") %>% select(6:ncol(sympdf)) %>% na.omit(.)
# S.it <- sympdf %>% filter(track == "Business IT") %>% select(6:ncol(sympdf))
# S.admin <- sympdf %>% filter(track == "Business Admin") %>% select(6:ncol(sympdf))
# S.hrc <- sympdf %>% filter(track == "HRC") %>% select(6:ncol(sympdf))
# S.nursing <- sympdf %>% filter(track == "Nursing") %>% select(6:ncol(sympdf))

# S.other <- sympdf %>% filter(track == 1) %>% select(6:ncol(sympdf))
S.it <- sympdf %>% filter(track == 2) %>% select(6:ncol(sympdf))
S.admin <- sympdf %>% filter(track == 3) %>% select(6:ncol(sympdf))
S.hrc <- sympdf %>% filter(track == 4) %>% select(6:ncol(sympdf))
S.nursing <- sympdf %>% filter(track == 5) %>% select(6:ncol(sympdf))

# nwOther <- bootnet::estimateNetwork(S.other, default="mgm")
nwIt <- bootnet::estimateNetwork(S.it, default="mgm")
nwAdmin <- bootnet::estimateNetwork(S.admin, default="mgm")
nwHrc <- bootnet::estimateNetwork(S.hrc, default="mgm")
nwNursing <- bootnet::estimateNetwork(S.nursing, default="mgm")

# othermeans <- sympdf %>% group_by(track) %>% 
#   summarise_at(vars(5:15),
#   funs(mean(., na.rm = TRUE))) %>% 
#   filter(track == "Other") %>% 
#   mutate_at(vars(PA, SB),
#             funs(. / (24*60))) %>% # proportion of day used doing the behaviour
#   select(-1)

# itmeans <- sympdf %>% group_by(track) %>% 
#   summarise_at(vars(5:15),
#   funs(mean(., na.rm = TRUE))) %>% 
#   filter(track == "Business IT") %>% 
#   mutate_at(vars(PA, SB),
#             funs(. / (24*60))) %>% # proportion of day used doing the behaviour
#   select(-1)

itmeans <- sympdf %>% group_by(track) %>% 
  summarise_at(vars(5:15),
  funs(mean(., na.rm = TRUE))) %>% 
  filter(track == 2) %>% 
  mutate_at(vars(PA, SB),
            funs(. / (24*60))) %>% # proportion of day used doing the behaviour
  select(-1)

# adminmeans <- sympdf %>% group_by(track) %>% 
#   summarise_at(vars(5:15),
#   funs(mean(., na.rm = TRUE))) %>% 
#   filter(track == "Business Admin") %>% 
#   mutate_at(vars(PA, SB),
#             funs(. / (24*60))) %>% # proportion of day used doing the behaviour
#   select(-1)

adminmeans <- sympdf %>% group_by(track) %>% 
  summarise_at(vars(5:15),
  funs(mean(., na.rm = TRUE))) %>% 
  filter(track == 3) %>% 
  mutate_at(vars(PA, SB),
            funs(. / (24*60))) %>% # proportion of day used doing the behaviour
  select(-1)

# hrcmeans <- sympdf %>% group_by(track) %>% 
#   summarise_at(vars(5:15),
#   funs(mean(., na.rm = TRUE))) %>% 
#   filter(track == "HRC") %>% 
#   mutate_at(vars(PA, SB),
#             funs(. / (24*60))) %>% # proportion of day used doing the behaviour
#   select(-1)

hrcmeans <- sympdf %>% group_by(track) %>% 
  summarise_at(vars(5:15),
  funs(mean(., na.rm = TRUE))) %>% 
  filter(track == 4) %>% 
  mutate_at(vars(PA, SB),
            funs(. / (24*60))) %>% # proportion of day used doing the behaviour
  select(-1)

# nursingmeans <- sympdf %>% group_by(track) %>% 
#   summarise_at(vars(5:15),
#   funs(mean(., na.rm = TRUE))) %>% 
#   filter(track == "Nursing") %>% 
#   mutate_at(vars(PA, SB),
#             funs(. / (24*60))) %>% # proportion of day used doing the behaviour
#   select(-1)

nursingmeans <- sympdf %>% group_by(track) %>% 
  summarise_at(vars(5:15),
  funs(mean(., na.rm = TRUE))) %>% 
  filter(track == 5) %>% 
  mutate_at(vars(PA, SB),
            funs(. / (24*60))) %>% # proportion of day used doing the behaviour
  select(-1)

averagelayout <- averageLayout(nwIt, nwAdmin, nwHrc, nwNursing)
# plot(nwOther, label.scale = FALSE, title = "Girls", label.cex = 0.75,
#      pie = othermeans, 
#      color = "skyblue",
#      pieBorder = 1)

layout(t(1:4))
plot(nwIt, label.scale = FALSE, title = "Business IT", layout = averagelayout, label.cex = 0.75, 
     pie = itmeans, 
     color = "skyblue",
     pieBorder = 1)

plot(nwAdmin, label.scale = FALSE, title = "Business admin", layout = averagelayout, label.cex = 0.75, 
     pie = adminmeans, 
     color = "skyblue",
     pieBorder = 1)

plot(nwHrc, label.scale = FALSE, title = "Hotel, restaurant and catering", layout = averagelayout, label.cex = 0.75, 
     pie = hrcmeans, 
     color = "skyblue",
     pieBorder = 1)

plot(nwNursing, label.scale = FALSE, title = "Nursing", layout = averagelayout, label.cex = 0.75, 
     pie = nursingmeans, 
     color = "skyblue",
     pieBorder = 1)




```


```{r}

colfill <- c(1,2,3,4,5)

# Create data frame
densplot <- d
levels(densplot$intervention) <- list("Intervention" = "1", "Control" = "0")
levels(densplot$girl) <- list("Girl" = "1", "Boy" = "0")

# This gives side-by-side plots
layout(t(1:2), 1)

# Intervention vs. control
# Choose only the variables needed and drop NA
dens <- densplot %>% select(fatpct_T1, intervention) %>% 
  filter(complete.cases(.))

# Set random number generator for reproducibility of bootstrap test of equal densities
set.seed(10)

# Make plot
sm.fatpct_T1_1 <- sm.density.compare2(as.numeric(dens$fatpct_T1), as.factor(dens$intervention), xlab="Percentage", col=colfill, lty=c(1,2), bandcol='LightGray', model="equal", lwd=(c(2,2)))
legend("topright", levels(dens$intervention), fill=c(1, 2))

# Girls vs. boys
# Choose only the variables needed and drop NA
dens <- densplot %>% select(fatpct_T1, girl) %>% 
  filter(complete.cases(.))

# Set random number generator for reproducibility of bootstrap test of equal densities
set.seed(10)

# Make plot
sm.fatpct_T1_2 <- sm.density.compare2(as.numeric(dens$fatpct_T1), as.factor(dens$girl), xlab="Percentage", col=colfill, lty=c(1,2), bandcol='LightGray', model="equal", lwd=(c(2,2)))
legend("topright", levels(dens$girl), fill=c(1, 2))

sm.fatpct_T1_2 <- sm.density.compare2(as.numeric(dens$fatpct_T1), as.factor(dens$girl), xlab="Percentage", col=colfill, lty=c(1,2), bandcol='LightGray', model="equal", lwd=(c(2,2)))
legend("topright", levels(dens$girl), fill=c(1, 2))
```



# Physical activity network

```{r}

data <- df %>% select(PA = paAccelerometer_T1, actCop = actcop_T1, BCT = frqbct_T1, amot = amotivation_T1, auton = autonomous_T1, cont = controlled_T1, dnorm = dnorm_T1, fatpct = fatpct_T1, inorm = inorm_T1, intent = intention_T1, oexp = oexp_T1, opp = opportunities_T1, sePbc = sePbc_T1) %>% data.frame() 

# Spinglass algorithm detects communities. Tutorial here: http://psych-networks.com/r-tutorial-identify-communities-items-networks/

qgraph(cor_auto(data), layout="spring")

cormatrix <- cor_auto(data1)

graph1 <- qgraph(cormatrix, graph="glasso", layout="spring", sampleSize = nrow(data),
              vsize=7, cut=0, maximum=.45, border.width=1.5)

g = as.igraph(graph1, attributes=TRUE)

sgc <- spinglass.community(g)

sgc$membership

group.spinglass<- list(c(1, 2, 3, 5, 10), 
                       c(4, 6, 8), 
                       c(7, 9), 
                       c(11, 12, 13))

set.seed(2)

network1 <- bootnet::estimateNetwork(data1, default="EBICglasso")

#bladibla <- averageLayout(network1$graph, network2$graph)

# layout(t(1:2))
# graph1 <- plot(network1, layout=bladibla, cut=0)
# graph2 <- plot(network2, layout=bladibla, cut=0)
# graph1 <- plot(network1, cut=0)
# graph2 <- plot(network2, cut=0)

plot(network1, layout = "spring", labels = TRUE, groups = group.spinglass, color=c("olivedrab2", "orange", "mediumpurple1", "lightblue"))


```

### PA network without SDT motivations

```{r}
# Network without motivation variables
data <- df %>% select(PA = paAccelerometer_T1, actCop = PA_actcop_T1, BCT = PA_frqbct_T1, amot = PA_amotivation_T1, auton = PA_autonomous_T1, cont = PA_controlled_T1, dnorm = PA_dnorm_T1, fatpct = fatpct_T1, inorm = PA_inorm_T1, intent = PA_intention_T1, oexp = PA_oexp_T1, opp = PA_opportunities_T1, sePbc = PA_sePbc_T1) %>% data.frame() %>% 
  select(-auton, -cont, -amot)

# Spinglass algorithm detects communities. Tutorial here: http://psych-networks.com/r-tutorial-identify-communities-items-networks/

cormatrix <- cor_auto(data)

graph1<-qgraph(cormatrix, graph="glasso", layout="spring", sampleSize = nrow(data),
              vsize=7, cut=0, maximum=.45, border.width=1.5)

g = as.igraph(graph1, attributes=TRUE)

sgc <- spinglass.community(g)

sgc$membership

# Without SDT motivations
group.spinglass<- list(c(1, 2, 3, 7), 
                       c(4, 6), 
                       c(5), 
                       c(8, 9, 10))

set.seed(2)

network1 <- bootnet::estimateNetwork(data, default="EBICglasso")

plot(network1, layout = "spring", labels = TRUE, groups = group.spinglass, color=c("olivedrab2", "orange", "mediumpurple1", "lightblue"))

```

### PA network without BCTs and SDT

```{r}
# Network without motivation variables
data <- df %>% select(PA = paAccelerometer_T1, 'action and coping planning' = PA_actcop_T1, 'Frequency-related BCTs' = PA_frqbct_T1, 'amotivation' = PA_amotivation_T1, 'autonomous motivation' = PA_autonomous_T1, 'controlled motivation' = PA_controlled_T1, 'descriptive norm' = PA_dnorm_T1, 'injunctive norm' = PA_inorm_T1, "fat pct" = fatpct_T1, 'intention' = PA_intention_T1, 'outcome expectations' = PA_oexp_T1, 'Self-efficacy / PBC' = PA_sePbc_T1, 'perceived opportunities' = PA_opportunities_T1) %>% 
            select(-`autonomous motivation`, -`controlled motivation`, -`amotivation`, -`Frequency-related BCTs`) %>% 
  data.frame

# Spinglass algorithm detects communities. Tutorial here: http://psych-networks.com/r-tutorial-identify-communities-items-networks/

cormatrix <- cor_auto(data)

graph1 <- qgraph(cormatrix, graph="glasso", layout="spring", sampleSize = nrow(data),
              vsize=7, cut=0, maximum=.45, border.width=1.5)

g = as.igraph(graph1, attributes=TRUE)

set.seed(4)

sgc <- spinglass.community(g)

sgc$membership

# Without SDT motivations

group.spinglass<- list(c(1, 2, 6), 
                       c(3, 4), 
                       c(5),
                       c(7, 8, 9))

network1 <- bootnet::estimateNetwork(data, default="EBICglasso")

piefill <- data %>%
  summarise_all(funs(mean(., na.rm = TRUE))) %>% 
  mutate_at(vars(PA),
            funs(. / (24*60))) %>% # proportion of day used doing the behaviour
  mutate_at(vars(action.and.coping.planning),
            funs(. / 4)) %>% 
  mutate_at(vars(3, 4, 6, 7, 8, 9),
            funs(. / 7)) %>% 
  mutate_at(vars(5),
            funs(. / 100))  

plot(network1, layout = "spring", labels = TRUE, groups = group.spinglass, color=c("olivedrab2", "orange", "mediumpurple1", "lightblue"),
     label.cex = 0.75,
     label.scale = FALSE,
     pie = piefill, 
     color = "skyblue",
     pieBorder = 1)


plot(nwBoys, label.scale = FALSE, title = "Boys", label.cex = 0.75, 
     pie = boymeans, 
     color = "skyblue",
     pieBorder = 1)
```

### PA network without BCTs and SDT, intention, PA, fat%

```{r}
# Network without motivation variables
data <- df %>% select(PA = paAccelerometer_T1, 'action and coping planning' = PA_actcop_T1, 'Frequency-related BCTs' = PA_frqbct_T1, 'amotivation' = PA_amotivation_T1, 'autonomous motivation' = PA_autonomous_T1, 'controlled motivation' = PA_controlled_T1, 'descriptive norm' = PA_dnorm_T1, 'injunctive norm' = PA_inorm_T1, "fat pct" = fatpct_T1, 'intention' = PA_intention_T1, 'outcome expectations' = PA_oexp_T1, 'Self-efficacy / PBC' = PA_sePbc_T1, 'perceived opportunities' = PA_opportunities_T1) %>% 
            select(-`autonomous motivation`, -`controlled motivation`, -`amotivation`, -`Frequency-related BCTs`, -PA, -`intention`, -`fat pct`) %>% 
  data.frame

# Spinglass algorithm detects communities. Tutorial here: http://psych-networks.com/r-tutorial-identify-communities-items-networks/

cormatrix <- cor_auto(data)

graph1 <- qgraph(cormatrix, graph="glasso", layout="spring", sampleSize = nrow(data),
              vsize=7, cut=0, maximum=.45, border.width=1.5)

g = as.igraph(graph1, attributes=TRUE)

set.seed(1)

sgc <- spinglass.community(g)

sgc$membership

group.spinglass<- list(c(1, 4:6), 
                       c(2, 3))

# Estimate and plot graph


network1 <- bootnet::estimateNetwork(data, default="EBICglasso")

piefill <- data %>%
  summarise_all(funs(mean(., na.rm = TRUE))) %>%
  mutate_at(vars(action.and.coping.planning),
            funs(. / 4)) %>% 
  mutate_at(vars(2:6),
            funs(. / 7))

plot(network1, layout = "spring", labels = TRUE, groups = group.spinglass, color=c("olivedrab2", "orange", "mediumpurple1", "lightblue"),
     label.cex = 0.75,
     label.scale = FALSE,
     pie = piefill, 
     color = "skyblue",
     pieBorder = 1)


```

## Robustness test 

```{r}

Network1 <- bootnet::estimateNetwork(data1, default = "EBICglasso")
plot(Network1, layout = "spring", labels = TRUE)

qgraph::centralityPlot(Network1)

boot1 <- bootnet::bootnet(Network1, nBoots = 2500, nCores = 2)

plot(boot1, labels = TRUE, order = "sample")

Network2 <- bootnet::estimateNetwork(data1, default = "pcor")
plot(Network2, layout = "spring", labels = TRUE)

boot2 <- bootnet::bootnet(Network2, nBoots = 2500, nCores = 2)

qgraph::centralityPlot(Network)
qgraph::centralityPlot(Network2)
```

## Centrality stability

```{r}
boot2 <- bootnet::bootnet(Network1, nBoots = 2500, type = "case", nCores = 2)
bootnet::corStability(boot2)

plot(boot2)

differenceTest(boot1, "auton", "intent",  measure = c("strength", "closeness", "betweenness"))

plot(boot1, "edge", plot = "difference", onlyNonZero = TRUE, order = "sample")

plot(boot1, "strength")
plot(boot1, "betweenness")
plot(boot1, "closeness")
```

## Network comparison test: girls and boys

```{r}

# here goes your data; call it "data"
data <- df %>% select(paT1, girl, actcop_T1, frqbct_T1, amotivation_T1, autonomous_T1, controlled_T1, dnorm_T1, fatpct_T1, inorm_T1, intention_T1, oexp_T1, opportunities_T1, sePbc_T1) 

### Split data into girls and boys
data1 <- data %>% filter(girl == 1) %>% select(-girl) %>% as.data.frame

data2 <- data %>% filter(girl == 0) %>% select(-girl) %>% as.data.frame

# ---------------------------------------------------------------------------------------
# ---------- 3. NCT ------------------------------------------------------------------
# ---------------------------------------------------------------------------------------


### estimate networks and compare visually; use averageLayout function, then plot via layout(t(1:2))
network1 <- bootnet::estimateNetwork(data1, default="EBICglasso")
network2 <- bootnet::estimateNetwork(data2, default="EBICglasso")

bladibla <- averageLayout(network1$graph, network2$graph)

layout(t(1:2))
graph1 <- plot(network1, layout=bladibla, cut=0)
graph2 <- plot(network2, layout=bladibla, cut=0)

### run NCT 

nct_results <- NetworkComparisonTest::NCT(data1, data2, it=1000, binary.data=FALSE, paired=TRUE, test.edges=TRUE, edges='all', progressbar=TRUE)

nct_results$nwinv.pval  # p value of network structure diff test
nct_results$glstrinv.pval  # p value of global connectivity diff test
nct_results$einv.pvals     #p values testing diffs for all individual edges
sum(nct_results$einv.pvals$"p-value" < 0.05)  # how many edges are different

```

## Robustness test 
```{r}
data <- data %>% select(BCT = agrbct_T1,
    AUT = autonomous_T1,
    Intn = intention_T1,
    PBC = pbc_T1,
    OExp = oexp_T1,
    DNorm = norm_T1)

Network <- bootnet::estimateNetwork(data, default = "EBICglasso")

boot1 <- bootnet::bootnet(Network, nBoots = 2500, nCores = 2)

plot(boot1, labels = TRUE, order = "sample")

plot(Network, layout = "spring", labels = TRUE)

Network2 <- bootnet::estimateNetwork(data, default = "pcor")
plot(Network2, layout = "spring", labels = TRUE)

boot1 <- bootnet::bootnet(Network2, nBoots = 2500, nCores = 2)

qgraph::centralityPlot(Network)
qgraph::centralityPlot(Network2)
```

# Centrality stability

```{r}
boot2 <- bootnet::bootnet(Network, nBoots = 2500, type = "case", nCores = 2)
bootnet::corStability(boot2)

plot(boot2)

differenceTest(boot1, "AUT", "Intn",  measure = c("strength", "closeness", "betweenness"))

plot(boot1, "edge", plot = "difference", onlyNonZero = TRUE, order = "sample")

plot(boot1, "strength")
plot(boot1, "betweenness")
plot(boot1, "closeness")
```

# PA motivation examined

```{r}
nItems <- 18
regulations.df <- lmi %>% select(id = ID,
  intervention = ryhm,
  group = ryhmkoodi_korjattu,
  school = Aineisto.1,
  girl = Kys0013.1,
  PA_amotivation_02_T1 = Kys0086.1,
  PA_amotivation_01_T1 = Kys0082.1,
  PA_amotivation_03_T1 = Kys0096.1,
  PA_amotivation_04_T1 = Kys0097.1,
  PA_extrinsic_01_T1 = Kys0080.1,
  PA_extrinsic_02_T1 = Kys0081.1,
  PA_extrinsic_03_T1 = Kys0083.1,
  PA_introjected_01_T1 = Kys0084.1,
  PA_introjected_02_T1 = Kys0085.1,
  PA_identified_01_T1 = Kys0087.1,
  PA_identified_02_T1 = Kys0088.1,
  PA_identified_03_T1 = Kys0090.1,
  PA_integrated_01_T1 = Kys0089.1,
  PA_integrated_02_T1 = Kys0092.1,
  PA_integrated_03_T1 = Kys0094.1,
  PA_intrinsic_01_T1 = Kys0091.1,
  PA_intrinsic_02_T1 = Kys0093.1,
  PA_intrinsic_03_T1 = Kys0095.1
)

regulations.df <- regulations.df %>% dplyr::mutate(group = ifelse(group == "", NA, group))

# Fix intervention and gender variables
regulations.df <- regulations.df %>% dplyr::mutate(intervention = ifelse(intervention == 1, 1, 0),
                         intervention = factor(intervention),
            girl = ifelse(girl == 2, 1, 0),
            girl = factor(girl, levels = c("1", "0")),
            school = factor(school, levels = c("1", "2", "3", "4", "5")))


motiGirls <- regulations.df %>% dplyr::select(id,
  intervention,
  group,
  school,
  girl,
  PA_amotivation_02_T1,
  PA_amotivation_01_T1,
  PA_amotivation_03_T1,
  PA_amotivation_04_T1,
  PA_extrinsic_01_T1,
  PA_extrinsic_02_T1,
  PA_extrinsic_03_T1,
  PA_introjected_01_T1,
  PA_introjected_02_T1,
  PA_identified_01_T1,
  PA_identified_02_T1,
  PA_identified_03_T1,
  PA_integrated_01_T1,
  PA_integrated_02_T1,
  PA_integrated_03_T1,
  PA_intrinsic_01_T1,
  PA_intrinsic_02_T1,
  PA_intrinsic_03_T1) %>%
 tidyr::gather(key = Variable, value = Value, 6:ncol(.)) %>%
  filter(girl == "1") %>% 
 ggplot(aes(x = Value, y = Variable, group = Variable)) +
  ggridges::geom_density_ridges2(aes(fill = Variable), stat = "binline", binwidth = 1, scale = 0.95) +
  scale_x_continuous(breaks = c(1:6), expand = c(0, 0),
                     name = "") +
  scale_y_discrete(expand = c(0.01, 0), name = "", labels = NULL) +
  ggridges::scale_fill_cyclical(values = c("darkolivegreen2", "darkolivegreen4")) +
  labs(title = "Girls") +
  guides(y = "none") +
  ggridges::theme_ridges(grid = FALSE) +
  theme(axis.title.x = element_text(hjust = 0.5),
        axis.title.y = element_text(hjust = 0.5),
        plot.title = element_text(hjust = 0.5),
        axis.text=element_text(size=10)) +
coord_cartesian(xlim = c(0.5, 5.5))

motiBoys <- regulations.df %>% dplyr::select(id,
  intervention,
  group,
  school,
  girl,
  PA_amotivation_02_T1,
  PA_amotivation_01_T1,
  PA_amotivation_03_T1,
  PA_amotivation_04_T1,
  PA_extrinsic_01_T1,
  PA_extrinsic_02_T1,
  PA_extrinsic_03_T1,
  PA_introjected_01_T1,
  PA_introjected_02_T1,
  PA_identified_01_T1,
  PA_identified_02_T1,
  PA_identified_03_T1,
  PA_integrated_01_T1,
  PA_integrated_02_T1,
  PA_integrated_03_T1,
  PA_intrinsic_01_T1,
  PA_intrinsic_02_T1,
  PA_intrinsic_03_T1) %>%
 tidyr::gather(key = Variable, value = Value, 6:ncol(.)) %>%
  filter(girl == "0") %>% 
 ggplot(aes(x = Value, y = Variable, group = Variable)) +
  ggridges::geom_density_ridges2(aes(fill = Variable), stat = "binline", binwidth = 1, scale = 0.95) +
  scale_x_continuous(breaks = c(1:6), expand = c(0, 0),
                     name = "") +
  scale_y_discrete(expand = c(0.01, 0), name = "", labels = NULL) +
  ggridges::scale_fill_cyclical(values = c("darkolivegreen2", "darkolivegreen4")) +
  labs(title = "Boys") +
  guides(y = "none") +
  ggridges::theme_ridges(grid = FALSE) +
  theme(axis.title.x = element_text(hjust = 0.5),
        axis.title.y = element_text(hjust = 0.5),
        plot.title = element_text(hjust = 0.5),
        axis.text=element_text(size=10)) +
coord_cartesian(xlim = c(0.5, 5.5))

motiInt <- regulations.df %>% dplyr::select(id,
  intervention,
  group,
  school,
  girl,
  PA_amotivation_02_T1,
  PA_amotivation_01_T1,
  PA_amotivation_03_T1,
  PA_amotivation_04_T1,
  PA_extrinsic_01_T1,
  PA_extrinsic_02_T1,
  PA_extrinsic_03_T1,
  PA_introjected_01_T1,
  PA_introjected_02_T1,
  PA_identified_01_T1,
  PA_identified_02_T1,
  PA_identified_03_T1,
  PA_integrated_01_T1,
  PA_integrated_02_T1,
  PA_integrated_03_T1,
  PA_intrinsic_01_T1,
  PA_intrinsic_02_T1,
  PA_intrinsic_03_T1) %>%
 tidyr::gather(key = Variable, value = Value, 6:ncol(.)) %>%
  filter(intervention == "1") %>% 
 ggplot(aes(x = Value, y = Variable, group = Variable)) +
  ggridges::geom_density_ridges2(aes(fill = Variable), stat = "binline", binwidth = 1, scale = 0.95) +
  scale_x_continuous(breaks = c(1:6), expand = c(0, 0),
                     name = "") +
  scale_y_discrete(expand = c(0.01, 0), name = "") +
  ggridges::scale_fill_cyclical(values = c("deepskyblue", "deepskyblue4")) +
  labs(title = "Intervention") +
  guides(y = "none") +
  ggridges::theme_ridges(grid = FALSE) +
  theme(axis.title.x = element_text(hjust = 0.5),
        axis.title.y = element_text(hjust = 0.5),
        axis.text=element_text(size=10)) +
coord_cartesian(xlim = c(0.5, 5.5))

motiCont <- regulations.df %>% dplyr::select(id,
  intervention,
  group,
  school,
  girl,
  PA_amotivation_02_T1,
  PA_amotivation_01_T1,
  PA_amotivation_03_T1,
  PA_amotivation_04_T1,
  PA_extrinsic_01_T1,
  PA_extrinsic_02_T1,
  PA_extrinsic_03_T1,
  PA_introjected_01_T1,
  PA_introjected_02_T1,
  PA_identified_01_T1,
  PA_identified_02_T1,
  PA_identified_03_T1,
  PA_integrated_01_T1,
  PA_integrated_02_T1,
  PA_integrated_03_T1,
  PA_intrinsic_01_T1,
  PA_intrinsic_02_T1,
  PA_intrinsic_03_T1) %>%
 tidyr::gather(key = Variable, value = Value, 6:ncol(.)) %>%
  filter(intervention == "0") %>% 
 ggplot(aes(x = Value, y = Variable, group = Variable)) +
  ggridges::geom_density_ridges2(aes(fill = Variable), stat = "binline", binwidth = 1, scale = 0.95) +
  scale_x_continuous(breaks = c(1:6), expand = c(0, 0),
                     name = "") +
  scale_y_discrete(expand = c(0.01, 0), name = "", labels = NULL) +
  ggridges::scale_fill_cyclical(values = c("deepskyblue", "deepskyblue4")) +
  labs(title = "Control") +
  guides(y = "none") +
  ggridges::theme_ridges(grid = FALSE) +
  theme(axis.title.x = element_text(hjust = 0.5),
        axis.title.y = element_text(hjust = 0.5),
        axis.text=element_text(size=10)) +
coord_cartesian(xlim = c(0.5, 5.5))

#grid.arrange(motiInt, motiGirls, motiCont, motiBoys, ncol = 2)

# ("Seldom or never", "About once a month", "About once a week", "Almost daily")

# This draws all histograms next to each other:
grid::grid.newpage()
grid::grid.draw(cbind(ggplotGrob(motiInt), ggplotGrob(motiCont), ggplotGrob(motiGirls), ggplotGrob(motiBoys), size = "last"))

```

## Motivational regulations network

## TEE TNNE PIEFILL; tummempi sama vri tai opacity?

```{r}
# Was going to do fused graphical lasso, but the items not normal...

# s1 <- regulations.df %>% filter(school == 1) %>% select(6:ncol(regulations.df)) # %>% na.omit(.) 
# s2 <- regulations.df %>% filter(school == 2) %>% select(6:ncol(regulations.df)) # %>% na.omit(.)
# s3 <- regulations.df %>% filter(school == 3) %>% select(6:ncol(regulations.df)) # %>% na.omit(.) 
# s4 <- regulations.df %>% filter(school == 4) %>% select(6:ncol(regulations.df)) # %>% na.omit(.)
# s5 <- regulations.df %>% filter(school == 5) %>% select(6:ncol(regulations.df)) # %>% na.omit(.)
# 
# network2 <- EstimateGroupNetwork(list("1" = s1,
#                                       "2" = s2,
#                                       "3" = s3,
#                                       "4" = s4,
#                                       "5" = s5),
#                                  n = c(nrow(s1), nrow(s2), nrow(s3), nrow(s4), nrow(s5)))
# 
regulations.df <- regulations.df %>% mutate(
PA_amotivation_02_T1 = ifelse(PA_amotivation_02_T1 == 1, 0, 1),
PA_amotivation_01_T1 = ifelse(PA_amotivation_01_T1 == 1, 0, 1),
PA_amotivation_03_T1 = ifelse(PA_amotivation_03_T1 == 1, 0, 1),
PA_amotivation_04_T1 = ifelse(PA_amotivation_04_T1 == 1, 0, 1),
PA_extrinsic_01_T1 = ifelse(PA_extrinsic_01_T1 == 1, 0, 1),
PA_extrinsic_02_T1 = ifelse(PA_extrinsic_02_T1 == 1, 0, 1),
PA_extrinsic_03_T1 = ifelse(PA_extrinsic_03_T1 == 1, 0, 1),
PA_introjected_01_T1 = ifelse(PA_introjected_01_T1 == 1, 0, 1),
PA_introjected_02_T1 = ifelse(PA_introjected_02_T1 == 1, 0, 1),
PA_identified_01_T1 = ifelse(PA_identified_01_T1 == 1, 0, 1),
PA_identified_02_T1 = ifelse(PA_identified_02_T1 == 1, 0, 1),
PA_identified_03_T1 = ifelse(PA_identified_03_T1 == 1, 0, 1),
PA_integrated_01_T1 = ifelse(PA_integrated_01_T1 == 1, 0, 1),
PA_integrated_02_T1 = ifelse(PA_integrated_02_T1 == 1, 0, 1),
PA_integrated_03_T1 = ifelse(PA_integrated_03_T1 == 1, 0, 1),
PA_intrinsic_01_T1 = ifelse(PA_intrinsic_01_T1 == 1, 0, 1),
PA_intrinsic_02_T1 = ifelse(PA_intrinsic_02_T1 == 1, 0, 1),
PA_intrinsic_03_T1 = ifelse(PA_intrinsic_03_T1 == 1, 0, 1))


### GIRLS AND BOYS

S.boys <- regulations.df %>% filter(girl == 0) %>% select(6:ncol(regulations.df)) # %>% na.omit(.) 
S.girls <- regulations.df %>% filter(girl == 1) %>% select(6:ncol(regulations.df)) # %>% na.omit(.)
nwBoys <- bootnet::estimateNetwork(S.boys, default="IsingFit")
nwGirls <- bootnet::estimateNetwork(S.girls, default="IsingFit")

data1 <- regulations.df %>% select(6:ncol(regulations.df))
names(data1) <- c(paste0(rep("Amoti", 4), 1:4),
                paste0(rep("Extri", 3), 1:3),
                paste0(rep("Intro", 2), 1:2),
                paste0(rep("Ident", 3), 1:3),
                paste0(rep("Integ", 3), 1:3),
                paste0(rep("Intri", 3), 1:3))
nwAll <- bootnet::estimateNetwork(data1, default="IsingFit")

# Create means for filling nodes
girlmeans <- regulations.df %>% group_by(girl) %>% 
  summarise_at(vars(5:(5+nItems-1)),
  funs(mean(., na.rm = TRUE))) %>% 
  filter(girl == 1) %>% 
  select(-1)

boymeans <- regulations.df %>% group_by(girl) %>% 
  summarise_at(vars(5:(5+nItems-1)),
  funs(mean(., na.rm = TRUE))) %>% 
  filter(girl == 0) %>% 
  select(-1)

# Find average layout for comparability and plot graphs next to each other

Layout <- averageLayout(nwGirls, nwBoys)


layout(t(1:2))
plot(nwGirls, layout = Layout, label.scale = FALSE, title = "Girls", label.cex = 0.75,
     pie = girlmeans, 
     color = "skyblue",
     pieBorder = 1)

plot(nwBoys, layout = Layout, label.scale = FALSE, title = "Boys", label.cex = 0.75, 
     pie = boymeans, 
     color = "skyblue",
     pieBorder = 1)

itemNames <- c('I can\'t see why I should bother exercising',
  'I do not see why I should have to exercise',
  ' I do not see the point in exercising',
  ' I think exercising is a waste of time',
  ' I exercise because other people say I should',
  ' I exercise because others will not be pleased with me if I do not',
  ' I feel under pressure from my friends/family to exercise',
  ' I feel guilty when I do not exercise',
  ' I feel like a failure when I have not exercised in a while',
  ' I think it is important to make the effort to exercise regularly',
  ' I value the benefits of exercise',
  ' it is important to me to exercise regularly',
  ' I exercise because it is consistent with my life goals.',
  ' I consider exercise consistent with my values.',
  ' I consider exercise a fundamental part of who I am.',
  ' I get pleasure and satisfaction from participating in exercise',
  ' I exercise because it is fun',
  ' I enjoy my exercise sessions')

itemGroups <- c(rep("Amotivation", 4),
                rep("Extrinsic", 3),
                rep("Introjected", 2),
                rep("Identified", 3),
                rep("Integrated", 3),
                rep("Intrinsic", 3))


plot(nwAll, groups = itemGroups, nodeNames = itemNames, legend.cex = 0.25)


```

## Community detection

```{r}

# Find communities
graph1 <- plot(nwBCT)
 
g = as.igraph(graph1, attributes=TRUE)
 
matrix_spinglass <- matrix(NA, nrow=1,ncol=1000)

set.seed(1)
for (i in 1:100) {
set.seed(i)
spinglass <- spinglass.community(g)
matrix_spinglass[1,i] <- max(spinglass$membership) 
} # 1000 took 8 minutes
 
mean(as.vector(matrix_spinglass)) 
max(as.vector(matrix_spinglass)) 
min(as.vector(matrix_spinglass)) 
median(as.vector(matrix_spinglass)) 

set.seed(1)
spinglass <- spinglass.community(g)
spinglass$membership
spinglassGroups <- list(rep(2, 6), rep(1, 4), rep(3, 9))

```

<!-- Of all the iterations of the spinglass algorithm, ` sum(table(matrix_spinglass)[1]) / 100`% gave `names(table(matrix_spinglass)[1])` groups, ` sum(table(matrix_spinglass)[2]) / 100`% gave `names(table(matrix_spinglass)[2])` groups, and ` sum(table(matrix_spinglass)[3]) / 100`% gave ` names(table(matrix_spinglass)[1])` groups,  -->
