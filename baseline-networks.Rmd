---
title: "Network analyses"
---

This section describes network analyses and displays correlation structures in the data. Here, physical activity (PA) is used interchangeably with moderate-to-vigorous physical activity (MVPA); all measures of activity relate to MVPA.

```{r setup, message = FALSE, warning = FALSE}

source("baseline-datasetup.R")

```

Clicking the "Code"-buttons on the right shows code for each chunk.

$~$
$~$
<a id="network"></a>

As with all models, network analysis entails its own set of assumptions. Due to the similarity with regression models, it does not make sense to include variables which can be thought to be embedded in each other. For example, it is difficult to argue that there is no conceptual overlap between positive outcome expectations and autonomous motivation. In this regard, behaviour change technique use and the quality of one’s motivation (as posited by self-determination theory) seem less problematic. Hence, we start with those.

# Network featured in manuscript

## Network

All BCTs are shown here separately; exceptions: memory cues which seems quite unclear a question, as well as analysing goal failure, which only concerns those who have not reached their goals (for which an option on the scale was given, making it differ from the other BCTs).

```{r}
bctdf_mgm_T1 <- df %>% dplyr::select(
#  id,
#  intervention,
#  group,
#  school,
#  girl,
  'goal setting' = PA_agreementDependentBCT_01_T1,
  'own plan' = PA_agreementDependentBCT_02_T1,
  'plan by other' = PA_agreementDependentBCT_03_T1,
  'reminder of plan' = PA_agreementDependentBCT_04_T1,
  'subgoals' = PA_agreementDependentBCT_05_T1,
  'trying new PA' = PA_agreementDependentBCT_06_T1,
  'barrier identification' = PA_agreementDependentBCT_07_T1,
  'problem solving' = PA_agreementDependentBCT_08_T1,
  'PA identity reflection' = PA_agreementDependentBCT_09_T1,
  'aligning PA with life values' = PA_agreementDependentBCT_10_T1,
  'remind of PA benefits' = PA_frequencyDependentBCT_01_T1,
  'self-monitor (paper)' = PA_frequencyDependentBCT_02_T1,
  'self-monitor (app)' = PA_frequencyDependentBCT_03_T1,
#  'memory cues' = PA_frequencyDependentBCT_04_T1, # Issues with clarity of item wording 
  'goal review' = PA_frequencyDependentBCT_05_T1,
  'personal relevance reflection' = PA_frequencyDependentBCT_06_T1,
  'environmental changes (home)' = PA_frequencyDependentBCT_07_T1,
  'social support' = PA_frequencyDependentBCT_08_T1,
  'analysing goal failure' = PA_frequencyDependentBCT_09_T1,
  'MVPA survey' = padaysLastweek_T1,
  'MVPA accelerometer' = mvpaAccelerometer_T1,
  'intrinsic' = PA_intrinsic_T1,
  'identified' = PA_identified_T1, 'integrated' = PA_integrated_T1,
  'controlled motivation' = PA_controlled_T1) %>%
 rowwise() %>% 
 mutate(
  'goal setting' = ifelse(`goal setting` == 1, 0, 1),
#  'has plan' = ifelse(`own plan` == 1 & `plan by other` == 1, 0, 1),
  'own plan' = ifelse(`own plan` == 1, 0, 1),
  'plan by other' = ifelse(`plan by other` == 1, 0, 1),
  'reminder of plan' = ifelse(`reminder of plan` == 1, 0, 1),
  'subgoals' = ifelse(`subgoals` == 1, 0, 1),
  'trying new PA' = ifelse(`trying new PA` == 1, 0, 1),
  'barrier identification' = ifelse(`barrier identification` == 1, 0, 1),
  'problem solving' = ifelse(`problem solving` == 1, 0, 1),
  # 'barriers identified or planned for' = ifelse(`problem solving` == 1 & `barrier identification` == 1, 0, 1),
  'PA identity reflection' = ifelse(`PA identity reflection` == 1, 0, 1),
  'aligning PA with life values' = ifelse(`aligning PA with life values` == 1, 0, 1),
  # 'identity, life values' = ifelse(`PA identity reflection` == 1 & `aligning PA with life values` == 1, 0, 1),
  'remind of PA benefits' = ifelse(`remind of PA benefits` == 1, 0, 1),
  'monitoring PA' = ifelse(`self-monitor (paper)` == 1 & `self-monitor (app)` == 1, 0, 1),
#  'memory cues' = ifelse(`memory cues` == 1, 0, 1),
  'goal review' = ifelse(`goal review` == 1, 0, 1),
  'personal relevance reflection' = ifelse(`personal relevance reflection` == 1, 0, 1),
  'environmental changes (home)' = ifelse(`environmental changes (home)` == 1, 0, 1),
  'social support' = ifelse(`social support` == 1, 0, 1),
  'analysing goal failure' = ifelse(`analysing goal failure` == 1, 0, 1),
  'autonomous motivation' = mean(c(identified, intrinsic, integrated), na.rm = T),
#  'girl' = ifelse(girl == "girl", 1, 0),
  'controlled motivation' = ifelse(`controlled motivation` < 3, 0, 1)) %>%  # If "at least partly" or more true, input 1. Normality otherwise a problem. 
#  'intervention' = ifelse(intervention == "1", 1, 0)) %>% 
  dplyr::select(-`self-monitor (paper)`, -`self-monitor (app)`, 
                # -`plan by other`, -`own plan`, 
                -identified, -intrinsic, -integrated,
         -`analysing goal failure` # only concerns those who haven't reached goals
         # -`barrier identification`, -`problem solving`, # closely related
           ) %>% 
#  dplyr::select(-controlled) %>% # Not really gaussian at all 
  dplyr::select('MVPA survey', 'MVPA accelerometer', everything())

bctdf_mgm_T1$`autonomous motivation`[is.nan(bctdf_mgm_T1$`autonomous motivation`)] <- NA

labs <- names(bctdf_mgm_T1)

# mgm wants full data, see package missForest for imputation methods
bctdf_mgm_T1 <- bctdf_mgm_T1 %>% na.omit(.)
# bctdf_mgm %>% names()
mgm_variable_types <- c("g", "g", rep("c", 17), "g")
mgm_variable_levels <- c("1", "1", rep("2", 17), "1")
# data.frame(mgm_variable_types, mgm_variable_levels, names(bctdf_mgm))

mgm_obj_T1 <- mgm::mgm(data = bctdf_mgm_T1,
  type = mgm_variable_types,
  level = mgm_variable_levels,
  lambdaSel = "EBIC",
  # lambdaFolds = 10,
  verbatim = FALSE,
  pbar = FALSE, 
  binarySign = TRUE)

# Node pies:
pies_T1 <- bctdf_mgm_T1 %>% 
  colMeans() # results in a series of means, which is ok for dichotomous vars
pies_T1["MVPA survey"] <- pies_T1["MVPA survey"] / 7
pies_T1["MVPA accelerometer"] <- pies_T1["MVPA accelerometer"] / max(bctdf_mgm_T1$`MVPA accelerometer`, na.rm = TRUE)
pies_T1["autonomous motivation"] <- pies_T1["autonomous motivation"] / 5

node_colors <- c(viridis::viridis(3, begin = 0.4, end = 0.99)[1], # Color 1 for MVPA (questionnaire)
                 viridis::viridis(3, begin = 0.4, end = 0.99)[1], # Color 1 for MVPA (accelerometer)
                 rep(viridis::viridis(3, begin = 0.4, end = 0.99)[2], 15), # 11x Color 2 for BCTs
                 rep(viridis::viridis(3, begin = 0.4, end = 0.99)[3], 1), # Color 3 for motivation (controlled)  
                 rep(viridis::viridis(3, begin = 0.4, end = 0.99)[2], 1), # 1x Color 2 for BCTs
                 viridis::viridis(3, begin = 0.4, end = 0.99)[3]) # Color 3 for motivation (autonomous) 

BCT_mgm_T1 <- qgraph::qgraph(mgm_obj_T1$pairwise$wadj, 
            layout = "spring",
            repulsion = 0.99, # To nudge the network from originally bad visual state
            edge.color = ifelse(mgm_obj_T1$pairwise$edgecolor == "darkgreen", "blue", mgm_obj_T1$pairwise$edgecolor),
            pie = pies_T1,
            # pieColor = pie_colors_T1,
            pieColor = node_colors,
            labels = names(bctdf_mgm_T1),
            pieBorder = 1,
            label.cex = 0.75,
            cut = 0,
            edge.labels = TRUE,
            label.scale = FALSE,
            DoNotPlot = TRUE)

plot(BCT_mgm_T1)

BCT_mgm_T1_circle <- qgraph::qgraph(mgm_obj_T1$pairwise$wadj, 
            layout = "circle",
            title = "Mixed graphical model: PA, BCTs & motivation",
            edge.color = ifelse(mgm_obj_T1$pairwise$edgecolor == "darkgreen", "blue", mgm_obj_T1$pairwise$edgecolor),
            pie = pies_T1,
            pieColor = viridis::viridis(5, begin = 0.3, end = 0.8)[5],
            color = node_colors,
            labels = names(bctdf_mgm_T1),
            label.cex = 0.75,
            cut = 0,
            label.scale = FALSE, 
            DoNotPlot = TRUE)

plot(BCT_mgm_T1_circle)
```

## Details and diagnostics {.tabset}

### Description

Tabs in this section show robustness diagnostics for the network. For details, see:

Epskamp, S., Borsboom, D., & Fried, E. I. (2018). Estimating psychological networks and their accuracy: A tutorial paper. Behavior Research Methods, 50(1), 195–212. https://doi.org/10.3758/s13428-017-0862-1

### Bootstrap stability {.tabset}

Graphs below depict bootstrapped sampling distributions for the edges, taking 100 bootstrap samples from the original data. Edges are introduced in decreasing order of strength. Line width indicates the edge values drawn from samples between the 5th and 95th quantiles, while the number inside the line is the proportion of non-zero parameter estimates. 

```{r manuscript-network-resample-bootstrap, fig.width = 10, fig.height = 7, results = "asis", fig.show = "asis"}

# all_BCTs_mgm_stability <- mgm::resample(object = mgm_obj_T1, data = bctdf_mgm_T1, nB = 100)
# save(all_BCTs_mgm_stability, file = "./Rdata_files/all_BCTs_mgm_stability.Rdata")
load("./Rdata_files/all_BCTs_mgm_stability.Rdata")

labels_for_plot <- bctdf_mgm_T1 %>% 
  names()
  
labels_for_plot[nchar(labels_for_plot) > 15] <- paste0(strtrim(labels_for_plot[nchar(labels_for_plot) > 15], 15), "...")

number_of_edges <- ncol(bctdf_mgm_T1) * (ncol(bctdf_mgm_T1) - 1) / 2

for (i in c(seq(from = 1, to = number_of_edges, by = 19))) {

 cat('\n\n####', paste0("edges ", i, "-", i+18), '\n\n  ')
  
 plot_resample <- mgm::plotRes(object = all_BCTs_mgm_stability,
        quantiles = c(.05, .95),
        cex.label = 0.5,
        lwd.qtl = 2.5,
        cex.mean = .5,
        decreasing = TRUE,
        cut = i:(i+18),
        axis.ticks = c(-0.5, -0.25, 0, 0.25, 0.5, 0.75, 1, 1.25, 1.5),
        labels = labels_for_plot)

 plot_resample
}

```


### Edge weights matrix

```{r edgeWeights, results = 'asis'}

edgeweights <- mgm_obj_T1$pairwise$wadj %>% round(., 3)
colnames(edgeweights) <- labs
rownames(edgeweights) <- labs

edgeweights %>% knitr::kable()

```



### Other estimation methods (mgm CV, GGM)

This section estimates models with different methods: mgm with cross-validation, the standard Gaussian Graphical Model (GGM), and unregularised GGM. The distributions violate normality assumptions of the GGM. 

```{r}
#### CV model selection for mgm 

mgm_obj_T1_CV <- mgm::mgm(data = bctdf_mgm_T1,
  type = mgm_variable_types,
  level = mgm_variable_levels,
  lambdaSel = "CV",
  lambdaFolds = 10,
  pbar = FALSE, 
  binarySign = TRUE)

# Node pies:
pies_T1 <- bctdf_mgm_T1 %>% 
  colMeans() # results in a series of means, which is ok for dichotomous vars
pies_T1["MVPA survey"] <- pies_T1["MVPA survey"] / 7
pies_T1["MVPA accelerometer"] <- pies_T1["MVPA accelerometer"] / max(bctdf_mgm_T1$`MVPA accelerometer`, na.rm = TRUE)
pies_T1["autonomous motivation"] <- pies_T1["autonomous motivation"] / 5


node_colors <- c(viridis::viridis(3, begin = 0.4, end = 0.99)[1], # Color 1 for MVPA (questionnaire)
                 viridis::viridis(3, begin = 0.4, end = 0.99)[1], # Color 1 for MVPA (accelerometer)
                 rep(viridis::viridis(3, begin = 0.4, end = 0.99)[2], 15), # 11x Color 2 for BCTs
                 rep(viridis::viridis(3, begin = 0.4, end = 0.99)[3], 1), # Color 3 for motivation (controlled)  
                 rep(viridis::viridis(3, begin = 0.4, end = 0.99)[2], 1), # 1x Color 2 for BCTs
                 viridis::viridis(3, begin = 0.4, end = 0.99)[3]) # Color 3 for motivation (autonomous) 

BCT_mgm_T1_CV <- qgraph::qgraph(mgm_obj_T1_CV$pairwise$wadj, 
            layout = BCT_mgm_T1$layout,
            repulsion = 0.99, # To nudge the network from originally bad visual state
            edge.color = ifelse(mgm_obj_T1$pairwise$edgecolor == "darkgreen", "blue", mgm_obj_T1$pairwise$edgecolor),
            pie = pies_T1,
            # pieColor = pie_colors_T1,
            pieColor = node_colors,
            labels = names(bctdf_mgm_T1),
            pieBorder = 1,
            label.cex = 0.75,
            cut = 0,
            label.scale = FALSE,
            title = "MGM with cross-validation")

#### GGM

bctdf_ggm_T1 <- df %>% dplyr::select(
  'goal setting' = PA_agreementDependentBCT_01_T1,
  'own plan' = PA_agreementDependentBCT_02_T1,
  'plan by other' = PA_agreementDependentBCT_03_T1,
  'reminder of plan' = PA_agreementDependentBCT_04_T1,
  'subgoals' = PA_agreementDependentBCT_05_T1,
  'trying new PA' = PA_agreementDependentBCT_06_T1,
  'barrier identification' = PA_agreementDependentBCT_07_T1,
  'problem solving' = PA_agreementDependentBCT_08_T1,
  'PA identity reflection' = PA_agreementDependentBCT_09_T1,
  'aligning PA with life values' = PA_agreementDependentBCT_10_T1,
  'remind of PA benefits' = PA_frequencyDependentBCT_01_T1,
  'self-monitor (paper)' = PA_frequencyDependentBCT_02_T1,
  'self-monitor (app)' = PA_frequencyDependentBCT_03_T1,
#  'memory cues' = PA_frequencyDependentBCT_04_T1, # Issues with clarity of item wording 
  'goal review' = PA_frequencyDependentBCT_05_T1,
  'personal relevance reflection' = PA_frequencyDependentBCT_06_T1,
  'environmental changes (home)' = PA_frequencyDependentBCT_07_T1,
  'social support' = PA_frequencyDependentBCT_08_T1,
  'analysing goal failure' = PA_frequencyDependentBCT_09_T1,
  'MVPA survey' = padaysLastweek_T1,
  'MVPA accelerometer' = mvpaAccelerometer_T1,
  'intrinsic' = PA_intrinsic_T1,
  'identified' = PA_identified_T1, 'integrated' = PA_integrated_T1,
  'controlled motivation' = PA_controlled_T1) %>%
 rowwise() %>% 
 mutate(
  # 'goal setting' = ifelse(`goal setting` == 1, 0, 1),
  # 'own plan' = ifelse(`own plan` == 1, 0, 1),
  # 'plan by other' = ifelse(`plan by other` == 1, 0, 1),
  # 'reminder of plan' = ifelse(`reminder of plan` == 1, 0, 1),
  # 'subgoals' = ifelse(`subgoals` == 1, 0, 1),
  # 'trying new PA' = ifelse(`trying new PA` == 1, 0, 1),
  # 'barrier identification' = ifelse(`barrier identification` == 1, 0, 1),
  # 'problem solving' = ifelse(`problem solving` == 1, 0, 1),
  # 'PA identity reflection' = ifelse(`PA identity reflection` == 1, 0, 1),
  # 'aligning PA with life values' = ifelse(`aligning PA with life values` == 1, 0, 1),
  # 'remind of PA benefits' = ifelse(`remind of PA benefits` == 1, 0, 1),
  'monitoring PA' = ifelse(`self-monitor (paper)` == 1 & `self-monitor (app)` == 1, 0, 1),
  # 'goal review' = ifelse(`goal review` == 1, 0, 1),
  # 'personal relevance reflection' = ifelse(`personal relevance reflection` == 1, 0, 1),
  # 'environmental changes (home)' = ifelse(`environmental changes (home)` == 1, 0, 1),
  # 'social support' = ifelse(`social support` == 1, 0, 1),
  # 'analysing goal failure' = ifelse(`analysing goal failure` == 1, 0, 1),
  'autonomous motivation' = mean(c(identified, intrinsic, integrated), na.rm = T),
  'controlled motivation' = `controlled motivation` * 1) %>% 
  dplyr::select(-`self-monitor (paper)`, -`self-monitor (app)`, 
                -identified, -intrinsic, -integrated,
         -`analysing goal failure` # only concerns those who haven't reached goals
           ) %>% 
  dplyr::select('MVPA survey', 'MVPA accelerometer', everything()) %>% 
  mutate_all(as.numeric)

nwBCT_ggm <- bootnet::estimateNetwork(bctdf_ggm_T1, default="EBICglasso")

BCT_ggm <- plot(nwBCT_ggm, 
                layout = BCT_mgm_T1$layout, 
                label.scale = FALSE, 
                title = "GGM: MVPA, BCTs & motivation", 
                label.cex = 0.75,
                # pie = piefill_ggm,
                color = node_colors,
                pieBorder = 1)

modSelect_0 <- qgraph::ggmModSelect(qgraph::cor_auto(bctdf_ggm_T1), n = nrow(bctdf_ggm_T1), gamma = 0)

g3 <- qgraph::qgraph(modSelect_0$graph, 
                     layout = BCT_mgm_T1$layout, 
                     label.scale = FALSE,
                     label.cex = 0.75,
                     labels = labs,
                     theme = "colorblind",
                     title = "ggmModSelect (gamma = 0)", 
                     color = node_colors, 
                     cut = 0)

modSelect_0.5 <- qgraph::ggmModSelect(qgraph::cor_auto(bctdf_ggm_T1), n = nrow(bctdf_ggm_T1), gamma = 0.5)

g4 <- qgraph::qgraph(modSelect_0.5$graph, 
                     layout = BCT_mgm_T1$layout, 
                     label.scale = FALSE,
                     label.cex = 0.75,
                     labels = labs,
                     theme = "colorblind", 
                     title = "ggmModSelect (gamma = 0.5)",
                     color = node_colors, 
                     cut = 0)
```

# Combined BCT chunks

The following network depicts a mixed graphical model, with the following variables:

- Two measures of physical activity. `MVPA accelerometer` is the mean accelerometer-measured Moderate-to-Vigorous Physical Activity (MVPA) during a day in the measurement period, `MVPA questionnaire` is a survey item which asked "on how many days the previous week were you active for at least 30 minutes so, that you were out of breath". 

- One Behaviour Change Technique usage node (BCT usage is the mean of all techniques participants reported having used).

- Four motivation types (Intrinsic and Identified, which are facets of "autonomous regulation" according to the self-determination theory, looked normal so used as continuous. Introjected and Extrinsic - facets of "controlled regulation" - were heavily skewed, so they were dichotomised: if "at least partly" or more true, a participant gets 1, otherwise 0.

```{r}

bctdf_mgm <- df %>% dplyr::select(
  'agr-BCTs' = PA_agreementDependentBCT_T1,
  'frq-BCTs' = PA_frequencyDependentBCT_T1,
  'MVPA questionnaire' = padaysLastweek_T1,
  'MVPA accelerometer' = mvpaAccelerometer_T1,
  'Intrinsic' = PA_intrinsic_T1,
  'Identified' = PA_identified_T1,
  'Introjected' = PA_introjected_T1,
  'Extrinsic' = PA_extrinsic_T1) %>%
 rowwise() %>% 
 mutate(
  'BCT usage' = mean(c(`agr-BCTs`, `frq-BCTs`), na.rm = TRUE),
  # 'autonomous motivation' = mean(c(identified, intrinsic), na.rm = TRUE),
  'Extrinsic' = ifelse(`Extrinsic` < 3, 0, 1), # If "at least partly" or more true, input 1. Normality otherwise a problem. 
  'Introjected' = ifelse(`Introjected` < 3, 0, 1)) %>%  # If "at least partly" or more true, input 1. Normality otherwise a problem. 
  dplyr::select('MVPA questionnaire', 'MVPA accelerometer', 'BCT usage', everything(), -contains("-BCTs")) %>% 
  mutate_all(as.numeric)

bctdf_mgm$`BCT usage`[is.nan(bctdf_mgm$`BCT usage`)] <- NA



# If you need mock data:
# bctdf_mgm <- data.frame(
#   'MVPA questionnaire' = sample(1:8, size = 700, replace = TRUE),
#   'MVPA accelerometer' = rnorm(mean = 130, sd = 40, n = 700),
#   'BCT usage' = replicate(19, sample(1:5, 700, rep = TRUE)) %>% as.data.frame() %>% rowMeans(.),
#   'Intrinsic' = replicate(3, sample(1:5, 700, rep = TRUE)) %>% as.data.frame() %>% rowMeans(.),
#   'Identified' = replicate(3, sample(1:5, 700, rep = TRUE)) %>% as.data.frame() %>% rowMeans(.),
#   'Introjected' = sample(0:1, 700, rep = TRUE) %>% as.data.frame() %>% rowMeans(.),
#   'Extrinsic' = sample(0:1, 700, rep = TRUE) %>% as.data.frame() %>% rowMeans(.)
# )

labs <- names(bctdf_mgm)

# mgm wants full data, see package missForest for imputation methods
bctdf_mgm <- bctdf_mgm %>% na.omit(.)
# bctdf_mgm %>% names()
mgm_variable_types <- c(rep("g", 5), "c", "c")
mgm_variable_levels <- c(rep("1", 5), "2", "2")
# data.frame(mgm_variable_types, mgm_variable_levels, names(bctdf_mgm))

mgm_obj <- mgm::mgm(data = bctdf_mgm,
  type = mgm_variable_types,
  level = mgm_variable_levels,
  lambdaSel = "CV",
  lambdaFolds = 10,
  pbar = FALSE, 
  binarySign = TRUE)

pred_obj <- predict(object = mgm_obj,
                         data = bctdf_mgm)

pred_obj$errors

# Take R2 from gaussian, CC from categorical variables 
pie_errors <- c(pred_obj$errors[1:5, 3],
                pred_obj$errors[6:7, 4])

# Coloring nodes: make a sequence of colors from the viridis palette. We need three colors (MVPA, BCTs, motivation), and "begin" from ones that are not too dark, so that black text shows up ok.

node_colors <- c(viridis::viridis(5, begin = 0.4, end = 0.99)[1], # Color 1 for MVPA (questionnaire)
                 viridis::viridis(5, begin = 0.4, end = 0.99)[1], # Color 1 for MVPA (accelerometer)
                 rep(viridis::viridis(5, begin = 0.4, end = 0.99)[4], 1), # 1x Color 4 for BCTs
                 rep(viridis::viridis(5, begin = 0.4, end = 0.99)[2], 2), # 2x Color 2 for autonomous
                 rep(viridis::viridis(5, begin = 0.4, end = 0.99)[3], 2)) # 2x Color 3 for controlled

BCT_mgm <- qgraph::qgraph(mgm_obj$pairwise$wadj, 
            layout = "spring",
            repulsion = 1, # To nudge the network from originally bad visual state
            # title = "Mixed graphical model: PA, BCTs & motivation",
            edge.color = ifelse(mgm_obj$pairwise$edgecolor == "darkgreen", "blue", mgm_obj$pairwise$edgecolor),
            pie = pie_errors,
            pieColor = viridis::viridis(5, begin = 0.3, end = 0.8)[5],
            color = node_colors,
            labels = names(bctdf_mgm),
            label.cex = 0.8,
            label.scale = FALSE,
            node.width = 1.65)

# adjacency_noAmotivation <- mgm_obj$pairwise$wadj
# save(adjacency_noAmotivation, file = "./Rdata_files/adjacency_noAmotivation.Rdata")
# signs_noAmotivation <- mgm_obj$pairwise$signs
# save(signs_noAmotivation, file = "./Rdata_files/signs_noAmotivation.Rdata")

# BCT_mgm_noAmotivation_stability <- mgm::resample(object = mgm_obj, data = bctdf_mgm, nB = 100)
# save(BCT_mgm_noAmotivation_stability, file = "./Rdata_files/BCT_mgm_noAmotivation_stability.Rdata")
load("./Rdata_files/BCT_mgm_noAmotivation_stability.Rdata")

# # Plotting the bootstrapped edge between variables 1 and 4:
# hist(BCT_mgm_noAmotivation_stability$bootParameters[1, 4, ],
# main = "",
# xlab = "Parameter Estimate")

mgm::plotRes(object = BCT_mgm_noAmotivation_stability, 
        quantiles = c(.05, .95), 
        cex.label = 0.5,
        lwd.qtl = 2.5, 
        cex.mean = .5,
        labels = names(bctdf_mgm))

```

The bootstrap stability plot above shows the proportion of re-samples, which contain a non-zero link between two edges (for a tutorial, see [this link](http://psych-networks.com/bootstrapping-edges-after-regularization-clarifications-tutorial/) -- or, if it's down, this [archived page](https://web.archive.org/web/20180809113839/http://psych-networks.com/bootstrapping-edges-after-regularization-clarifications-tutorial/)). For example, when we draw observations from the current sample with replacement a 100 times, 99% of these times a non-zero link between questionnaire-measured MVPA and intrinsic motivation is estimated.

# Correlation network and mixed graphical model compared

```{r network-dataprep, message = FALSE, warning = FALSE, echo = FALSE}

bctdf_mgm <- df %>% dplyr::select(
  'agr-BCTs' = PA_agreementDependentBCT_T1,
  'frq-BCTs' = PA_frequencyDependentBCT_T1,
  'MVPA survey' = padaysLastweek_T1,
  'MVPA accelerom.' = mvpaAccelerometer_T1,
  'Intrinsic' = PA_intrinsic_T1,
  'Identified' = PA_identified_T1,
  'Introjected' = PA_introjected_T1,
  'Extrinsic' = PA_extrinsic_T1) %>%
 rowwise() %>% 
 mutate(
  'BCT usage' = mean(c(`agr-BCTs`, `frq-BCTs`), na.rm = TRUE),
  'Extrinsic' = ifelse(`Extrinsic` < 3, 0, 1), # If "at least partly" or more true, input 1. Normality otherwise a problem. 
  'Introjected' = ifelse(`Introjected` < 3, 0, 1)) %>%  # If "at least partly" or more true, input 1. Normality otherwise a problem. 
  dplyr::select('MVPA survey', 'MVPA accelerom.', everything(), -contains("-BCTs")) %>% 
  mutate_all(as.numeric)

bctdf_mgm$`BCT usage`[is.nan(bctdf_mgm$`BCT usage`)] <- NA # Taking the mean earlier introduced NaN's instead of NAs. This fixes them.

labs <- names(bctdf_mgm)

bctdf_mgm <- bctdf_mgm %>% na.omit(.) # Omit cases with missing data; # mgm wants full data. See package missForest for imputation methods.
# bctdf_mgm %>% names()
mgm_variable_types <- c(rep("g", 4), "c", "c", "g") # Set variable types; categorical for extrinsic and introjected and otherwise gaussian.
mgm_variable_levels <- c(rep("1", 4), "2", "2", "1") # Set variable levels; "1" for gaussian, "2" for categorical.
# data.frame(mgm_variable_types, mgm_variable_levels, names(bctdf_mgm)) # Check that the levels and types are correct.

# Estimate the mgm object:
mgm_obj <- mgm::mgm(data = bctdf_mgm, 
  type = mgm_variable_types,
  level = mgm_variable_levels,
  lambdaSel = "CV",
  lambdaFolds = 10,
  pbar = FALSE, 
  binarySign = TRUE)

pred_obj <- predict(object = mgm_obj,
                         data = bctdf_mgm)

pred_obj$errors

# Take R2 from gaussian, CC from categorical variables 
pie_errors <- c(pred_obj$errors[1:4, 3],
                pred_obj$errors[5:6, 4],
                pred_obj$errors[7, 3])

# Coloring nodes: make a sequence of colors from the viridis palette. We need five colors (MVPA, BCTs, motivation x2 & the circle around nodes indicating predictability), and "begin" from ones that are not too dark, so that black text shows up ok.
node_colors <- c(viridis::viridis(5, begin = 0.4, end = 0.99)[1], # Color 1 for MVPA (questionnaire)
                 viridis::viridis(5, begin = 0.4, end = 0.99)[1], # Color 1 for MVPA (accelerometer)
                 rep(viridis::viridis(5, begin = 0.4, end = 0.99)[3], 2), # 2x Color 2 for autonomous
                 rep(viridis::viridis(5, begin = 0.4, end = 0.99)[4], 2), # 2x Color 3 for controlled
                 rep(viridis::viridis(5, begin = 0.4, end = 0.99)[5], 1)) # 1x Color 2 for BCTs

BCT_mgm <- qgraph::qgraph(mgm_obj$pairwise$wadj, 
            layout = "spring",
            repulsion = 0.9913, # To nudge the network from originally bad visual state
            # title = "Mixed graphical model: PA, BCTs & motivation",
            edge.color = ifelse(mgm_obj$pairwise$edgecolor == "darkgreen", "blue", mgm_obj$pairwise$edgecolor),
            pie = pie_errors,
            pieColor = viridis::viridis(5, begin = 0.3, end = 0.99)[2],
            color = node_colors,
            labels = names(bctdf_mgm),
            label.cex = 1.5,
            label.scale = FALSE,
            node.width = 1.65,
            DoNotPlot = TRUE)

# Make a sequence of numers, to be used as a pie chart in nodes, to depict mean:
piefill <- bctdf_mgm %>% 
  colMeans(.) 

piefill['MVPA survey'] <- piefill["MVPA survey"] / 7
piefill['MVPA accelerom.'] <- piefill['MVPA accelerom.'] / (max(df$mvpaAccelerometer_T1, na.rm = TRUE))
piefill['Intrinsic'] <- piefill['Intrinsic'] / 5
piefill['Identified'] <- piefill['Identified'] / 5
piefill['Introjected'] <- piefill['Introjected'] / 1 # already a proportion
piefill['Extrinsic'] <- piefill['Extrinsic'] / 1
piefill['BCT usage'] <- piefill['BCT usage'] / 6

corgraph <- qgraph::qgraph(qgraph::cor_auto(bctdf_mgm), graph = "cor",
              color = node_colors,
              labels = names(bctdf_mgm),
              label.cex = 1.5,
              label.scale = FALSE,
              node.width = 1.65,
              edge.labels = TRUE, 
              title = "bivariate correlation network",
              DoNotPlot = TRUE)

```

```{r network-plot, fig.width = 12, fig.height = 6, fig.cap = "A) Mixed graphical model with LASSO regularisation and model selection by cross-validation. Pie indicates node predictability. B) Bivariate correlation network. Pie indicates node mean as % of theoretical maximum (for MVPA accelerometer, mean as % maximum observed MVPA)."}

averagedLayout <- qgraph::averageLayout(BCT_mgm, corgraph)

layout(t(1:2))

BCT_mgm <- qgraph::qgraph(mgm_obj$pairwise$wadj, 
            layout = averagedLayout,
            edge.color = ifelse(mgm_obj$pairwise$edgecolor == "darkgreen", "blue", mgm_obj$pairwise$edgecolor),
            pie = pie_errors,
            pieColor = viridis::viridis(5, begin = 0.3, end = 0.99)[2],
            color = node_colors,
            labels = names(bctdf_mgm),
            # label.cex = 1,
            label.scale = FALSE,
            # node.width = 1,
            edge.labels = TRUE,
            title = "A)")

corgraph <- qgraph::qgraph(qgraph::cor_auto(bctdf_mgm), 
              layout = averagedLayout,
              graph = "cor",
              pie = piefill,
              pieBorder = 1,
              pieColor = node_colors,
              labels = names(bctdf_mgm),
              # label.cex = 1,
              label.scale = FALSE,
              # node.width = 1,
              edge.labels = TRUE, 
              title = "B)")
```

The "last motivation type", i.e. the fifth, is Amotivation (dichotomised due to skew). A node for that is added in the network below:

```{r network-with-amotivation-and-resampling, fig.width = 10}

bctdf_mgm <- df %>% dplyr::select(
  'agr-BCTs' = PA_agreementDependentBCT_T1,
  'frq-BCTs' = PA_frequencyDependentBCT_T1,
  'MVPA questionnaire' = padaysLastweek_T1,
  'MVPA accelerometer' = mvpaAccelerometer_T1,
  'Intrinsic' = PA_intrinsic_T1,
  'Identified' = PA_identified_T1,
  'Introjected' = PA_introjected_T1,
  'Extrinsic' = PA_extrinsic_T1,
  'Amotivation' = PA_amotivation_T1) %>%
 rowwise() %>% 
 mutate(
  'BCT usage' = mean(c(`agr-BCTs`, `frq-BCTs`), na.rm = TRUE),
  # 'autonomous motivation' = mean(c(identified, intrinsic), na.rm = TRUE),
  'Extrinsic' = ifelse(`Extrinsic` < 3, 0, 1), # If "at least partly" or more true, input 1. Normality otherwise a problem.
  'Amotivation' = ifelse(`Amotivation` < 3, 0, 1), # If "at least partly" or more true, input 1. Normality otherwise a problem.
  'Introjected' = ifelse(`Introjected` < 3, 0, 1)) %>%  # If "at least partly" or more true, input 1. Normality otherwise a problem. 
  dplyr::select('MVPA questionnaire', 'MVPA accelerometer', 'BCT usage', everything(), -contains("-BCTs")) %>% 
  mutate_all(as.numeric)

bctdf_mgm$`BCT usage`[is.nan(bctdf_mgm$`BCT usage`)] <- NA

labs <- names(bctdf_mgm)

# mgm wants full data, see package missForest for imputation methods
bctdf_mgm <- bctdf_mgm %>% na.omit(.)
# bctdf_mgm %>% names()
mgm_variable_types <- c(rep("g", 5), "c", "c", "c")
mgm_variable_levels <- c(rep("1", 5), "2", "2", "2")
# data.frame(mgm_variable_types, mgm_variable_levels, names(bctdf_mgm))

mgm_obj <- mgm::mgm(data = bctdf_mgm,
  type = mgm_variable_types,
  level = mgm_variable_levels,
  lambdaSel = "CV",
  lambdaFolds = 10,
  pbar = FALSE, 
  binarySign = TRUE)

pred_obj <- predict(object = mgm_obj,
                         data = bctdf_mgm)

pred_obj$errors

# Take R2 from gaussian, CC from categorical variables 
pie_errors <- c(pred_obj$errors[1:5, 3],
                pred_obj$errors[6:8, 4])

# Coloring nodes: make a sequence of colors from the viridis palette. We need three colors (MVPA, BCTs, motivation), and "begin" from ones that are not too dark, so that black text shows up ok.

node_colors <- c(viridis::viridis(5, begin = 0.4, end = 0.99)[1], # Color 1 for MVPA (questionnaire)
                 viridis::viridis(5, begin = 0.4, end = 0.99)[1], # Color 1 for MVPA (accelerometer)
                 rep(viridis::viridis(5, begin = 0.4, end = 0.99)[4], 1), # 1x Color 4 for BCTs
                 rep(viridis::viridis(5, begin = 0.4, end = 0.99)[2], 2), # 2x Color 2 for autonomous
                 rep(viridis::viridis(5, begin = 0.4, end = 0.99)[3], 3)) # 3x Color 3 for controlled/amotivation

BCT_mgm <- qgraph::qgraph(mgm_obj$pairwise$wadj, 
            layout = "spring",
            repulsion = 1, # To nudge the network from originally bad visual state
            # title = "Mixed graphical model: PA, BCTs & motivation",
            edge.color = ifelse(mgm_obj$pairwise$edgecolor == "darkgreen", "blue", mgm_obj$pairwise$edgecolor),
            pie = pie_errors,
            pieColor = viridis::viridis(5, begin = 0.3, end = 0.8)[5],
            color = node_colors,
            labels = names(bctdf_mgm),
            label.cex = 0.8,
            label.scale = FALSE,
            node.width = 1.65)

# BCT_mgm_withAmotivation_stability <- mgm::resample(object = mgm_obj, data = bctdf_mgm, nB = 100)
# save(BCT_mgm_withAmotivation_stability, file = "./Rdata_files/BCT_mgm_withAmotivation_stability.Rdata")
load("./Rdata_files/BCT_mgm_withAmotivation_stability.Rdata")

mgm::plotRes(object = BCT_mgm_withAmotivation_stability, 
        quantiles = c(.05, .95), 
        cex.label = 0.5, 
        lwd.qtl = 2.5,
        labels = bctdf_mgm %>% names(),
        cex.mean = .5)

```

Theory-wise, Amotivation should be negatively correlated with everything but Extrinsic and Introjected. Given that BCT usage is 19 items, there are probably a lot of ways there can be a positive correlation, although that would be unexpected. But the positive relation with MVPA questionnaire would mean, that people who report having done physical activity on more days last week, would also say they don't see any point in doing physical activity (another example item: I think exercising is a waste of time).  One explanation would be some form of [conditioning on a collider](https://web.archive.org/web/20180807095037/http://www.the100.ci/2017/03/14/that-one-weird-third-variable-problem-nobody-ever-mentions-conditioning-on-a-collider/).

One option would be, that (as the model drops incomplete observations), there is some selection effects based on motivation types and/or BCT usage. To check for this, we estimate a Gaussian Graphical Model, which assumes normally distributed data but uses all observations.

```{r selection-collider-check-ggm}
bctdf_ggm <- df %>% dplyr::select(
  'agr-BCTs' = PA_agreementDependentBCT_T1,
  'frq-BCTs' = PA_frequencyDependentBCT_T1,
  'MVPA questionnaire' = padaysLastweek_T1,
  'MVPA accelerometer' = mvpaAccelerometer_T1,
  'Intrinsic' = PA_intrinsic_T1,
  'Identified' = PA_identified_T1,
  'Introjected' = PA_introjected_T1,
  'Extrinsic' = PA_extrinsic_T1,
  'Amotivation' = PA_amotivation_T1) %>%
 rowwise() %>% 
 mutate(
  'BCT usage' = mean(c(`agr-BCTs`, `frq-BCTs`), na.rm = TRUE),
  # 'autonomous motivation' = mean(c(identified, intrinsic), na.rm = TRUE),
  'Extrinsic' = ifelse(`Extrinsic` < 3, 0, 1), # If "at least partly" or more true, input 1. Normality otherwise a problem.
  'Amotivation' = ifelse(`Amotivation` < 3, 0, 1), # If "at least partly" or more true, input 1. Normality otherwise a problem.
  'Introjected' = ifelse(`Introjected` < 3, 0, 1)) %>%  # If "at least partly" or more true, input 1. Normality otherwise a problem. 
  dplyr::select('MVPA questionnaire', 'MVPA accelerometer', 'BCT usage', everything(), -contains("-BCTs")) %>% 
  mutate_all(as.numeric)

bctdf_ggm$`BCT usage`[is.nan(bctdf_ggm$`BCT usage`)] <- NA

# Network for all participants
S.total_ggm <- bctdf_ggm
nwBCT_ggm <- bootnet::estimateNetwork(S.total_ggm, default="EBICglasso")

labs_ggm <- colnames(S.total_ggm)

# Create means for filling nodes
# piefill_ggm <- S.total_ggm %>% 
#   dplyr::select(-contains("MVPA"), -contains("motivation")) %>% data.frame %>% 
#   dplyr::summarise_all(funs(mean(., na.rm = TRUE) /6))
# 
# piefill_ggm$`MVPA accelerometer` <- median(S.total_ggm$`MVPA accelerometer`, na.rm = TRUE) / (60 * 24)
# piefill_ggm$`MVPA questionnaire` <- median(S.total_ggm$`MVPA questionnaire`, na.rm = TRUE) / 7
# piefill_ggm$autonomous <- median(S.total_ggm$`autonomous motivation`, na.rm = TRUE) / 5
# piefill_ggm$controlled <- median(S.total_ggm$`controlled motivation`, na.rm = TRUE) / 5
#   
# piefill_ggm <- piefill_ggm %>% 
#   dplyr::select("MVPA questionnaire", "MVPA accelerometer", autonomous, controlled, everything())

# Plot network

BCT_ggm <- plot(nwBCT_ggm, 
                layout = "spring", 
                repulsion = 0.99, # To nudge the network from originally bad visual state
                label.scale = FALSE, 
                title = "GGM: MVPA, BCTs & motivation", 
                label.cex = 0.75,
                # pie = piefill_ggm,
                color = "skyblue",
                pieBorder = 1)


qgraph::flow(BCT_ggm, "MVPA accelerometer", theme = "colorblind", vsize = 8)
qgraph::flow(BCT_ggm, "MVPA questionnaire", theme = "colorblind", vsize = 8)

```

From the network above, we see that the positive connection between amotivation and questionnaire-measured MVPA has almost completely disappered. Bootstrapping to inspect stability shows, that the connection is likely to be zero (see 13th edge from the bottom; "MVPA questionnaire--Amotivation"). 

```{r stability}

# collider_boot <- bootnet(nwBCT_ggm, nBoots = 2500)
# save(collider_boot, file = "./Rdata_files/collider_boot.Rdata")
load("./Rdata_files/collider_boot.Rdata")
plot(collider_boot, plot = "interval", split0 = TRUE, order = "sample", labels = TRUE)

```

The bootstrap stability plot above (for a tutorial, see [this link](http://psych-networks.com/bootstrapping-edges-after-regularization-clarifications-tutorial/) -- or, if it's down, this [archived page](https://web.archive.org/web/20180809113839/http://psych-networks.com/bootstrapping-edges-after-regularization-clarifications-tutorial/)) shows, that when we draw observations from the sample with replacement 2500 times, the connection between amotivation and questionnaire-measured MVPA was estimated as non-zero only about 30% of time.

# Combining some BCT items

This section presents a Mixed Graphical Model (MGM) and a Gaussian Graphical Model (GGM). In the MGM, we opted to dichotomise the BCTs in order to increase interpretability while not violating model assumptions. Results do not differ very much. Some nodes were still combined, to reduce estimation burden.

```{r allBctsMotiSurveyPA-dataprep}
bctdf_mgm <- df %>% dplyr::select(
#  id,
#  intervention,
#  group,
#  school,
#  girl,
  'goal setting' = PA_agreementDependentBCT_01_T1,
  'own plan' = PA_agreementDependentBCT_02_T1,
  'plan by other' = PA_agreementDependentBCT_03_T1,
  'reminder of plan' = PA_agreementDependentBCT_04_T1,
  'subgoals' = PA_agreementDependentBCT_05_T1,
  'trying new PA' = PA_agreementDependentBCT_06_T1,
  'barrier identification' = PA_agreementDependentBCT_07_T1,
  'problem solving' = PA_agreementDependentBCT_08_T1,
  'PA identity reflection' = PA_agreementDependentBCT_09_T1,
  'aligning PA with life values' = PA_agreementDependentBCT_10_T1,
  'remind of PA benefits' = PA_frequencyDependentBCT_01_T1,
  'self-monitor (paper)' = PA_frequencyDependentBCT_02_T1,
  'self-monitor (app)' = PA_frequencyDependentBCT_03_T1,
#  'memory cues' = PA_frequencyDependentBCT_04_T1, # Issues with clarity of item wording 
  'goal review' = PA_frequencyDependentBCT_05_T1,
  'personal relevance reflection' = PA_frequencyDependentBCT_06_T1,
  'environmental changes (home)' = PA_frequencyDependentBCT_07_T1,
  'social support' = PA_frequencyDependentBCT_08_T1,
  'analysing goal failure' = PA_frequencyDependentBCT_09_T1,
  'MVPA questionnaire' = padaysLastweek_T1,
  'MVPA accelerometer' = mvpaAccelerometer_T1,
  'intrinsic' = PA_intrinsic_T1,
  'identified' = PA_identified_T1,
  'controlled motivation' = PA_controlled_T1) %>%
 rowwise() %>% 
 mutate(
  'goal setting' = ifelse(`goal setting` == 1, 0, 1),
#  'has plan' = ifelse(`own plan` == 1 & `plan by other` == 1, 0, 1),
  'own plan' = ifelse(`own plan` == 1, 0, 1),
  'plan by other' = ifelse(`plan by other` == 1, 0, 1),
  'reminder of plan' = ifelse(`reminder of plan` == 1, 0, 1),
  'subgoals' = ifelse(`subgoals` == 1, 0, 1),
  'trying new PA' = ifelse(`trying new PA` == 1, 0, 1),
#  'barrier identification' = ifelse(`barrier identification` == 1, 0, 1),
#  'problem solving' = ifelse(`problem solving` == 1, 0, 1),
  'barriers identified or planned for' = ifelse(`problem solving` == 1 & `barrier identification` == 1, 0, 1),
#  'PA identity reflection' = ifelse(`PA identity reflection` == 1, 0, 1),
#  'aligning PA with life values' = ifelse(`aligning PA with life values` == 1, 0, 1),
  'identity, life values' = ifelse(`PA identity reflection` == 1 & `aligning PA with life values` == 1, 0, 1),
  'remind of PA benefits' = ifelse(`remind of PA benefits` == 1, 0, 1),
  'monitoring PA' = ifelse(`self-monitor (paper)` == 1 & `self-monitor (app)` == 1, 0, 1),
#  'memory cues' = ifelse(`memory cues` == 1, 0, 1),
  'goal review' = ifelse(`goal review` == 1, 0, 1),
  'personal relevance reflection' = ifelse(`personal relevance reflection` == 1, 0, 1),
  'environmental changes (home)' = ifelse(`environmental changes (home)` == 1, 0, 1),
  'social support' = ifelse(`social support` == 1, 0, 1),
  'analysing goal failure' = ifelse(`analysing goal failure` == 1, 0, 1),
  'autonomous motivation' = mean(c(identified, intrinsic), na.rm = T),
#  'girl' = ifelse(girl == "girl", 1, 0),
  'controlled motivation' = ifelse(`controlled motivation` < 3, 0, 1)) %>%  # If "at least partly" or more true, input 1. Normality otherwise a problem. 
#  'intervention' = ifelse(intervention == "1", 1, 0)) %>% 
  dplyr::select(-`self-monitor (paper)`, -`self-monitor (app)`, 
                # -`plan by other`, -`own plan`, 
                -identified, -intrinsic,
         -`analysing goal failure`, # only concerns those who haven't reached goals
         -`barrier identification`, -`problem solving`, # closely related
         -`PA identity reflection`, -`aligning PA with life values`) %>% # closely related
#  dplyr::select(-controlled) %>% # Not really gaussian at all 
  dplyr::select('MVPA questionnaire', 'MVPA accelerometer', everything())

bctdf_mgm$`autonomous motivation`[is.nan(bctdf_mgm$`autonomous motivation`)] <- NA

labs <- names(bctdf_mgm)

```

#### mgm estimation

```{r allBctsMotiSurveyPA-mgm}
# devtools::install_github("jmbh/mgm")
# Restart R for the latest package
# .r.restartR()

# mgm wants full data, see package missForest for imputation methods
bctdf_mgm <- bctdf_mgm %>% na.omit(.)
# bctdf_mgm %>% names()
mgm_variable_types <- c("g", "g", rep("c", 15), "g")
mgm_variable_levels <- c("1", "1", rep("2", 15), "1")
# data.frame(mgm_variable_types, mgm_variable_levels, names(bctdf_mgm))

mgm_obj <- mgm::mgm(data = bctdf_mgm,
  type = mgm_variable_types,
  level = mgm_variable_levels,
  lambdaSel = "CV",
  lambdaFolds = 10,
  pbar = FALSE, 
  binarySign = TRUE)

pred_obj <- predict(object = mgm_obj,
                         data = bctdf_mgm)

pred_obj$errors

# Take R2 from gaussian, CC from categorical variables 
pie_errors <- c(pred_obj$errors[1, 3],
                pred_obj$errors[2, 3],
                pred_obj$errors[3:17, 4],
                pred_obj$errors[18, 3])


```

#### mgm plotting

```{r allBctsMotiSurveyPA-mgm-plot}
# Coloring nodes: make a sequence of colors from the viridis palette. We need three colors (MVPA, BCTs, motivation), and "begin" from ones that are not too dark, so that black text shows up ok.

node_colors <- c(viridis::viridis(3, begin = 0.4, end = 0.99)[1], # Color 1 for MVPA (questionnaire)
                 viridis::viridis(3, begin = 0.4, end = 0.99)[1], # Color 1 for MVPA (accelerometer)
                 rep(viridis::viridis(3, begin = 0.4, end = 0.99)[2], 11), # 11x Color 2 for BCTs
                 rep(viridis::viridis(3, begin = 0.4, end = 0.99)[3], 1), # Color 3 for motivation (controlled)  
                 rep(viridis::viridis(3, begin = 0.4, end = 0.99)[2], 3), # 3x Color 2 for BCTs
                 viridis::viridis(3, begin = 0.4, end = 0.99)[3]) # Color 3 for motivation (autonomous) 

BCT_mgm <- qgraph::qgraph(mgm_obj$pairwise$wadj, 
            layout = "spring",
            repulsion = 0.9999, # To nudge the network from originally bad visual state
            title = "Mixed graphical model: PA, BCTs & motivation",
            edge.color = ifelse(mgm_obj$pairwise$edgecolor == "darkgreen", "blue", mgm_obj$pairwise$edgecolor),
            pie = pie_errors,
            pieColor = viridis::viridis(5, begin = 0.3, end = 0.8)[5],
            color = node_colors,
            labels = names(bctdf_mgm),
            label.cex = 0.75,
            label.scale = FALSE)

```


### ggm estimation & plotting

```{r allBctsMotiSurveyPA-ggm}

bctdf_ggm <- df %>% dplyr::select(
#  id,
#  intervention,
#  group,
#  school,
#  girl,
  'goal setting' = PA_agreementDependentBCT_01_T1,
  'own plan' = PA_agreementDependentBCT_02_T1,
  'plan by other' = PA_agreementDependentBCT_03_T1,
  'reminder of plan' = PA_agreementDependentBCT_04_T1,
  'subgoals' = PA_agreementDependentBCT_05_T1,
  'trying new PA' = PA_agreementDependentBCT_06_T1,
  'barrier identification' = PA_agreementDependentBCT_07_T1,
  'problem solving' = PA_agreementDependentBCT_08_T1,
  'PA identity reflection' = PA_agreementDependentBCT_09_T1,
  'aligning PA with life values' = PA_agreementDependentBCT_10_T1,
  'remind of PA benefits' = PA_frequencyDependentBCT_01_T1,
  'self-monitor (paper)' = PA_frequencyDependentBCT_02_T1,
  'self-monitor (app)' = PA_frequencyDependentBCT_03_T1,
#  'memory cues' = PA_frequencyDependentBCT_04_T1,
  'goal review' = PA_frequencyDependentBCT_05_T1,
  'personal relevance reflection' = PA_frequencyDependentBCT_06_T1,
  'environmental changes (home)' = PA_frequencyDependentBCT_07_T1,
  'social support' = PA_frequencyDependentBCT_08_T1,
  'failure contemplated' = PA_frequencyDependentBCT_09_T1,
  'MVPA questionnaire' = padaysLastweek_T1,
  'MVPA accelerometer' = mvpaAccelerometer_T1,
  'intrinsic' = PA_intrinsic_T1,
  'identified' = PA_identified_T1,
  'controlled motivation' = PA_controlled_T1) %>%
 rowwise() %>% 
 mutate(
#  'has plan' = mean(c(`own plan`, `plan by other`), na.rm = TRUE),
  'barriers identified or planned for' = mean(c(`problem solving`, `barrier identification`), na.rm = TRUE),
  'identity, life values' = mean(c(`PA identity reflection` == 1, `aligning PA with life values`), na.rm = TRUE),
  'monitoring PA' = mean(c(`self-monitor (paper)`, `self-monitor (app)`), na.rm = TRUE),
  'autonomous motivation' = mean(c(identified, intrinsic), na.rm = T)) %>% 
#  'girl' = ifelse(girl == "girl", 1, 0),
#  'intervention' = ifelse(intervention == "1", 1, 0)) %>% 
  dplyr::select(-`self-monitor (paper)`, -`self-monitor (app)`, 
#                -`plan by other`, -`own plan`,
                -identified, -intrinsic,
         -`failure contemplated`, # only concerns those who haven't reached goals
         -`barrier identification`, -`problem solving`, # closely related
         -`PA identity reflection`, -`aligning PA with life values`) %>% # closely related
#  dplyr::select(-controlled) %>% # Not really gaussian at all 
  dplyr::select("MVPA questionnaire", "MVPA accelerometer", "autonomous motivation", "controlled motivation", everything()) %>% 
  dplyr::mutate_all(as.numeric)

# Network for all participants
S.total_ggm <- bctdf_ggm
nwBCT_ggm <- bootnet::estimateNetwork(S.total_ggm, default="EBICglasso")

labs_ggm <- colnames(S.total_ggm)

# Create means for filling nodes
piefill_ggm <- S.total_ggm %>% 
  dplyr::select(-contains("MVPA"), -contains("motivation")) %>% data.frame %>% 
  dplyr::summarise_all(funs(mean(., na.rm = TRUE) /6))

piefill_ggm$`MVPA accelerometer` <- median(S.total_ggm$`MVPA accelerometer`, na.rm = TRUE) / (60 * 24)
piefill_ggm$`MVPA questionnaire` <- median(S.total_ggm$`MVPA questionnaire`, na.rm = TRUE) / 7
piefill_ggm$autonomous <- median(S.total_ggm$`autonomous motivation`, na.rm = TRUE) / 5
piefill_ggm$controlled <- median(S.total_ggm$`controlled motivation`, na.rm = TRUE) / 5
  
piefill_ggm <- piefill_ggm %>% 
  dplyr::select("MVPA questionnaire", "MVPA accelerometer", autonomous, controlled, everything())

# Plot network

BCT_ggm <- plot(nwBCT_ggm, 
                layout = "spring", 
                repulsion = 0.99, # To nudge the network from originally bad visual state
                label.scale = FALSE, 
                title = "GGM: MVPA, BCTs & motivation", 
                label.cex = 0.75,
                pie = piefill_ggm,
                color = "skyblue",
                pieBorder = 1)


qgraph::flow(BCT_ggm, "MVPA accelerometer", theme = "colorblind", vsize = 8)
qgraph::flow(BCT_ggm, "MVPA questionnaire", theme = "colorblind", vsize = 8)
```

### Centrality and stability

```{r allBctsMotiSurveyPA-ggm-stability}

allBctsMotiSurveyPA <- nwBCT_ggm

allBctsMotiSurveyPA_centralityPlot <- qgraph::centralityPlot(allBctsMotiSurveyPA)

qgraph::centrality(allBctsMotiSurveyPA)$InDegree %>% 
  data.frame("Node" = names(.), "Strength" = .) %>%
  dplyr::arrange(desc(Strength)) %>% 
  papaja::apa_table()

scale(qgraph::centrality(allBctsMotiSurveyPA)$InDegree) %>% 
  data.frame(Node = labels(.), `Standardised strength` = .) %>%
  plyr::arrange(desc(`Standardised.strength`)) %>% 
  papaja::apa_table()
  
qgraph::centrality(allBctsMotiSurveyPA)$Closeness %>% data.frame(Closeness = .) %>% papaja::apa_table()

qgraph::centrality(allBctsMotiSurveyPA)$Betweenness %>% data.frame(names(.), .) %>% papaja::apa_table()

cor(qgraph::centrality(allBctsMotiSurveyPA)$InDegree, qgraph::centrality(allBctsMotiSurveyPA)$Betweenness, 
    method = "spearman") 

# bootnet_stability_allBctsMotiSurveyPA <- bootnet::bootnet(allBctsMotiSurveyPA, nBoots=1000)
# save(bootnet_stability_allBctsMotiSurveyPA, file = "./Rdata_files/bootnet_stability_allBctsMotiSurveyPA.Rdata")
load("./Rdata_files/bootnet_stability_allBctsMotiSurveyPA.Rdata")

plot(bootnet_stability_allBctsMotiSurveyPA, labels = FALSE, order = "sample") 
plot(bootnet_stability_allBctsMotiSurveyPA, labels = FALSE, "edge", plot = "difference", onlyNonZero = TRUE, order = "sample")

# bootnet_centrality_stability_allBctsMotiSurveyPA <- bootnet::bootnet(allBctsMotiSurveyPA, nBoots=1000,nCores=8, type="case")
# save(bootnet_centrality_stability_allBctsMotiSurveyPA, file = "./Rdata_files/bootnet_centrality_stability_allBctsMotiSurveyPA.Rdata")
load("./Rdata_files/bootnet_centrality_stability_allBctsMotiSurveyPA.Rdata")

plot(bootnet_centrality_stability_allBctsMotiSurveyPA)
plot(bootnet_centrality_stability_allBctsMotiSurveyPA, perNode=T, "strength")

bootnet::corStability(bootnet_centrality_stability_allBctsMotiSurveyPA)

```

<!-- ## Visually compare ggm and mgm -->

<!-- TODO -->

```{r pa-bct-motivation-compare-ggm-mgm, eval = FALSE}

layout_mgm_ggm <- qgraph::averageLayout(BCT_ggm, BCT_mgm)

layout(t(1:2))

plot(nwBCT_ggm, layout = layout_mgm_ggm, label.scale = FALSE, title = "GGM: MVPA, BCTs & motivation", label.cex = 0.75,
     pie = piefill_ggm,
     color = "skyblue",
     pieBorder = 1)

qgraph::qgraph(mgm_obj$pairwise$wadj,
            layout = layout_mgm_ggm,
            title = "MGM: MVPA, BCTs & motivation",
            edge.color = ifelse(mgm_obj$pairwise$edgecolor == "darkgreen", "blue", mgm_obj$pairwise$edgecolor),
            pie = pie_errors,
            pieColor = viridis::viridis(6, begin = 0.3, end = 0.8)[6],
            color = node_colors,
            labels = names(bctdf_mgm),
            label.cex = 0.75,
            label.scale = FALSE)

```

## Correlation and partial correlation networks visualised

As we can see, the bivariate correlation network is uninterpretable due to high number of edges. 

```{r pa-bct-moti-compare-correlation-partialcorrelation}

corgraph <- qgraph::qgraph(qgraph::cor_auto(bctdf_ggm), graph = "cor",
                           repulsion = 0.99,
       labels = names(bctdf_ggm),
       edge.labels = TRUE,
       edge.label.cex = 0.75,
       label.scale = FALSE,
       layout = qgraph::averageLayout(BCT_ggm, BCT_mgm), # get the mgm layout 
       title = "bivariate correlation network",
       theme = "colorblind",
       label.cex = 0.75,
       pie = piefill_ggm,
       pieBorder = 1,
       color = "skyblue")


pcorgraph <- qgraph::qgraph(qgraph::cor_auto(bctdf_ggm), graph = "pcor",
                           repulsion = 0.99,
       labels = names(bctdf_ggm),
       edge.labels = TRUE,
       edge.label.cex = 0.75,
       label.scale = FALSE,
       layout = qgraph::averageLayout(BCT_ggm, BCT_mgm), # get the mgm layout 
       title = "Partial correlation network",
       theme = "colorblind",
       label.cex = 0.75,
       pie = piefill_ggm,
       pieBorder = 1,
       color = "skyblue")

```

## Correlation matrix visualised

```{r allBctsMotiSurveyPA-corrmatrix, results = "asis"}

bivariate_BCTs <- df %>% dplyr::select(
  'goal setting' = PA_agreementDependentBCT_01_T1,
  'own plan' = PA_agreementDependentBCT_02_T1,
  'plan by other' = PA_agreementDependentBCT_03_T1,
  'reminder of plan' = PA_agreementDependentBCT_04_T1,
  'subgoals' = PA_agreementDependentBCT_05_T1,
  'trying new PA' = PA_agreementDependentBCT_06_T1,
  'barrier identification' = PA_agreementDependentBCT_07_T1,
  'problem solving' = PA_agreementDependentBCT_08_T1,
  'PA identity reflection' = PA_agreementDependentBCT_09_T1,
  'aligning PA with life values' = PA_agreementDependentBCT_10_T1,
  'remind of PA benefits' = PA_frequencyDependentBCT_01_T1,
  'self-monitor (paper)' = PA_frequencyDependentBCT_02_T1,
  'self-monitor (app)' = PA_frequencyDependentBCT_03_T1,
  'memory cues' = PA_frequencyDependentBCT_04_T1,
  'goal review' = PA_frequencyDependentBCT_05_T1,
  'personal relevance reflection' = PA_frequencyDependentBCT_06_T1,
  'environmental changes (home)' = PA_frequencyDependentBCT_07_T1,
  'social support' = PA_frequencyDependentBCT_08_T1,
  'failure contemplated' = PA_frequencyDependentBCT_09_T1,
  'PA accelerometer' = mvpaAccelerometer_T1,
  'PA self-report' = padaysLastweek_T1,
  'autonomous' = PA_autonomous_T1,
  'controlled' = PA_controlled_T1) %>%
 rowwise() %>% 
  dplyr::select(`PA accelerometer`, `PA self-report`, autonomous, controlled, everything()) %>% 
  mutate_all(as.numeric)

# Create a covariance matrix of the data
covMatrix <- bctdf_ggm %>% cov(use = "pairwise.complete.obs")

# Transform the matrix so, that lower diagonal of the matrix shows partial correlations,
# while the upper one shows bivariate correlations.
matrix_corLower_parcorUpper <- covMatrix %>% ggm::correlations()

# Show the matrix
matrix_corLower_parcorUpper %>% papaja::apa_table(caption = "Correlation matrix of key variables of interest. Lower diagonal shows bivariate correlations, upper diagonal shows partial correlations")

labs <- names(bctdf_ggm)
# Plot the matrix as a correlogram
matrix_corLower_parcorUpper %>% corrgram::corrgram(
  type = "cor",
  lower.panel = corrgram::panel.pie,
  upper.panel = corrgram::panel.pie,
  outer.labels = list(bottom = list(labels = labs, cex = 0.75, srt = 30),
                      left = list(labels = labs, cex = 0.75, srt = 30)),
  main = "Bivariate (upper diagonal) and partial (lower diagonal)\ncorrelations of BCTs, motivation and self-reported PA")

corMatrix_BCTs <- bivariate_BCTs %>% cor(use = "pairwise.complete.obs", method = "spearman")

as.data.frame(as.table(corMatrix_BCTs)) %>% 
  dplyr::filter(Var1 == "PA accelerometer" | Var1 == "PA self report") %>% 
  dplyr::mutate("Spearman correlation" = Freq) %>% 
  dplyr::select(-Freq) %>% 
  dplyr::filter(`Spearman correlation` != 1) %>% 
  dplyr::arrange(desc(`Spearman correlation`)) %>% 
  papaja::apa_table(caption = "Bivariate correlations between BCTs, motivation and self-reported PA. Sorted by strength.")

```

## Cognitive BCTs only, added one at a time

Four BCTs can be categorised as being completely cognitive, i.e. not being observable to an outsider. These are (in order of correlation with accelerometer-measured MVPA:

1. I have attempted to find ways to exercise so, that it won't obstruct but instead helps actualise my other life values.
2. I have thought about which reasons to do PA are important to me personally.
3. I have reminded myself even in my spare time, what kind of positive consequences frequent PA would have in my life.
4. I have thought about how PA fits my identity (self concept).

First, we fit a model with only the first one:

```{r cognitiveBCTs1}
bctdf_mgm <- df %>% dplyr::select(
#  id,
#  intervention,
#  group,
#  school,
#  girl,
  'goal setting' = PA_agreementDependentBCT_01_T1,
  'own plan' = PA_agreementDependentBCT_02_T1,
  'plan by other' = PA_agreementDependentBCT_03_T1,
  'reminder of plan' = PA_agreementDependentBCT_04_T1,
  'subgoals' = PA_agreementDependentBCT_05_T1,
  'trying new PA' = PA_agreementDependentBCT_06_T1,
  'barrier identification' = PA_agreementDependentBCT_07_T1,
  'problem solving' = PA_agreementDependentBCT_08_T1,
  'PA identity reflection' = PA_agreementDependentBCT_09_T1,
  'aligning PA with life values' = PA_agreementDependentBCT_10_T1,
  'remind of PA benefits' = PA_frequencyDependentBCT_01_T1,
  'self-monitor (paper)' = PA_frequencyDependentBCT_02_T1,
  'self-monitor (app)' = PA_frequencyDependentBCT_03_T1,
#  'memory cues' = PA_frequencyDependentBCT_04_T1, # Issues with clarity of item wording 
  'goal review' = PA_frequencyDependentBCT_05_T1,
  'personal relevance reflection' = PA_frequencyDependentBCT_06_T1,
  'environmental changes (home)' = PA_frequencyDependentBCT_07_T1,
  'social support' = PA_frequencyDependentBCT_08_T1,
  'analysing goal failure' = PA_frequencyDependentBCT_09_T1,
  'MVPA questionnaire' = padaysLastweek_T1,
  'MVPA accelerometer' = mvpaAccelerometer_T1,
  'intrinsic' = PA_intrinsic_T1,
  'identified' = PA_identified_T1,
  'controlled motivation' = PA_controlled_T1) %>%
 rowwise() %>% 
 dplyr::transmute(
  # 'goal setting' = ifelse(`goal setting` == 1, 0, 1),
  # 'has plan' = ifelse(`own plan` == 1 & `plan by other` == 1, 0, 1),
  # 'own plan' = ifelse(`own plan` == 1, 0, 1),
  # 'plan by other' = ifelse(`plan by other` == 1, 0, 1),
  # 'reminder of plan' = ifelse(`reminder of plan` == 1, 0, 1),
  # 'subgoals' = ifelse(`subgoals` == 1, 0, 1),
  # 'trying new PA' = ifelse(`trying new PA` == 1, 0, 1),
  # 'barrier identification' = ifelse(`barrier identification` == 1, 0, 1),
  # 'problem solving' = ifelse(`problem solving` == 1, 0, 1),
  # 'barriers identified or planned for' = ifelse(`problem solving` == 1 & `barrier identification` == 1, 0, 1),
 # 'PA identity reflection' = ifelse(`PA identity reflection` == 1, 0, 1),
 'aligning PA with life values' = ifelse(`aligning PA with life values` == 1, 0, 1),
  # 'identity, life values' = ifelse(`PA identity reflection` == 1 & `aligning PA with life values` == 1, 0, 1),
  # 'remind of PA benefits' = ifelse(`remind of PA benefits` == 1, 0, 1),
  # 'monitoring PA' = ifelse(`self-monitor (paper)` == 1 & `self-monitor (app)` == 1, 0, 1),
  # 'memory cues' = ifelse(`memory cues` == 1, 0, 1),
  # 'goal review' = ifelse(`goal review` == 1, 0, 1),
  # 'personal relevance reflection' = ifelse(`personal relevance reflection` == 1, 0, 1),
  # 'environmental changes (home)' = ifelse(`environmental changes (home)` == 1, 0, 1),
  # 'social support' = ifelse(`social support` == 1, 0, 1),
  # 'analysing goal failure' = ifelse(`analysing goal failure` == 1, 0, 1),
  'autonomous motivation' = mean(c(identified, intrinsic), na.rm = TRUE),
#  'girl' = ifelse(girl == "girl", 1, 0),
  'controlled motivation' = ifelse(`controlled motivation` < 3, 0, 1), # If "at least partly" or more true, input 1. Normality otherwise a problem.
  'MVPA questionnaire' = `MVPA questionnaire` * 1, 
  'MVPA accelerometer' = `MVPA accelerometer` * 1) %>%  
  dplyr::select('MVPA questionnaire', 'MVPA accelerometer', everything())

bctdf_mgm$`autonomous motivation`[is.nan(bctdf_mgm$`autonomous motivation`)] <- NA

labs <- names(bctdf_mgm)

bctdf_mgm <- bctdf_mgm %>% na.omit(.)
# bctdf_mgm %>% names()
mgm_variable_types <- c("g", "g", rep("c", 1), "g", "c")
mgm_variable_levels <- c("1", "1", rep("2", 1), "1", "2")
# data.frame(mgm_variable_types, mgm_variable_levels, names(bctdf_mgm))

mgm_obj <- mgm::mgm(data = bctdf_mgm,
  type = mgm_variable_types,
  level = mgm_variable_levels,
  lambdaSel = "CV",
  lambdaFolds = 10,
  pbar = FALSE, 
  binarySign = TRUE)

pred_obj <- predict(object = mgm_obj,
                         data = bctdf_mgm)

pred_obj$errors

# Take R2 from gaussian, CC from categorical variables 
pie_errors <- c(pred_obj$errors[1, 3],
                pred_obj$errors[2, 3],
                pred_obj$errors[3, 4],
                pred_obj$errors[4, 3],
                pred_obj$errors[5, 4])

# Coloring nodes: make a sequence of colors from the viridis palette. We need three colors (MVPA, BCTs, motivation), and "begin" from ones that are not too dark, so that black text shows up ok.

node_colors <- c(viridis::viridis(3, begin = 0.4, end = 0.99)[1], # Color 1 for MVPA (questionnaire)
                 viridis::viridis(3, begin = 0.4, end = 0.99)[1], # Color 1 for MVPA (accelerometer)
                 rep(viridis::viridis(3, begin = 0.4, end = 0.99)[2], 1), # 4x Color 2 for BCTs
                 rep(viridis::viridis(3, begin = 0.4, end = 0.99)[3], 1), # Color 3 for motivation (controlled)
                 viridis::viridis(3, begin = 0.4, end = 0.99)[3]) # Color 3 for motivation (autonomous) 

BCT_mgm <- qgraph::qgraph(mgm_obj$pairwise$wadj, 
            layout = "spring",
            repulsion = 0.99, # To nudge the network from originally bad visual state
            title = "cognitive/motivational BCTs, PA & motivation",
            edge.color = ifelse(mgm_obj$pairwise$edgecolor == "darkgreen", "blue", mgm_obj$pairwise$edgecolor),
            pie = pie_errors,
            pieColor = viridis::viridis(5, begin = 0.3, end = 0.8)[5],
            color = node_colors,
            labels = names(bctdf_mgm),
            label.cex = 0.75,
            label.scale = FALSE,
            vertex.label.dist = 2)

```

Adding the second (I have thought about which reasons to do PA are important to me personally):

```{r cognitiveBCTs2}
bctdf_mgm <- df %>% dplyr::select(
#  id,
#  intervention,
#  group,
#  school,
#  girl,
  'goal setting' = PA_agreementDependentBCT_01_T1,
  'own plan' = PA_agreementDependentBCT_02_T1,
  'plan by other' = PA_agreementDependentBCT_03_T1,
  'reminder of plan' = PA_agreementDependentBCT_04_T1,
  'subgoals' = PA_agreementDependentBCT_05_T1,
  'trying new PA' = PA_agreementDependentBCT_06_T1,
  'barrier identification' = PA_agreementDependentBCT_07_T1,
  'problem solving' = PA_agreementDependentBCT_08_T1,
  'PA identity reflection' = PA_agreementDependentBCT_09_T1,
  'aligning PA with life values' = PA_agreementDependentBCT_10_T1,
  'remind of PA benefits' = PA_frequencyDependentBCT_01_T1,
  'self-monitor (paper)' = PA_frequencyDependentBCT_02_T1,
  'self-monitor (app)' = PA_frequencyDependentBCT_03_T1,
#  'memory cues' = PA_frequencyDependentBCT_04_T1, # Issues with clarity of item wording 
  'goal review' = PA_frequencyDependentBCT_05_T1,
  'personal relevance reflection' = PA_frequencyDependentBCT_06_T1,
  'environmental changes (home)' = PA_frequencyDependentBCT_07_T1,
  'social support' = PA_frequencyDependentBCT_08_T1,
  'analysing goal failure' = PA_frequencyDependentBCT_09_T1,
  'MVPA questionnaire' = padaysLastweek_T1,
  'MVPA accelerometer' = mvpaAccelerometer_T1,
  'intrinsic' = PA_intrinsic_T1,
  'identified' = PA_identified_T1,
  'controlled motivation' = PA_controlled_T1) %>%
 rowwise() %>% 
 dplyr::transmute(
  # 'goal setting' = ifelse(`goal setting` == 1, 0, 1),
  # 'has plan' = ifelse(`own plan` == 1 & `plan by other` == 1, 0, 1),
  # 'own plan' = ifelse(`own plan` == 1, 0, 1),
  # 'plan by other' = ifelse(`plan by other` == 1, 0, 1),
  # 'reminder of plan' = ifelse(`reminder of plan` == 1, 0, 1),
  # 'subgoals' = ifelse(`subgoals` == 1, 0, 1),
  # 'trying new PA' = ifelse(`trying new PA` == 1, 0, 1),
  # 'barrier identification' = ifelse(`barrier identification` == 1, 0, 1),
  # 'problem solving' = ifelse(`problem solving` == 1, 0, 1),
  # 'barriers identified or planned for' = ifelse(`problem solving` == 1 & `barrier identification` == 1, 0, 1),
 # 'PA identity reflection' = ifelse(`PA identity reflection` == 1, 0, 1),
 'aligning PA with life values' = ifelse(`aligning PA with life values` == 1, 0, 1),
  # 'identity, life values' = ifelse(`PA identity reflection` == 1 & `aligning PA with life values` == 1, 0, 1),
  # 'remind of PA benefits' = ifelse(`remind of PA benefits` == 1, 0, 1),
  # 'monitoring PA' = ifelse(`self-monitor (paper)` == 1 & `self-monitor (app)` == 1, 0, 1),
  # 'memory cues' = ifelse(`memory cues` == 1, 0, 1),
  # 'goal review' = ifelse(`goal review` == 1, 0, 1),
  'personal relevance reflection' = ifelse(`personal relevance reflection` == 1, 0, 1),
  # 'environmental changes (home)' = ifelse(`environmental changes (home)` == 1, 0, 1),
  # 'social support' = ifelse(`social support` == 1, 0, 1),
  # 'analysing goal failure' = ifelse(`analysing goal failure` == 1, 0, 1),
  'autonomous motivation' = mean(c(identified, intrinsic), na.rm = TRUE),
#  'girl' = ifelse(girl == "girl", 1, 0),
  'controlled motivation' = ifelse(`controlled motivation` < 3, 0, 1), # If "at least partly" or more true, input 1. Normality otherwise a problem.
  'MVPA questionnaire' = `MVPA questionnaire` * 1, 
  'MVPA accelerometer' = `MVPA accelerometer` * 1) %>%  
  dplyr::select('MVPA questionnaire', 'MVPA accelerometer', everything())

bctdf_mgm$`autonomous motivation`[is.nan(bctdf_mgm$`autonomous motivation`)] <- NA

labs <- names(bctdf_mgm)

bctdf_mgm <- bctdf_mgm %>% na.omit(.)
# bctdf_mgm %>% names()
mgm_variable_types <- c("g", "g", rep("c", 2), "g", "c")
mgm_variable_levels <- c("1", "1", rep("2", 2), "1", "2")
# data.frame(mgm_variable_types, mgm_variable_levels, names(bctdf_mgm))

mgm_obj <- mgm::mgm(data = bctdf_mgm,
  type = mgm_variable_types,
  level = mgm_variable_levels,
  lambdaSel = "CV",
  lambdaFolds = 10,
  pbar = FALSE, 
  binarySign = TRUE)

pred_obj <- predict(object = mgm_obj,
                         data = bctdf_mgm)

pred_obj$errors

# Take R2 from gaussian, CC from categorical variables 
pie_errors <- c(pred_obj$errors[1, 3],
                pred_obj$errors[2, 3],
                pred_obj$errors[3:4, 4],
                pred_obj$errors[5, 3],
                pred_obj$errors[6, 4])

# Coloring nodes: make a sequence of colors from the viridis palette. We need three colors (MVPA, BCTs, motivation), and "begin" from ones that are not too dark, so that black text shows up ok.

node_colors <- c(viridis::viridis(3, begin = 0.4, end = 0.99)[1], # Color 1 for MVPA (questionnaire)
                 viridis::viridis(3, begin = 0.4, end = 0.99)[1], # Color 1 for MVPA (accelerometer)
                 rep(viridis::viridis(3, begin = 0.4, end = 0.99)[2], 2), # 2x Color 2 for BCTs
                 rep(viridis::viridis(3, begin = 0.4, end = 0.99)[3], 1), # Color 3 for motivation (controlled)
                 viridis::viridis(3, begin = 0.4, end = 0.99)[3]) # Color 3 for motivation (autonomous) 

BCT_mgm <- qgraph::qgraph(mgm_obj$pairwise$wadj, 
            layout = "spring",
            repulsion = 0.99, # To nudge the network from originally bad visual state
            title = "cognitive/motivational BCTs, PA & motivation",
            edge.color = ifelse(mgm_obj$pairwise$edgecolor == "darkgreen", "blue", mgm_obj$pairwise$edgecolor),
            pie = pie_errors,
            pieColor = viridis::viridis(5, begin = 0.3, end = 0.8)[5],
            color = node_colors,
            labels = names(bctdf_mgm),
            label.cex = 0.75,
            label.scale = FALSE)

```

Adding the third (I have reminded myself even in my spare time, what kind of positive consequences frequent PA would have in my life):

```{r cognitiveBCTs3}
bctdf_mgm <- df %>% dplyr::select(
#  id,
#  intervention,
#  group,
#  school,
#  girl,
  'goal setting' = PA_agreementDependentBCT_01_T1,
  'own plan' = PA_agreementDependentBCT_02_T1,
  'plan by other' = PA_agreementDependentBCT_03_T1,
  'reminder of plan' = PA_agreementDependentBCT_04_T1,
  'subgoals' = PA_agreementDependentBCT_05_T1,
  'trying new PA' = PA_agreementDependentBCT_06_T1,
  'barrier identification' = PA_agreementDependentBCT_07_T1,
  'problem solving' = PA_agreementDependentBCT_08_T1,
  'PA identity reflection' = PA_agreementDependentBCT_09_T1,
  'aligning PA with life values' = PA_agreementDependentBCT_10_T1,
  'remind of PA benefits' = PA_frequencyDependentBCT_01_T1,
  'self-monitor (paper)' = PA_frequencyDependentBCT_02_T1,
  'self-monitor (app)' = PA_frequencyDependentBCT_03_T1,
#  'memory cues' = PA_frequencyDependentBCT_04_T1, # Issues with clarity of item wording 
  'goal review' = PA_frequencyDependentBCT_05_T1,
  'personal relevance reflection' = PA_frequencyDependentBCT_06_T1,
  'environmental changes (home)' = PA_frequencyDependentBCT_07_T1,
  'social support' = PA_frequencyDependentBCT_08_T1,
  'analysing goal failure' = PA_frequencyDependentBCT_09_T1,
  'MVPA questionnaire' = padaysLastweek_T1,
  'MVPA accelerometer' = mvpaAccelerometer_T1,
  'intrinsic' = PA_intrinsic_T1,
  'identified' = PA_identified_T1,
  'controlled motivation' = PA_controlled_T1) %>%
 rowwise() %>% 
 dplyr::transmute(
  # 'goal setting' = ifelse(`goal setting` == 1, 0, 1),
  # 'has plan' = ifelse(`own plan` == 1 & `plan by other` == 1, 0, 1),
  # 'own plan' = ifelse(`own plan` == 1, 0, 1),
  # 'plan by other' = ifelse(`plan by other` == 1, 0, 1),
  # 'reminder of plan' = ifelse(`reminder of plan` == 1, 0, 1),
  # 'subgoals' = ifelse(`subgoals` == 1, 0, 1),
  # 'trying new PA' = ifelse(`trying new PA` == 1, 0, 1),
  # 'barrier identification' = ifelse(`barrier identification` == 1, 0, 1),
  # 'problem solving' = ifelse(`problem solving` == 1, 0, 1),
  # 'barriers identified or planned for' = ifelse(`problem solving` == 1 & `barrier identification` == 1, 0, 1),
 # 'PA identity reflection' = ifelse(`PA identity reflection` == 1, 0, 1),
 'aligning PA with life values' = ifelse(`aligning PA with life values` == 1, 0, 1),
  # 'identity, life values' = ifelse(`PA identity reflection` == 1 & `aligning PA with life values` == 1, 0, 1),
  'remind of PA benefits' = ifelse(`remind of PA benefits` == 1, 0, 1),
  # 'monitoring PA' = ifelse(`self-monitor (paper)` == 1 & `self-monitor (app)` == 1, 0, 1),
  # 'memory cues' = ifelse(`memory cues` == 1, 0, 1),
  # 'goal review' = ifelse(`goal review` == 1, 0, 1),
  'personal relevance reflection' = ifelse(`personal relevance reflection` == 1, 0, 1),
  # 'environmental changes (home)' = ifelse(`environmental changes (home)` == 1, 0, 1),
  # 'social support' = ifelse(`social support` == 1, 0, 1),
  # 'analysing goal failure' = ifelse(`analysing goal failure` == 1, 0, 1),
  'autonomous motivation' = mean(c(identified, intrinsic), na.rm = TRUE),
#  'girl' = ifelse(girl == "girl", 1, 0),
  'controlled motivation' = ifelse(`controlled motivation` < 3, 0, 1), # If "at least partly" or more true, input 1. Normality otherwise a problem.
  'MVPA questionnaire' = `MVPA questionnaire` * 1, 
  'MVPA accelerometer' = `MVPA accelerometer` * 1) %>%  
  dplyr::select('MVPA questionnaire', 'MVPA accelerometer', everything())

bctdf_mgm$`autonomous motivation`[is.nan(bctdf_mgm$`autonomous motivation`)] <- NA

labs <- names(bctdf_mgm)

bctdf_mgm <- bctdf_mgm %>% na.omit(.)
# bctdf_mgm %>% names()
mgm_variable_types <- c("g", "g", rep("c", 3), "g", "c")
mgm_variable_levels <- c("1", "1", rep("2", 3), "1", "2")
# data.frame(mgm_variable_types, mgm_variable_levels, names(bctdf_mgm))

mgm_obj <- mgm::mgm(data = bctdf_mgm,
  type = mgm_variable_types,
  level = mgm_variable_levels,
  lambdaSel = "CV",
  lambdaFolds = 10,
  pbar = FALSE, 
  binarySign = TRUE)

pred_obj <- predict(object = mgm_obj,
                         data = bctdf_mgm)

pred_obj$errors

# Take R2 from gaussian, CC from categorical variables 
pie_errors <- c(pred_obj$errors[1, 3],
                pred_obj$errors[2, 3],
                pred_obj$errors[3:5, 4],
                pred_obj$errors[6, 3],
                pred_obj$errors[7, 4])

# Coloring nodes: make a sequence of colors from the viridis palette. We need three colors (MVPA, BCTs, motivation), and "begin" from ones that are not too dark, so that black text shows up ok.

node_colors <- c(viridis::viridis(3, begin = 0.4, end = 0.99)[1], # Color 1 for MVPA (questionnaire)
                 viridis::viridis(3, begin = 0.4, end = 0.99)[1], # Color 1 for MVPA (accelerometer)
                 rep(viridis::viridis(3, begin = 0.4, end = 0.99)[2], 3), # 3x Color 2 for BCTs
                 rep(viridis::viridis(3, begin = 0.4, end = 0.99)[3], 1), # Color 3 for motivation (controlled)
                 viridis::viridis(3, begin = 0.4, end = 0.99)[3]) # Color 3 for motivation (autonomous) 

BCT_mgm <- qgraph::qgraph(mgm_obj$pairwise$wadj, 
            layout = "spring",
            repulsion = 0.99, # To nudge the network from originally bad visual state
            title = "cognitive/motivational BCTs, PA & motivation",
            edge.color = ifelse(mgm_obj$pairwise$edgecolor == "darkgreen", "blue", mgm_obj$pairwise$edgecolor),
            pie = pie_errors,
            pieColor = viridis::viridis(5, begin = 0.3, end = 0.8)[5],
            color = node_colors,
            labels = names(bctdf_mgm),
            label.cex = 0.75,
            label.scale = FALSE)

```

Adding the fourth (I have thought about how PA fits my identity (self concept)):

```{r cognitiveBCTs4}
bctdf_mgm <- df %>% dplyr::select(
#  id,
#  intervention,
#  group,
#  school,
#  girl,
  'goal setting' = PA_agreementDependentBCT_01_T1,
  'own plan' = PA_agreementDependentBCT_02_T1,
  'plan by other' = PA_agreementDependentBCT_03_T1,
  'reminder of plan' = PA_agreementDependentBCT_04_T1,
  'subgoals' = PA_agreementDependentBCT_05_T1,
  'trying new PA' = PA_agreementDependentBCT_06_T1,
  'barrier identification' = PA_agreementDependentBCT_07_T1,
  'problem solving' = PA_agreementDependentBCT_08_T1,
  'PA identity reflection' = PA_agreementDependentBCT_09_T1,
  'aligning PA with life values' = PA_agreementDependentBCT_10_T1,
  'remind of PA benefits' = PA_frequencyDependentBCT_01_T1,
  'self-monitor (paper)' = PA_frequencyDependentBCT_02_T1,
  'self-monitor (app)' = PA_frequencyDependentBCT_03_T1,
#  'memory cues' = PA_frequencyDependentBCT_04_T1, # Issues with clarity of item wording 
  'goal review' = PA_frequencyDependentBCT_05_T1,
  'personal relevance reflection' = PA_frequencyDependentBCT_06_T1,
  'environmental changes (home)' = PA_frequencyDependentBCT_07_T1,
  'social support' = PA_frequencyDependentBCT_08_T1,
  'analysing goal failure' = PA_frequencyDependentBCT_09_T1,
  'MVPA questionnaire' = padaysLastweek_T1,
  'MVPA accelerometer' = mvpaAccelerometer_T1,
  'intrinsic' = PA_intrinsic_T1,
  'identified' = PA_identified_T1,
  'controlled motivation' = PA_controlled_T1) %>%
 rowwise() %>% 
 dplyr::transmute(
  # 'goal setting' = ifelse(`goal setting` == 1, 0, 1),
  # 'has plan' = ifelse(`own plan` == 1 & `plan by other` == 1, 0, 1),
  # 'own plan' = ifelse(`own plan` == 1, 0, 1),
  # 'plan by other' = ifelse(`plan by other` == 1, 0, 1),
  # 'reminder of plan' = ifelse(`reminder of plan` == 1, 0, 1),
  # 'subgoals' = ifelse(`subgoals` == 1, 0, 1),
  # 'trying new PA' = ifelse(`trying new PA` == 1, 0, 1),
  # 'barrier identification' = ifelse(`barrier identification` == 1, 0, 1),
  # 'problem solving' = ifelse(`problem solving` == 1, 0, 1),
  # 'barriers identified or planned for' = ifelse(`problem solving` == 1 & `barrier identification` == 1, 0, 1),
 'PA identity reflection' = ifelse(`PA identity reflection` == 1, 0, 1),
 'aligning PA with life values' = ifelse(`aligning PA with life values` == 1, 0, 1),
  # 'identity, life values' = ifelse(`PA identity reflection` == 1 & `aligning PA with life values` == 1, 0, 1),
  'remind of PA benefits' = ifelse(`remind of PA benefits` == 1, 0, 1),
  # 'monitoring PA' = ifelse(`self-monitor (paper)` == 1 & `self-monitor (app)` == 1, 0, 1),
  # 'memory cues' = ifelse(`memory cues` == 1, 0, 1),
  # 'goal review' = ifelse(`goal review` == 1, 0, 1),
  'personal relevance reflection' = ifelse(`personal relevance reflection` == 1, 0, 1),
  # 'environmental changes (home)' = ifelse(`environmental changes (home)` == 1, 0, 1),
  # 'social support' = ifelse(`social support` == 1, 0, 1),
  # 'analysing goal failure' = ifelse(`analysing goal failure` == 1, 0, 1),
  'autonomous motivation' = mean(c(identified, intrinsic), na.rm = TRUE),
#  'girl' = ifelse(girl == "girl", 1, 0),
  'controlled motivation' = ifelse(`controlled motivation` < 3, 0, 1), # If "at least partly" or more true, input 1. Normality otherwise a problem.
  'MVPA questionnaire' = `MVPA questionnaire` * 1, 
  'MVPA accelerometer' = `MVPA accelerometer` * 1) %>%  
  dplyr::select('MVPA questionnaire', 'MVPA accelerometer', everything())

bctdf_mgm$`autonomous motivation`[is.nan(bctdf_mgm$`autonomous motivation`)] <- NA

labs <- names(bctdf_mgm)

bctdf_mgm <- bctdf_mgm %>% na.omit(.)
# bctdf_mgm %>% names()
mgm_variable_types <- c("g", "g", rep("c", 4), "g", "c")
mgm_variable_levels <- c("1", "1", rep("2", 4), "1", "2")
# data.frame(mgm_variable_types, mgm_variable_levels, names(bctdf_mgm))

mgm_obj <- mgm::mgm(data = bctdf_mgm,
  type = mgm_variable_types,
  level = mgm_variable_levels,
  lambdaSel = "CV",
  lambdaFolds = 10,
  pbar = FALSE, 
  binarySign = TRUE)

pred_obj <- predict(object = mgm_obj,
                         data = bctdf_mgm)

pred_obj$errors

# Take R2 from gaussian, CC from categorical variables 
pie_errors <- c(pred_obj$errors[1, 3],
                pred_obj$errors[2, 3],
                pred_obj$errors[3:6, 4],
                pred_obj$errors[7, 3],
                pred_obj$errors[8, 4])

# Coloring nodes: make a sequence of colors from the viridis palette. We need three colors (MVPA, BCTs, motivation), and "begin" from ones that are not too dark, so that black text shows up ok.

node_colors <- c(viridis::viridis(3, begin = 0.4, end = 0.99)[1], # Color 1 for MVPA (questionnaire)
                 viridis::viridis(3, begin = 0.4, end = 0.99)[1], # Color 1 for MVPA (accelerometer)
                 rep(viridis::viridis(3, begin = 0.4, end = 0.99)[2], 4), # 4x Color 2 for BCTs
                 rep(viridis::viridis(3, begin = 0.4, end = 0.99)[3], 1), # Color 3 for motivation (controlled)
                 viridis::viridis(3, begin = 0.4, end = 0.99)[3]) # Color 3 for motivation (autonomous) 

BCT_mgm <- qgraph::qgraph(mgm_obj$pairwise$wadj, 
            layout = "spring",
            repulsion = 0.99, # To nudge the network from originally bad visual state
            title = "cognitive/motivational BCTs, PA & motivation",
            edge.color = ifelse(mgm_obj$pairwise$edgecolor == "darkgreen", "blue", mgm_obj$pairwise$edgecolor),
            pie = pie_errors,
            pieColor = viridis::viridis(5, begin = 0.3, end = 0.8)[5],
            color = node_colors,
            labels = names(bctdf_mgm),
            label.cex = 0.75,
            label.scale = FALSE)

```

Next: Removing motivation items makes the negative connection between positive consequences and MVPA questionnaire disappear (see following plot). One explanation would be [conditioning on a collider](https://web.archive.org/web/20180807095037/http://www.the100.ci/2017/03/14/that-one-weird-third-variable-problem-nobody-ever-mentions-conditioning-on-a-collider/): if both physical activity and thinking about its positive consequences lead to autonomous motivation, this creates a spurious negative link between the two antecedents.

```{r cognitiveBCTs_collider1}
bctdf_mgm <- df %>% dplyr::select(
#  id,
#  intervention,
#  group,
#  school,
#  girl,
  'goal setting' = PA_agreementDependentBCT_01_T1,
  'own plan' = PA_agreementDependentBCT_02_T1,
  'plan by other' = PA_agreementDependentBCT_03_T1,
  'reminder of plan' = PA_agreementDependentBCT_04_T1,
  'subgoals' = PA_agreementDependentBCT_05_T1,
  'trying new PA' = PA_agreementDependentBCT_06_T1,
  'barrier identification' = PA_agreementDependentBCT_07_T1,
  'problem solving' = PA_agreementDependentBCT_08_T1,
  'PA identity reflection' = PA_agreementDependentBCT_09_T1,
  'aligning PA with life values' = PA_agreementDependentBCT_10_T1,
  'remind of PA benefits' = PA_frequencyDependentBCT_01_T1,
  'self-monitor (paper)' = PA_frequencyDependentBCT_02_T1,
  'self-monitor (app)' = PA_frequencyDependentBCT_03_T1,
#  'memory cues' = PA_frequencyDependentBCT_04_T1, # Issues with clarity of item wording 
  'goal review' = PA_frequencyDependentBCT_05_T1,
  'personal relevance reflection' = PA_frequencyDependentBCT_06_T1,
  'environmental changes (home)' = PA_frequencyDependentBCT_07_T1,
  'social support' = PA_frequencyDependentBCT_08_T1,
  'analysing goal failure' = PA_frequencyDependentBCT_09_T1,
  'MVPA questionnaire' = padaysLastweek_T1,
  'MVPA accelerometer' = mvpaAccelerometer_T1,
  'intrinsic' = PA_intrinsic_T1,
  'identified' = PA_identified_T1,
  'controlled motivation' = PA_controlled_T1) %>%
 rowwise() %>% 
 dplyr::transmute(
  # 'goal setting' = ifelse(`goal setting` == 1, 0, 1),
  # 'has plan' = ifelse(`own plan` == 1 & `plan by other` == 1, 0, 1),
  # 'own plan' = ifelse(`own plan` == 1, 0, 1),
  # 'plan by other' = ifelse(`plan by other` == 1, 0, 1),
  # 'reminder of plan' = ifelse(`reminder of plan` == 1, 0, 1),
  # 'subgoals' = ifelse(`subgoals` == 1, 0, 1),
  # 'trying new PA' = ifelse(`trying new PA` == 1, 0, 1),
  # 'barrier identification' = ifelse(`barrier identification` == 1, 0, 1),
  # 'problem solving' = ifelse(`problem solving` == 1, 0, 1),
  # 'barriers identified or planned for' = ifelse(`problem solving` == 1 & `barrier identification` == 1, 0, 1),
 'PA identity reflection' = ifelse(`PA identity reflection` == 1, 0, 1),
 'aligning PA with life values' = ifelse(`aligning PA with life values` == 1, 0, 1),
  # 'identity, life values' = ifelse(`PA identity reflection` == 1 & `aligning PA with life values` == 1, 0, 1),
  'remind of PA benefits' = ifelse(`remind of PA benefits` == 1, 0, 1),
  # 'monitoring PA' = ifelse(`self-monitor (paper)` == 1 & `self-monitor (app)` == 1, 0, 1),
  # 'memory cues' = ifelse(`memory cues` == 1, 0, 1),
  # 'goal review' = ifelse(`goal review` == 1, 0, 1),
  'personal relevance reflection' = ifelse(`personal relevance reflection` == 1, 0, 1),
  # 'environmental changes (home)' = ifelse(`environmental changes (home)` == 1, 0, 1),
  # 'social support' = ifelse(`social support` == 1, 0, 1),
  # 'analysing goal failure' = ifelse(`analysing goal failure` == 1, 0, 1),
  'autonomous motivation' = mean(c(identified, intrinsic), na.rm = TRUE),
#  'girl' = ifelse(girl == "girl", 1, 0),
  'controlled motivation' = ifelse(`controlled motivation` < 3, 0, 1), # If "at least partly" or more true, input 1. Normality otherwise a problem.
  'MVPA questionnaire' = `MVPA questionnaire` * 1, 
  'MVPA accelerometer' = `MVPA accelerometer` * 1) %>%  
  dplyr::select('MVPA questionnaire', 'MVPA accelerometer', everything()) %>% 
  dplyr::select(-'autonomous motivation', -'controlled motivation')

# bctdf_mgm$`autonomous motivation`[is.nan(bctdf_mgm$`autonomous motivation`)] <- NA

labs <- names(bctdf_mgm)

bctdf_mgm <- bctdf_mgm %>% na.omit(.)
# bctdf_mgm %>% names()
mgm_variable_types <- c("g", "g", rep("c", 4))
mgm_variable_levels <- c("1", "1", rep("2", 4))
# data.frame(mgm_variable_types, mgm_variable_levels, names(bctdf_mgm))

mgm_obj <- mgm::mgm(data = bctdf_mgm,
  type = mgm_variable_types,
  level = mgm_variable_levels,
  lambdaSel = "CV",
  lambdaFolds = 10,
  pbar = FALSE, 
  binarySign = TRUE)

pred_obj <- predict(object = mgm_obj,
                         data = bctdf_mgm)

pred_obj$errors

# Take R2 from gaussian, CC from categorical variables 
pie_errors <- c(pred_obj$errors[1, 3],
                pred_obj$errors[2, 3],
                pred_obj$errors[3:6, 4])

# Coloring nodes: make a sequence of colors from the viridis palette. We need three colors (MVPA, BCTs, motivation), and "begin" from ones that are not too dark, so that black text shows up ok.

node_colors <- c(viridis::viridis(3, begin = 0.4, end = 0.99)[1], # Color 1 for MVPA (questionnaire)
                 viridis::viridis(3, begin = 0.4, end = 0.99)[1], # Color 1 for MVPA (accelerometer)
                 rep(viridis::viridis(3, begin = 0.4, end = 0.99)[2], 4)) # 4x Color 2 for BCTs

BCT_mgm <- qgraph::qgraph(mgm_obj$pairwise$wadj, 
            layout = "spring",
            repulsion = 0.99, # To nudge the network from originally bad visual state
            title = "cognitive/motivational BCTs, PA & motivation",
            edge.color = ifelse(mgm_obj$pairwise$edgecolor == "darkgreen", "blue", mgm_obj$pairwise$edgecolor),
            pie = pie_errors,
            pieColor = viridis::viridis(5, begin = 0.3, end = 0.8)[5],
            color = node_colors,
            labels = names(bctdf_mgm),
            label.cex = 0.75,
            label.scale = FALSE)
```

Keeping only the three items showing a presumable conditioning on a collider effect, does not lend support for the simple collider hypothesis with these variables.

```{r cognitiveBCTs_collider2}
bctdf_mgm <- df %>% dplyr::select(
#  id,
#  intervention,
#  group,
#  school,
#  girl,
  'goal setting' = PA_agreementDependentBCT_01_T1,
  'own plan' = PA_agreementDependentBCT_02_T1,
  'plan by other' = PA_agreementDependentBCT_03_T1,
  'reminder of plan' = PA_agreementDependentBCT_04_T1,
  'subgoals' = PA_agreementDependentBCT_05_T1,
  'trying new PA' = PA_agreementDependentBCT_06_T1,
  'barrier identification' = PA_agreementDependentBCT_07_T1,
  'problem solving' = PA_agreementDependentBCT_08_T1,
  'PA identity reflection' = PA_agreementDependentBCT_09_T1,
  'aligning PA with life values' = PA_agreementDependentBCT_10_T1,
  'remind of PA benefits' = PA_frequencyDependentBCT_01_T1,
  'self-monitor (paper)' = PA_frequencyDependentBCT_02_T1,
  'self-monitor (app)' = PA_frequencyDependentBCT_03_T1,
#  'memory cues' = PA_frequencyDependentBCT_04_T1, # Issues with clarity of item wording 
  'goal review' = PA_frequencyDependentBCT_05_T1,
  'personal relevance reflection' = PA_frequencyDependentBCT_06_T1,
  'environmental changes (home)' = PA_frequencyDependentBCT_07_T1,
  'social support' = PA_frequencyDependentBCT_08_T1,
  'analysing goal failure' = PA_frequencyDependentBCT_09_T1,
  'MVPA questionnaire' = padaysLastweek_T1,
  'MVPA accelerometer' = mvpaAccelerometer_T1,
  'intrinsic' = PA_intrinsic_T1,
  'identified' = PA_identified_T1,
  'controlled motivation' = PA_controlled_T1) %>%
 rowwise() %>% 
 dplyr::transmute(
  # 'goal setting' = ifelse(`goal setting` == 1, 0, 1),
  # 'has plan' = ifelse(`own plan` == 1 & `plan by other` == 1, 0, 1),
  # 'own plan' = ifelse(`own plan` == 1, 0, 1),
  # 'plan by other' = ifelse(`plan by other` == 1, 0, 1),
  # 'reminder of plan' = ifelse(`reminder of plan` == 1, 0, 1),
  # 'subgoals' = ifelse(`subgoals` == 1, 0, 1),
  # 'trying new PA' = ifelse(`trying new PA` == 1, 0, 1),
  # 'barrier identification' = ifelse(`barrier identification` == 1, 0, 1),
  # 'problem solving' = ifelse(`problem solving` == 1, 0, 1),
  # 'barriers identified or planned for' = ifelse(`problem solving` == 1 & `barrier identification` == 1, 0, 1),
 # 'PA identity reflection' = ifelse(`PA identity reflection` == 1, 0, 1),
 'aligning PA with life values' = ifelse(`aligning PA with life values` == 1, 0, 1),
  # 'identity, life values' = ifelse(`PA identity reflection` == 1 & `aligning PA with life values` == 1, 0, 1),
  'remind of PA benefits' = ifelse(`remind of PA benefits` == 1, 0, 1),
  # 'monitoring PA' = ifelse(`self-monitor (paper)` == 1 & `self-monitor (app)` == 1, 0, 1),
  # 'memory cues' = ifelse(`memory cues` == 1, 0, 1),
  # 'goal review' = ifelse(`goal review` == 1, 0, 1),
  'personal relevance reflection' = ifelse(`personal relevance reflection` == 1, 0, 1),
  # 'environmental changes (home)' = ifelse(`environmental changes (home)` == 1, 0, 1),
  # 'social support' = ifelse(`social support` == 1, 0, 1),
  # 'analysing goal failure' = ifelse(`analysing goal failure` == 1, 0, 1),
  'autonomous motivation' = mean(c(identified, intrinsic), na.rm = TRUE),
#  'girl' = ifelse(girl == "girl", 1, 0),
  'controlled motivation' = ifelse(`controlled motivation` < 3, 0, 1), # If "at least partly" or more true, input 1. Normality otherwise a problem.
  'MVPA questionnaire' = `MVPA questionnaire` * 1, 
  'MVPA accelerometer' = `MVPA accelerometer` * 1) %>%  
  dplyr::select('MVPA questionnaire', 'autonomous motivation', 'remind of PA benefits')

bctdf_mgm$`autonomous motivation`[is.nan(bctdf_mgm$`autonomous motivation`)] <- NA

labs <- names(bctdf_mgm)

bctdf_mgm <- bctdf_mgm %>% na.omit(.)
# bctdf_mgm %>% names()
mgm_variable_types <- c("g", "g", "c")
mgm_variable_levels <- c("1", "1", "2")
# data.frame(mgm_variable_types, mgm_variable_levels, names(bctdf_mgm))

mgm_obj <- mgm::mgm(data = bctdf_mgm,
  type = mgm_variable_types,
  level = mgm_variable_levels,
  lambdaSel = "CV",
  lambdaFolds = 10,
  pbar = FALSE, 
  binarySign = TRUE)

pred_obj <- predict(object = mgm_obj,
                         data = bctdf_mgm)

pred_obj$errors

# Take R2 from gaussian, CC from categorical variables 
pie_errors <- c(pred_obj$errors[1, 3],
                pred_obj$errors[2, 3],
                pred_obj$errors[3, 4])

# Coloring nodes: make a sequence of colors from the viridis palette. We need three colors (MVPA, BCTs, motivation), and "begin" from ones that are not too dark, so that black text shows up ok.

node_colors <- c(viridis::viridis(3, begin = 0.4, end = 0.99)[1], # Color 1 for MVPA (questionnaire)
                 viridis::viridis(3, begin = 0.4, end = 0.99)[3], # Color 3 for motivation (autonomous) 
                 viridis::viridis(3, begin = 0.4, end = 0.99)[2]) # Color 2 for BCTs

BCT_mgm <- qgraph::qgraph(mgm_obj$pairwise$wadj, 
            layout = "spring",
            repulsion = 0.99, # To nudge the network from originally bad visual state
            title = "cognitive/motivational BCTs, PA & motivation",
            edge.color = ifelse(mgm_obj$pairwise$edgecolor == "darkgreen", "blue", mgm_obj$pairwise$edgecolor),
            pie = pie_errors,
            pieColor = viridis::viridis(5, begin = 0.3, end = 0.8)[5],
            color = node_colors,
            labels = names(bctdf_mgm),
            label.cex = 0.75,
            label.scale = FALSE)

```

# Environmental variables (group, opportunities)

Environmental opportunities include having enough money to be physically active, biking and hiking tracks in one's environment, needed PA equipment (gear), facilities for being physically active (such as sports halls/centres, gyms) nearby, not feeling like lack of PA gear is an obstackle for being active, not being too busy with school, hobbies and/or friends, having good opportunities to be active at home, and not feeling like one's family or religion restricts their activity.

```{r}
environmentdf_mgm_T1 <- df %>% 
  dplyr::select('group feels safe' = groupFeelsSafe_T1,
  'group listens to me' = groupListensToMe_T1,
  'group supports me' = groupSupportsMe_T1,
  'group understands me' = groupUnderstandsMe_T1,
  'group values me' = groupValuesMe_T1,
  "enough money" = PA_opportunities_01_T1,
  "biking and hiking tracks" = PA_opportunities_02_T1,
  "has PA gear" = PA_opportunitiesReverseCoded_03_T1,
  "facilities (e.g. gyms)" = PA_opportunities_04_T1,
  "PA gear no obstacle" = PA_opportunities_05_T1,
  "life not too busy" = PA_opportunitiesReverseCoded_06_T1,
  "opportunities at home" = PA_opportunities_07_T1,  
  "religion or family" = PA_opportunitiesReverseCoded_08_T1,
  'MVPA survey' = padaysLastweek_T1,
  'MVPA accelerometer' = mvpaAccelerometer_T1) %>% 
 rowwise() %>% 
 mutate("religion or family" = ifelse(`religion or family` < 7, 0, 1)) %>% # highly skewed, so dichotomised
  dplyr::select('MVPA survey', 'MVPA accelerometer', everything())

labs <- names(environmentdf_mgm_T1)

# mgm wants full data, see package missForest for imputation methods
environmentdf_mgm_T1 <- environmentdf_mgm_T1 %>% na.omit(.)
# environmentdf_mgm %>% names()
mgm_variable_types <- c(rep("g", 14), rep("c", 1))
mgm_variable_levels <- c(rep("1", 14), rep("2", 1))
# data.frame(mgm_variable_types, mgm_variable_levels, names(environmentdf_mgm))

mgm_obj_T1 <- mgm::mgm(data = environmentdf_mgm_T1,
  type = mgm_variable_types,
  level = mgm_variable_levels,
  lambdaSel = "EBIC",
  # lambdaFolds = 10,
  pbar = FALSE, 
  binarySign = TRUE)

# Node pies:
# pies_T1 <- environmentdf_mgm_T1 %>% 
#   dplyr::summarise_all(~mean(., na.rm = TRUE)) # results in a series of means, which is ok for dichotomous vars
# pies_T1[1] <- pies_T1[1] / 7
# pies_T1[2] <- pies_T1[2] / max(environmentdf_mgm_T1$`MVPA accelerometer`, na.rm = TRUE)
# pies_T1[20] <- pies_T1[20] / 5


node_colors <- c(viridis::viridis(3, begin = 0.4, end = 0.99)[1], # Color 1 for MVPA (questionnaire)
                 viridis::viridis(3, begin = 0.4, end = 0.99)[1], # Color 1 for MVPA (accelerometer)
                 rep(viridis::viridis(3, begin = 0.4, end = 0.99)[2], 5), # 5x Color 2 for group-variables
                 rep(viridis::viridis(3, begin = 0.4, end = 0.99)[3], 8)) # Color 3 for opportunities  

# environment_mgm_T1 <- qgraph::qgraph(mgm_obj_T1$pairwise$wadj, 
#             layout = "spring",
#             repulsion = 0.99, # To nudge the network from originally bad visual state
#             edge.color = ifelse(mgm_obj_T1$pairwise$edgecolor == "darkgreen", "blue", mgm_obj_T1$pairwise$edgecolor),
#             # pie = pies_T1,
#             # pieColor = pie_colors_T1,
#             pieColor = node_colors,
#             labels = names(environmentdf_mgm_T1),
#             # pieBorder = 1,
#             label.cex = 0.75,
#             cut = 0,
#             edge.labels = TRUE,
#             label.scale = FALSE)

environment_mgm_T1_circle <- qgraph::qgraph(mgm_obj_T1$pairwise$wadj, 
            layout = "circle",
            title = "Mixed graphical model: PA, group environment & opportunities",
            edge.color = ifelse(mgm_obj_T1$pairwise$edgecolor == "darkgreen", "blue", mgm_obj_T1$pairwise$edgecolor),
            # pie = pies_T1,
            # pieColor = viridis::viridis(5, begin = 0.3, end = 0.8)[5],
            color = node_colors,
            labels = names(environmentdf_mgm_T1),
            label.cex = 0.75,
            cut = 0,
            label.scale = FALSE)


```



# Exercise types

The first network is an Ising model with all participants. 

```{r exercisetypes-ising}

exerciseTypes_df <- lmi %>% select(Kys0051.1:Kys0064.1) %>% 
  dplyr::select(contains(".1")) %>% 
  dplyr::mutate_all(funs(replace_na(., 0)))
# exerciseTypes_df$track <- df$track
# exerciseTypes_df$girl <- df$girl

names(exerciseTypes_df) <- c("Team ball games", 
                             "Other ball games",
                             "Gym training",
                             "Combat sports",
                             "Fitness classes",
                             "Home workout",
                             "Cycling",
                             "Swimming",
                             "Walking",
                             "Running",
                             "Skiing",
                             "Roller skating", 
                             "Horseback riding",
                             "Other"
                             )

exerciseTypes_df %>% dplyr::summarise_all(funs(sum))

# Roller skating has only 8 observations; leave out
exerciseTypes_df <- exerciseTypes_df %>% dplyr::select(-`Roller skating`)

# Variable types are muddled, change all to numeric
exerciseTypes_df <- as.data.frame(purrr::map(exerciseTypes_df, `class<-`, c("numeric"))) 

# Change data frame to type tbl to allow for spaces
exerciseTypes_df <- as.tbl(exerciseTypes_df)

# Take all names, replace the dots with space
names(exerciseTypes_df) <- stringr::str_replace_all(names(exerciseTypes_df), pattern = "\\.", replacement = " ")

exerciseTypes_network <- bootnet::estimateNetwork(exerciseTypes_df, default="IsingFit")

# Create means for filling nodes
piefill <- exerciseTypes_df %>%
  summarise_all(funs(mean(., na.rm = TRUE))) 

# Plot network
exerciseTypes_ising <- plot(
  exerciseTypes_network, 
  layout = "spring", 
  label.scale = FALSE, 
  title = "Ising fit: self-reported exercise types", 
  # label.cex = 0.75,
  pie = piefill, 
  color = "skyblue",
  pieBorder = 1)

```

Same network, but estimated with mgm:

```{r exercisetypes-mgm}

exerciseTypes_df <- lmi %>% select(Kys0051.1:Kys0064.1) %>% 
  dplyr::select(contains(".1")) %>% 
  dplyr::mutate_all(funs(replace_na(., 0)))
# exerciseTypes_df$track <- df$track
# exerciseTypes_df$girl <- df$girl
# exerciseTypes_df$`PA accelerometer` <- df$mvpaAccelerometer_T1
# exerciseTypes_df$`PA self-report` <- df$padaysLastweek_T1

names(exerciseTypes_df) <- c("Team ball games", 
                             "Other ball games",
                             "Gym training",
                             "Combat sports",
                             "Fitness classes",
                             "Home workout",
                             "Cycling",
                             "Swimming",
                             "Walking",
                             "Running",
                             "Skiing",
                             "Roller skating",
                             "Horseback riding",
                             "Other"
                             # "PA accelerometer",
                             # "PA self-report"
                             )

# Roller skating has only 8 observations; leave out
exerciseTypes_df <- exerciseTypes_df %>% dplyr::select(-`Roller skating`)

# Variable types are muddled, change all to numeric
exerciseTypes_df <- as.data.frame(purrr::map(exerciseTypes_df, `class<-`, c("numeric"))) 

# Change data frame to type tbl to allow for spaces
exerciseTypes_df <- as.tbl(exerciseTypes_df)

# Take all names, replace the dots with space
names(exerciseTypes_df) <- stringr::str_replace_all(names(exerciseTypes_df), pattern = "\\.", replacement = " ")

# Remove incomplete cases
exerciseTypes_df_fullobs <- exerciseTypes_df %>% na.omit()

# Tell mgm, that the first 14 variables are categorical and the last two are gaussian
exerciseTypes_df_variable_types <- c(rep("c", 13))
exerciseTypes_df_variable_levels <- c(rep("2", 13))
# data.frame(exerciseTypes_df_variable_types, exerciseTypes_df_variable_levels, names(exerciseTypes_df))

mgm_obj <- mgm::mgm(data = exerciseTypes_df_fullobs,
  type = exerciseTypes_df_variable_types,
  level = exerciseTypes_df_variable_levels,
  lambdaSel = "CV",
  lambdaFolds = 10,
  pbar = FALSE, 
  binarySign = TRUE)

pred_obj <- predict(object = mgm_obj,
                         data = exerciseTypes_df_fullobs)

# pred_obj$errors

# Take R2 from gaussian, CC from categorical variables 
pie_errors <- c(pred_obj$errors[1:13, 4])

# Define node colors
node_colors <- c(rep(viridis::viridis(3, begin = 0.4, end = 0.95)[1], 13))

exerciseTypes_mgm <- qgraph::qgraph(mgm_obj$pairwise$wadj, 
            layout = "spring",
            repulsion = 0.999, # To nudge the network from originally bad visual state
            title = "Mixed graphical model: Types of reported physical activity",
            edge.color = ifelse(mgm_obj$pairwise$edgecolor == "darkgreen", "blue", mgm_obj$pairwise$edgecolor),
            pie = pie_errors,
            pieColor = viridis::viridis(3, begin = 0.4, end = 0.95)[2],
            color = node_colors,
            labels = names(exerciseTypes_df_fullobs),
            label.cex = 0.75,
            label.scale = FALSE,
            label.color = c(rep("black", 13)))

```

Below, we average the layout and plot these networks side-by-side for comparison.

```{r exercisetypes-comparison}
avglayout <- qgraph::averageLayout(exerciseTypes_mgm, exerciseTypes_ising)

layout(t(1:2))

exerciseTypes_ising <- plot(
  exerciseTypes_network, 
  layout = avglayout, 
  label.scale = FALSE, 
  title = "Ising fit (EBIC model selection)", 
  label.cex = 0.75,
  pie = piefill, 
  color = "skyblue",
  pieBorder = 1)

exerciseTypes_mgm <- qgraph::qgraph(mgm_obj$pairwise$wadj, 
            layout = avglayout,
            repulsion = 0.999, # To nudge the network from originally bad visual state
            title = "Mixed graphical model (Cross-validation)",
            edge.color = ifelse(mgm_obj$pairwise$edgecolor == "darkgreen", "blue", mgm_obj$pairwise$edgecolor),
            pie = pie_errors,
            pieColor = viridis::viridis(3, begin = 0.4, end = 0.95)[2],
            color = node_colors,
            labels = names(exerciseTypes_df_fullobs),
            label.cex = 0.75,
            label.scale = FALSE,
            label.color = c(rep("black", 13))
            )


```

Graph below includes the moderate-to-vigorous physical activity measures, and shows a mixed graphical model with model selection done by cross-validation.

```{r exercisetypes-mgm-CV}

exerciseTypes_df <- lmi %>% select(Kys0051.1:Kys0064.1) %>% 
  dplyr::select(contains(".1")) %>% 
  dplyr::mutate_all(funs(replace_na(., 0)))
# exerciseTypes_df$track <- df$track
# exerciseTypes_df$girl <- df$girl
exerciseTypes_df$`PA accelerometer` <- df$mvpaAccelerometer_T1
exerciseTypes_df$`PA self-report` <- df$padaysLastweek_T1

names(exerciseTypes_df) <- c("Team ball games", 
                             "Other ball games",
                             "Gym training",
                             "Combat sports",
                             "Fitness classes",
                             "Home workout",
                             "Cycling",
                             "Swimming",
                             "Walking",
                             "Running",
                             "Skiing",
                             "Roller skating",
                             "Horseback riding",
                             "Other",
                             "PA accelerometer",
                             "PA self-report"
                             )

# Roller skating has only 8 observations; leave out
exerciseTypes_df <- exerciseTypes_df %>% dplyr::select(-`Roller skating`)

# Variable types are muddled, change all to numeric
exerciseTypes_df <- as.data.frame(purrr::map(exerciseTypes_df, `class<-`, c("numeric"))) 

# Change data frame to type tbl to allow for spaces
exerciseTypes_df <- as.tbl(exerciseTypes_df)

# Take all names, replace the dots with space
names(exerciseTypes_df) <- stringr::str_replace_all(names(exerciseTypes_df), pattern = "\\.", replacement = " ")

# Remove incomplete cases
exerciseTypes_df_fullobs <- exerciseTypes_df %>% na.omit()

# Tell mgm, that the first 14 variables are categorical and the last two are gaussian
exerciseTypes_df_variable_types <- c(rep("c", 13), rep("g", 2))
exerciseTypes_df_variable_levels <- c(rep("2", 13), rep("1", 2))
# data.frame(exerciseTypes_df_variable_types, exerciseTypes_df_variable_levels, names(exerciseTypes_df))

mgm_obj_CV <- mgm::mgm(data = exerciseTypes_df_fullobs,
  type = exerciseTypes_df_variable_types,
  level = exerciseTypes_df_variable_levels,
  lambdaSel = "CV",
  lambdaFolds = 10,
  pbar = FALSE, 
  binarySign = TRUE)

pred_obj <- predict(object = mgm_obj_CV,
                         data = exerciseTypes_df_fullobs)

# pred_obj$errors

# Take R2 from gaussian, CC from categorical variables 
pie_errors <- c(pred_obj$errors[1:13, 4],
                pred_obj$errors[14:15, 3])

# Define node colors
node_colors <- c(rep(viridis::viridis(3, begin = 0.4, end = 0.95)[1], 13),
                 rep(viridis::viridis(3, begin = 0.4, end = 0.95)[3], 2))

exerciseTypes_mgm_withMeasures <- qgraph::qgraph(mgm_obj_CV$pairwise$wadj, 
            layout = "spring",
            repulsion = 0.99, # To nudge the network from originally bad visual state
            title = "Mixed graphical model: Types of reported physical activity and their relations to measured MVPA",
            edge.color = ifelse(mgm_obj_CV$pairwise$edgecolor == "darkgreen", "blue", mgm_obj_CV$pairwise$edgecolor),
            pie = pie_errors,
            pieColor = viridis::viridis(3, begin = 0.4, end = 0.95)[2],
            color = node_colors,
            labels = names(exerciseTypes_df_fullobs),
            label.cex = 0.75,
            label.scale = FALSE,
            label.color = c(rep("black", 15)))


```

The next graph is identical, except that model selection is done by the Extended Bayesian Information Criterion (EBIC).

```{r exercisetypes-mgm-EBIC}

exerciseTypes_df <- lmi %>% select(Kys0051.1:Kys0064.1) %>% 
  dplyr::select(contains(".1")) %>% 
  dplyr::mutate_all(funs(replace_na(., 0)))
# exerciseTypes_df$track <- df$track
# exerciseTypes_df$girl <- df$girl
exerciseTypes_df$`PA accelerometer` <- df$mvpaAccelerometer_T1
exerciseTypes_df$`PA self-report` <- df$padaysLastweek_T1

names(exerciseTypes_df) <- c("Team ball games", 
                             "Other ball games",
                             "Gym training",
                             "Combat sports",
                             "Fitness classes",
                             "Home workout",
                             "Cycling",
                             "Swimming",
                             "Walking",
                             "Running",
                             "Skiing",
                             "Roller skating",
                             "Horseback riding",
                             "Other",
                             "PA accelerometer",
                             "PA self-report"
                             )

# Roller skating has only 8 observations; leave out
exerciseTypes_df <- exerciseTypes_df %>% dplyr::select(-`Roller skating`)

# Variable types are muddled, change all to numeric
exerciseTypes_df <- as.data.frame(purrr::map(exerciseTypes_df, `class<-`, c("numeric"))) 

# Change data frame to type tbl to allow for spaces
exerciseTypes_df <- as.tbl(exerciseTypes_df)

# Take all names, replace the dots with space
names(exerciseTypes_df) <- stringr::str_replace_all(names(exerciseTypes_df), pattern = "\\.", replacement = " ")

# Remove incomplete cases
exerciseTypes_df_fullobs <- exerciseTypes_df %>% na.omit()

# Tell mgm, that the first 14 variables are categorical and the last two are gaussian
exerciseTypes_df_variable_types <- c(rep("c", 13), rep("g", 2))
exerciseTypes_df_variable_levels <- c(rep("2", 13), rep("1", 2))
# data.frame(exerciseTypes_df_variable_types, exerciseTypes_df_variable_levels, names(exerciseTypes_df))

mgm_obj_EBIC <- mgm::mgm(data = exerciseTypes_df_fullobs,
  type = exerciseTypes_df_variable_types,
  level = exerciseTypes_df_variable_levels,
  lambdaSel = "EBIC",
  # lambdaFolds = 10,
  pbar = FALSE, 
  binarySign = TRUE)

pred_obj2 <- predict(object = mgm_obj_EBIC,
                         data = exerciseTypes_df_fullobs)

# pred_obj$errors

# Take R2 from gaussian, CC from categorical variables 
pie_errors2 <- c(pred_obj2$errors[1:13, 4],
                pred_obj2$errors[14:15, 3])

# Define node colors
node_colors <- c(rep(viridis::viridis(3, begin = 0.4, end = 0.95)[1], 13),
                 rep(viridis::viridis(3, begin = 0.4, end = 0.95)[3], 2))

exerciseTypes_mgm_withMeasures2 <- qgraph::qgraph(mgm_obj_EBIC$pairwise$wadj, 
            layout = "spring",
            repulsion = 0.99, # To nudge the network from originally bad visual state
            title = "Mixed graphical model: Types of reported physical activity and their relations to measured MVPA",
            edge.color = ifelse(mgm_obj_EBIC$pairwise$edgecolor == "darkgreen", "blue",
                                mgm_obj_EBIC$pairwise$edgecolor),
            pie = pie_errors2,
            pieColor = viridis::viridis(3, begin = 0.4, end = 0.95)[2],
            color = node_colors,
            labels = names(exerciseTypes_df_fullobs),
            label.cex = 0.75,
            label.scale = FALSE,
            label.color = c(rep("black", 15)))

# exerciseTypes_mgm_withMeasures_cor <- qgraph::qgraph(qgraph::cor_auto(exerciseTypes_df), 
#             layout = "spring",
#             repulsion = 0.99, # To nudge the network from originally bad visual state
#             title = "Bivariate correlations",
#             pie = pie_errors2,
#             pieColor = viridis::viridis(3, begin = 0.4, end = 0.95)[2],
#             color = node_colors,
#             edge.labels = TRUE,
#             labels = names(exerciseTypes_df),
#             label.cex = 0.75,
#             label.scale = FALSE)


```

To compare the two previous graphs, we again average the layout and plot them next to each other.

```{r exercisetypes-comparison2}
avglayout <- qgraph::averageLayout(exerciseTypes_mgm_withMeasures, exerciseTypes_mgm_withMeasures2)

layout(t(1:2))

qgraph::qgraph(mgm_obj_CV$pairwise$wadj, 
            layout = avglayout,
            title = "Mixed graphical model (Cross-validation)",
            edge.color = ifelse(mgm_obj_CV$pairwise$edgecolor == "darkgreen", "blue", mgm_obj_CV$pairwise$edgecolor),
            pie = pie_errors2,
            pieColor = viridis::viridis(3, begin = 0.4, end = 0.95)[2],
            color = node_colors,
            labels = names(exerciseTypes_df_fullobs),
            label.cex = 0.75,
            label.scale = FALSE,
            label.color = c(rep("black", 13)))

qgraph::qgraph(mgm_obj_EBIC$pairwise$wadj, 
            layout = avglayout,
            title = "Mixed graphical model (EBIC model selection)",
            edge.color = ifelse(mgm_obj_EBIC$pairwise$edgecolor == "darkgreen", "blue", mgm_obj_EBIC$pairwise$edgecolor),
            pie = pie_errors2,
            pieColor = viridis::viridis(3, begin = 0.4, end = 0.95)[2],
            color = node_colors,
            labels = names(exerciseTypes_df_fullobs),
            label.cex = 0.75,
            label.scale = FALSE,
            label.color = c(rep("black", 15)))


```

## Bivariate correlations

Table below shows, how correlations between exercise types differ between the accelerometer and self-reported MVPA measure.

```{r exercisetypes-bivariate}

exerciseTypes_df <- lmi %>% select(Kys0051.1:Kys0064.1) %>% 
  dplyr::select(contains(".1")) %>% 
  dplyr::mutate_all(funs(replace_na(., 0)))
# exerciseTypes_df$track <- df$track
# exerciseTypes_df$girl <- df$girl
exerciseTypes_df$`PA accelerometer` <- df$mvpaAccelerometer_T1
exerciseTypes_df$`PA self-report` <- df$padaysLastweek_T1

names(exerciseTypes_df) <- c("Team ball games", 
                             "Other ball games",
                             "Gym training",
                             "Combat sports",
                             "Fitness classes",
                             "Home workout",
                             "Cycling",
                             "Swimming",
                             "Walking",
                             "Running",
                             "Skiing",
                             "Roller skating",
                             "Horseback riding",
                             "Other",
                             "PA accelerometer",
                             "PA self-report"
                             )

# Roller skating has only 8 observations; leave out
exerciseTypes_df <- exerciseTypes_df %>% dplyr::select(-`Roller skating`)

# Variable types are muddled, change all to numeric
exerciseTypes_df <- as.data.frame(purrr::map(exerciseTypes_df, `class<-`, c("numeric"))) 

# Change data frame to type tbl to allow for spaces
exerciseTypes_df <- as.tbl(exerciseTypes_df)

# Take all names, replace the dots with space
names(exerciseTypes_df) <- stringr::str_replace_all(names(exerciseTypes_df), pattern = "\\.", replacement = " ")

qgraph::cor_auto(exerciseTypes_df) %>% data.frame() %>% 
  dplyr::mutate(variable = names(exerciseTypes_df)) %>% 
  dplyr::mutate_at(vars(PA.accelerometer, PA.self.report), funs(round(., 3))) %>% 
  dplyr::select(variable, PA.accelerometer, PA.self.report) %>% 
  dplyr::mutate(diff = PA.accelerometer - PA.self.report) %>% 
  dplyr::arrange(desc(abs(diff))) %>% 
  dplyr::filter(variable != "PA accelerometer", variable != "PA self report") %>% 
  DT::datatable(caption = "Bivariate correlations between PA measures and self-reported activity types")

```

# Chunked BCTs, PA, motivation 

This section shows the correlations structure between BCTs (lumped into chunks based on whether they relate to frequency or agreement), motivational regulations and MVPA (self-reported MVPA the previous week and accelerometer-measured MVPA the following week).

Note: This is only to demonstrate data exploration, as many assumptions (such as multivariate normality, homogeneity, multilevel structure) are not accounted for.   

```{r bivariate-correlations, results = "asis"}

bivariate_BCTs <- df %>% dplyr::select(
  'goal setting' = PA_agreementDependentBCT_01_T1,
  'own plan' = PA_agreementDependentBCT_02_T1,
  'plan by other' = PA_agreementDependentBCT_03_T1,
  'reminder of plan' = PA_agreementDependentBCT_04_T1,
  'subgoals' = PA_agreementDependentBCT_05_T1,
  'trying new PA' = PA_agreementDependentBCT_06_T1,
  'barrier identification' = PA_agreementDependentBCT_07_T1,
  'problem solving' = PA_agreementDependentBCT_08_T1,
  'PA identity reflection' = PA_agreementDependentBCT_09_T1,
  'aligning PA with life values' = PA_agreementDependentBCT_10_T1,
  'remind of PA benefits' = PA_frequencyDependentBCT_01_T1,
  'self-monitor (paper)' = PA_frequencyDependentBCT_02_T1,
  'self-monitor (app)' = PA_frequencyDependentBCT_03_T1,
  'memory cues' = PA_frequencyDependentBCT_04_T1,
  'goal review' = PA_frequencyDependentBCT_05_T1,
  'personal relevance reflection' = PA_frequencyDependentBCT_06_T1,
  'environmental changes (home)' = PA_frequencyDependentBCT_07_T1,
  'social support' = PA_frequencyDependentBCT_08_T1,
  'failure contemplated' = PA_frequencyDependentBCT_09_T1,
  'PA accelerometer' = mvpaAccelerometer_T1,
  'PA self-report' = padaysLastweek_T1,
  'autonomous' = PA_autonomous_T1,
  'controlled' = PA_controlled_T1) %>%
 rowwise() %>% 
  dplyr::select(`PA accelerometer`, `PA self-report`, autonomous, controlled, everything()) %>% 
  mutate_all(as.numeric)

# Create a covariance matrix of the data
covMatrix <- bivariate_BCTs %>% cov(use = "pairwise.complete.obs")

# Transform the matrix so, that lower diagonal of the matrix shows partial correlations,
# while the upper one shows bivariate correlations.
matrix_corLower_parcorUpper <- covMatrix %>% ggm::correlations()

# Show the matrix
matrix_corLower_parcorUpper %>% 
  papaja::apa_table(caption = "Correlation matrix of key variables of interest. Lower diagonal shows bivariate correlations, upper diagonal shows partial correlations")

# Plot the matrix as a correlogram
matrix_corLower_parcorUpper %>% corrgram::corrgram(
  type = "cor",
  lower.panel = corrgram::panel.pie,
  upper.panel = corrgram::panel.pie,
  main = "Bivariate (upper diagonal) and partial (lower diagonal)\ncorrelations of key PA variables")

corMatrix_BCTs <- bivariate_BCTs %>% cor(use = "pairwise.complete.obs", method = "spearman")

as.data.frame(as.table(corMatrix_BCTs)) %>% 
  dplyr::filter(Var1 == "PA accelerometer" | Var1 == "PA self report") %>% 
  dplyr::mutate("Spearman correlation" = Freq %>% round(., 3) %>% format(., nsmall = 3)) %>% 
  dplyr::select(-Freq) %>% 
  dplyr::filter(`Spearman correlation` != 1) %>% 
  dplyr::arrange(desc(`Spearman correlation`)) %>% 
  DT::datatable(caption = "Bivariate correlations between BCTs, motivation and PA. Sorted by strength.")

```

Highest bivariate (Spearman) correlations with self-reported PA:

1. I have tried out new ways for me to be physically active.
2. I have personally made a specific plan ("what, where, how") to implement my PA.
3. I have a PA plan, which has been made by someone else, e.g. my sports club (e.g. a workout schedule).
4. I have set PA goals for myself.
5. I have broken down larger PA goals to smaller subgoals.
6. I have compared my actualized PA with the PA goal I have set.
7. I have attempted to find ways to exercise so, that it won't obstruct but instead helps actualise my other life values.
8. I have thought about which reasons to do PA are important to me personally.
9. I have monitored my PA by marking the PA occasions on an exercise log on paper.
10. I have a way by which I remind myself of my PA plan, e.g. I write it down in the calendar.

## Prepare data and show correlation structure

```{r chunked-dataprep-corr, results = "asis"}
bctdf_chunks <- df %>% dplyr::select(
  'agr-BCTs' = PA_agreementDependentBCT_T1,
  'frq-BCTs' = PA_frequencyDependentBCT_T1,
  'Accelerometer' = mvpaAccelerometer_T1,
  'Self-report' = padaysLastweek_T1,
  'intrinsic' = PA_intrinsic_T1,
  'identified' = PA_identified_T1,
  'introjected' = PA_introjected_T1,
  'extrinsic' = PA_extrinsic_T1) %>%
  rowwise() %>% 
  mutate_all(as.numeric)

labs <- names(bctdf_chunks)

bctdf_chunks %>% 
  corrgram::corrgram( 
         cor.method = "pearson", 
         # diag.panel=panel.minmax, 
         # lower.panel=panel.shade, 
         # lower.panel=panel.ellipse,
         # lower.panel=panel.cor,
         upper.panel=corrgram::panel.conf,
         lower.panel=corrgram::panel.pie,
         outer.labels=list(
           bottom=list(labels=labs,cex=.75, srt=60),
           left=list(labels=labs,cex=.75, srt=30))
         )

# Create a covariance matrix of the data
covMatrix <- bctdf_chunks %>% cov(use = "pairwise.complete.obs")

# Transform the matrix so, that lower diagonal of the matrix shows partial correlations,
# while the upper one shows bivariate correlations.
matrix_corLower_parcorUpper <- covMatrix %>% ggm::correlations()

# Show the matrix
matrix_corLower_parcorUpper %>% 
  papaja::apa_table(caption = "Correlation matrix of key variables of interest. Lower diagonal shows bivariate correlations, upper diagonal shows partial correlations")

# Plot the matrix as a correlogram
matrix_corLower_parcorUpper %>% corrgram::corrgram(
  type = "cor",
  lower.panel = corrgram::panel.pie,
  upper.panel = corrgram::panel.pie,
  main = "Bivariate (upper diagonal) and partial (lower diagonal)\ncorrelations of key PA variables")
```

## Estimate and plot networks

```{r chunked-networks, echo = FALSE, results = 'hide'}

# Estimate a network

nwBCT_chunks <- bootnet::estimateNetwork(bctdf_chunks, default="EBICglasso")

bootnetgraph <- plot(nwBCT_chunks, edge.labels = TRUE)

corgraph <- qgraph::qgraph(qgraph::cor_auto(bctdf_chunks), graph = "cor",
       labels = names(bctdf_chunks),
       edge.labels = TRUE)

pcorgraph <- qgraph::qgraph(qgraph::cor_auto(bctdf_chunks), graph = "pcor",
       labels = names(bctdf_chunks),
       edge.labels = TRUE)

```

```{r chunked-networks2}

# Average the layout according to three previous plots, and plot each according to the layout
avlayout <- qgraph::averageLayout(bootnetgraph, corgraph, pcorgraph)

corgraph <- qgraph::qgraph(qgraph::cor_auto(bctdf_chunks), graph = "cor",
       labels = names(bctdf_chunks),
       edge.labels = TRUE, 
       layout = avlayout, 
       title = "bivariate correlation network",
       theme = "colorblind",
       maximum = max(c(bootnetgraph$graph$Graph$maximum,
                     pcorgraph$graph$Graph$maximum, 
                     corgraph$graph$Graph$maximum)))

# To help with visual comparison, that last argument takes the maximum edge of the three 
# graphs and places that as the benchmark for the thickest line in all plots.

pcorgraph <- qgraph::qgraph(qgraph::cor_auto(bctdf_chunks), graph = "pcor",
       labels = names(bctdf_chunks),
       edge.labels = TRUE, 
       layout = avlayout,
       title = "partial correlation network",
       theme = "colorblind",
       maximum = max(c(bootnetgraph$graph$Graph$maximum,
                     pcorgraph$graph$Graph$maximum, 
                     corgraph$graph$Graph$maximum)))

bootnetgraph <- plot(nwBCT_chunks, 
                     edge.labels = TRUE, 
                     layout = avlayout, 
                     title = "partial correlation network, with LASSO regularisation and EBIC model selection",
       maximum = max(c(bootnetgraph$graph$Graph$maximum,
                     pcorgraph$graph$Graph$maximum, 
                     corgraph$graph$Graph$maximum)))

```

### Stability

```{r chunked-stability}
# bootnet_stability_output <- bootnet::bootnet(nwBCT_chunks, nBoots=1000)
# save(bootnet_stability_output, file = "./Rdata_files/bootnet_stability_output.Rdata")
load("./Rdata_files/bootnet_stability_output.Rdata")

plot(bootnet_stability_output, labels = TRUE, order = "sample") 
plot(bootnet_stability_output, "edge", plot = "difference", onlyNonZero = TRUE, order = "sample")

# bootnet_centrality_stability_output <- bootnet::bootnet(nwBCT_chunks, nBoots=1000,nCores=8, type="case")
# save(bootnet_centrality_stability_output, file = "./Rdata_files/bootnet_centrality_stability_output.Rdata")
load("./Rdata_files/bootnet_centrality_stability_output.Rdata")

plot(bootnet_centrality_stability_output)
plot(bootnet_centrality_stability_output, perNode=T, "strength")


```

# Individual agreement-related BCTs and PA 

Network without combining nodes

```{r individualAgreementBCTs-dataprep-corr, results = "asis"}

bctdf_pa_mgm <- df %>% dplyr::select(
#  id,
#  intervention,
#  group,
#  school,
  'PA selfrep' = padaysLastweek_T1,
  'PA accelerometer' = mvpaAccelerometer_T1,
  'goal setting' = PA_agreementDependentBCT_01_T1,
  'own plan' = PA_agreementDependentBCT_02_T1,
  'plan by other' = PA_agreementDependentBCT_03_T1,
  'reminder of plan' = PA_agreementDependentBCT_04_T1,
  'subgoals' = PA_agreementDependentBCT_05_T1,
  'trying new PA' = PA_agreementDependentBCT_06_T1,
  'barrier identification' = PA_agreementDependentBCT_07_T1,
  'problem solving' = PA_agreementDependentBCT_08_T1,
  'PA identity reflection' = PA_agreementDependentBCT_09_T1,
  'aligning PA with life values' = PA_agreementDependentBCT_10_T1) %>%
 rowwise() %>% 
 mutate(
  'goal setting' = ifelse(`goal setting` == 1, 0, 1),
  # 'has plan' = ifelse(`own plan` == 1 & `plan by other` == 1, 0, 1),
  'own plan' = ifelse(`own plan` == 1, 0, 1),
  'reminder of plan' = ifelse(`reminder of plan` == 1, 0, 1),
  'subgoals' = ifelse(`subgoals` == 1, 0, 1),
  'trying new PA' = ifelse(`trying new PA` == 1, 0, 1),
  'plan by other' = ifelse(`plan by other` == 1, 0, 1),
 'barrier identification' = ifelse(`barrier identification` == 1, 0, 1),
 'problem solving' = ifelse(`problem solving` == 1, 0, 1),
  # 'barriers identified or planned for' = ifelse(`problem solving` == 1 & `barrier identification` == 1, 0, 1),
 'PA identity reflection' = ifelse(`PA identity reflection` == 1, 0, 1),
 'aligning PA with life values' = ifelse(`aligning PA with life values` == 1, 0, 1)) %>% 
  # 'identity, life values' = ifelse(`PA identity reflection` == 1 & `aligning PA with life values` == 1, 0, 1),
  # dplyr::select(-`self-monitor (paper)`, -`self-monitor (app)`, -`plan by other`, -`own plan`, -identified, -intrinsic,
  #        -`failure contemplated`, # only concerns those who haven't reached goals
  #        -`barrier identification`, -`problem solving`, # closely related
  #        -`PA identity reflection`, -`aligning PA with life values`) %>% # closely related
#  dplyr::select(-controlled) %>% # Not really gaussian at all 
  # data.frame %>% 
  mutate_all(as.numeric)

# bctdf_mgm$autonomous[is.nan(bctdf_mgm$autonomous)] <- NA

# Create a covariance matrix of the data
covMatrix <- bctdf_pa_mgm %>% cov(use = "pairwise.complete.obs")

# Transform the matrix so, that lower diagonal of the matrix shows partial correlations,
# while the upper one shows bivariate correlations.
matrix_corLower_parcorUpper <- covMatrix %>% ggm::correlations()

# Show the matrix
matrix_corLower_parcorUpper %>% papaja::apa_table(caption = "Correlation matrix of key variables of interest. Lower diagonal shows bivariate correlations, upper diagonal shows partial correlations")

# Plot the matrix as a correlogram
matrix_corLower_parcorUpper %>% corrgram::corrgram(
  type = "cor",
  lower.panel = corrgram::panel.pie,
  upper.panel = corrgram::panel.pie,
  main = "Bivariate (upper diagonal) and partial (lower diagonal)\ncorrelations of agreement-BCTs and PA")

```

## mgm estimation

```{r individualAgreementBCTs-mgm}
# devtools::install_github("jmbh/mgm")
# Restart R for the latest package
# .r.restartR()

# mgm wants full data, see package missForest for imputation
bctdf_pa_mgm_fullobs <- bctdf_pa_mgm %>% na.omit()

mgm_pa_variable_types <- c("c", "g", rep("c", 10))
mgm_pa_variable_levels <- c("8", "1", rep("2", 10))
# data.frame(mgm_pa_variable_types, mgm_pa_variable_levels, names(bctdf_pa_mgm_fullobs))

mgm_obj <- mgm::mgm(data = bctdf_pa_mgm_fullobs,
  type = mgm_pa_variable_types,
  level = mgm_pa_variable_levels,
  lambdaSel = "CV",
  lambdaFolds = 10,
  pbar = FALSE, 
  binarySign = TRUE)

pred_obj <- predict(object = mgm_obj,
                         data = bctdf_pa_mgm_fullobs)

pred_obj$errors

# Take R2 from gaussian, CC from categorical variables 
pie_errors <- c(pred_obj$errors[1, 4],
                pred_obj$errors[2, 3],
                pred_obj$errors[3:nrow(pred_obj$errors), 4])

# PLOT NETWORK 

node_colors <- c(viridis::viridis(4, begin = 0.3, end = 0.8)[1], 
                 viridis::viridis(4, begin = 0.3, end = 0.8)[2],
                 rep(viridis::viridis(4, begin = 0.3, end = 0.8)[3], 10))

BCT_mgm <- qgraph::qgraph(mgm_obj$pairwise$wadj, 
            layout = "spring",
            repulsion = 0.90, # To nudge the network from originally bad visual state
            title = "agreement-measured BCTs and PA (accelerometer & self-reported)",
            edge.color = ifelse(mgm_obj$pairwise$edgecolor == "darkgreen", "blue", mgm_obj$pairwise$edgecolor),
            pie = pie_errors,
            pieColor = viridis::viridis(4, begin = 0.3, end = 0.8)[4],
            color = node_colors,
            labels = names(bctdf_pa_mgm_fullobs),
            label.cex = 0.75,
            label.scale = FALSE,
            label.color = c(rep("black", 12)))

```

## ggm estimation

```{r individualAgreementBCTs-ggm}

# Estimate a network

individualAgreementBCTs <- bootnet::estimateNetwork(bctdf_pa_mgm, default="EBICglasso")

bootnetgraph <- plot(individualAgreementBCTs, edge.labels = TRUE, 
       title = "partial correlation network, with LASSO regularisation and EBIC model selection")

corgraph <- qgraph::qgraph(qgraph::cor_auto(bctdf_pa_mgm), graph = "cor",
       labels = names(bctdf_pa_mgm),
       edge.labels = TRUE, 
       title = "bivariate correlation network")

pcorgraph <- qgraph::qgraph(qgraph::cor_auto(bctdf_pa_mgm), graph = "pcor",
       labels = names(bctdf_pa_mgm),
       edge.labels = TRUE, 
       title = "partial correlation network")

# Average the layout and plot all according to that
avlayout <- qgraph::averageLayout(bootnetgraph, corgraph, pcorgraph)

corgraph <- qgraph::qgraph(qgraph::cor_auto(bctdf_pa_mgm), graph = "cor",
       labels = names(bctdf_pa_mgm),
       edge.labels = TRUE, 
       layout = avlayout, 
       title = "bivariate correlation network",
       theme = "colorblind",
       maximum = max(c(bootnetgraph$graph$Graph$maximum,
                     pcorgraph$graph$Graph$maximum, 
                     corgraph$graph$Graph$maximum)),
       label.scale = FALSE)

# To help with visual comparison, that last argument takes the maximum edge of the three 
# graphs and places that as the benchmark for the thickest line in all plots.

pcorgraph <- qgraph::qgraph(qgraph::cor_auto(bctdf_pa_mgm), graph = "pcor",
       labels = names(bctdf_pa_mgm),
       edge.labels = TRUE, 
       layout = avlayout,
       title = "partial correlation network",
       theme = "colorblind",
       maximum = max(c(bootnetgraph$graph$Graph$maximum,
                     pcorgraph$graph$Graph$maximum, 
                     corgraph$graph$Graph$maximum)),
       label.scale = FALSE)

bootnetgraph <- plot(individualAgreementBCTs, 
                     edge.labels = TRUE, 
                     layout = avlayout, 
                     title = "partial correlation network, with LASSO regularisation and EBIC model selection",
       maximum = max(c(bootnetgraph$graph$Graph$maximum,
                     pcorgraph$graph$Graph$maximum, 
                     corgraph$graph$Graph$maximum)),
       label.scale = FALSE)
```

### Centrality and stability

For interpretation, see:

Epskamp, S., Borsboom, D., & Fried, E. I. (2018). Estimating psychological networks and their accuracy: A tutorial paper. Behavior Research Methods, 50(1), 195–212. https://doi.org/10.3758/s13428-017-0862-1

For caveats to interpreting centrality, see:

1) Bringmann, L. F., Elmer, T., Epskamp, S., Krause, R. W., Schoch, D., Wichers, M., … Bringmann, L. What do centrality measures measure in psychological networks? Preprint available: https://www.researchgate.net/publication/329129039_What_do_centrality_measures_measure_in_psychological_networks

2) Hallquist, M., Wright, A. G. C., & Molenaar, P. C. M. (2019). Problems with centrality measures in psychopathology symptom networks: Why network psychometrics cannot escape psychometric theory. https://doi.org/10.31234/osf.io/pg4mf

```{r individualAgreementBCTs-stability}

combinedAgreementBcts_centralityPlot <- qgraph::centralityPlot(bootnetgraph)

qgraph::centralityPlot(bootnetgraph, 
               include = c("Strength", "ExpectedInfluence"),
               orderBy = "ExpectedInfluence")

qgraph::centrality(bootnetgraph)$InDegree
scale(qgraph::centrality(bootnetgraph)$InDegree)
qgraph::centrality(bootnetgraph)$Closeness
qgraph::centrality(bootnetgraph)$Betweenness

cor(qgraph::centrality(bootnetgraph)$InDegree, qgraph::centrality(bootnetgraph)$Betweenness, 
    method = "spearman") 

# bootnet_stability_individualAgreementBcts <- bootnet::bootnet(individualAgreementBCTs, nBoots=1000)
# save(bootnet_stability_individualAgreementBcts, file = "./Rdata_files/bootnet_stability_individualAgreementBcts.Rdata")
load("./Rdata_files/bootnet_stability_individualAgreementBcts.Rdata")

plot(bootnet_stability_individualAgreementBcts, labels = TRUE, order = "sample") 
plot(bootnet_stability_individualAgreementBcts, "edge", plot = "difference", onlyNonZero = TRUE, order = "sample")

# bootnet_centrality_stability_individualAgreementBcts <- bootnet::bootnet(individualAgreementBCTs, nBoots=1000,nCores=8, type="case")
# save(bootnet_centrality_stability_individualAgreementBcts, file = "./Rdata_files/bootnet_centrality_stability_individualAgreementBcts.Rdata")
load("./Rdata_files/bootnet_centrality_stability_individualAgreementBcts.Rdata")

plot(bootnet_centrality_stability_individualAgreementBcts)
plot(bootnet_centrality_stability_individualAgreementBcts, perNode=T, "strength")

bootnet::corStability(bootnet_centrality_stability_individualAgreementBcts)
```

# Combined agreement-related BCTs and PA

```{r combinedAgreementBcts-mgm-dataprep-corr}

bctdf_pa_combinedAgreementBcts <- df %>% dplyr::select(
  'PA selfrep' = padaysLastweek_T1,
  'PA accelerometer' = mvpaAccelerometer_T1,
  'goal setting' = PA_agreementDependentBCT_01_T1,
  'own plan' = PA_agreementDependentBCT_02_T1,
  'plan by other' = PA_agreementDependentBCT_03_T1,
  'reminder of plan' = PA_agreementDependentBCT_04_T1,
  'subgoals' = PA_agreementDependentBCT_05_T1,
  'trying new PA' = PA_agreementDependentBCT_06_T1,
  'barrier identification' = PA_agreementDependentBCT_07_T1,
  'problem solving' = PA_agreementDependentBCT_08_T1,
  'PA identity reflection' = PA_agreementDependentBCT_09_T1,
  'aligning PA with life values' = PA_agreementDependentBCT_10_T1) %>%
 rowwise() %>% 
 mutate(
  'goal setting' = ifelse(`goal setting` == 1, 0, 1),
  'has plan' = ifelse(`own plan` == 1 & `plan by other` == 1, 0, 1),
  # 'own plan' = ifelse(`own plan` == 1, 0, 1),
  'reminder of plan' = ifelse(`reminder of plan` == 1, 0, 1),
  'subgoals' = ifelse(`subgoals` == 1, 0, 1),
  'trying new PA' = ifelse(`trying new PA` == 1, 0, 1),
  # 'plan by other' = ifelse(`plan by other` == 1, 0, 1), 
  # 'barrier identification' = ifelse(`barrier identification` == 1, 0, 1),
  # 'problem solving' = ifelse(`problem solving` == 1, 0, 1),
  'barriers identified or planned for' = ifelse(`problem solving` == 1 & `barrier identification` == 1, 0, 1),
  # 'PA identity reflection' = ifelse(`PA identity reflection` == 1, 0, 1),
  # 'aligning PA with life values' = ifelse(`aligning PA with life values` == 1, 0, 1)) %>% 
  'identity, life values' = ifelse(`PA identity reflection` == 1 & `aligning PA with life values` == 1, 0, 1)) %>% 
  dplyr::select(-`plan by other`, -`own plan`,
         -`barrier identification`, -`problem solving`, # closely related
         -`PA identity reflection`, -`aligning PA with life values`) %>% # closely related
  mutate_all(as.numeric)


```

#### mgm estimation

```{r combinedAgreementBcts-mgm}
# devtools::install_github("jmbh/mgm")
# Restart R for the latest package
# .r.restartR()

# mgm wants full data, see package missForest for imputation
bctdf_pa_combinedAgreementBcts <- bctdf_pa_combinedAgreementBcts %>% na.omit()
# bctdf_pa_combinedAgreementBcts %>% names()
mgm_pa_variable_types <- c("g", "g", rep("c", 7))
mgm_pa_variable_levels <- c("1", "1", rep("2", 7))
# data.frame(mgm_pa_variable_types, mgm_pa_variable_levels, names(bctdf_pa_combinedAgreementBcts))

mgm_obj <- mgm::mgm(data = bctdf_pa_combinedAgreementBcts,
  type = mgm_pa_variable_types,
  level = mgm_pa_variable_levels,
  lambdaSel = "CV",
  lambdaFolds = 10,
  pbar = FALSE, 
  binarySign = TRUE)

pred_obj <- predict(object = mgm_obj,
                         data = bctdf_pa_combinedAgreementBcts)

pred_obj$errors

# Take R2 from gaussian, CC from categorical variables 
pie_errors <- c(pred_obj$errors[1, 3],
                pred_obj$errors[2, 3],
                pred_obj$errors[3:nrow(pred_obj$errors), 4])

# PLOT NETWORK 

node_colors <- c(viridis::viridis(4, begin = 0.3, end = 0.8)[1], 
                 viridis::viridis(4, begin = 0.3, end = 0.8)[2],
                 rep(viridis::viridis(4, begin = 0.3, end = 0.8)[3], 7))

BCT_mgm <- qgraph::qgraph(mgm_obj$pairwise$wadj, 
            layout = "spring",
            repulsion = 1, # To nudge the network from originally bad visual state
            title = "agreement-measured BCTs and PA",
            edge.color = ifelse(mgm_obj$pairwise$edgecolor == "darkgreen", "blue", mgm_obj$pairwise$edgecolor),
            pie = pie_errors,
            pieColor = viridis::viridis(4, begin = 0.3, end = 0.8)[4],
            color = node_colors,
            labels = names(bctdf_pa_combinedAgreementBcts),
            label.cex = 0.75,
            label.scale = FALSE,
            label.color = c(rep("black", 9)))


```

## GGM plot

```{r combinedAgreementBcts-ggm-dataprep}

combinedAgreementBcts_ggm_df <- df %>% dplyr::select(
  'PA selfrep' = padaysLastweek_T1,
  'PA accelerometer' = mvpaAccelerometer_T1,
  'goal setting' = PA_agreementDependentBCT_01_T1,
  'own plan' = PA_agreementDependentBCT_02_T1,
  'plan by other' = PA_agreementDependentBCT_03_T1,
  'reminder of plan' = PA_agreementDependentBCT_04_T1,
  'subgoals' = PA_agreementDependentBCT_05_T1,
  'trying new PA' = PA_agreementDependentBCT_06_T1,
  'barrier identification' = PA_agreementDependentBCT_07_T1,
  'problem solving' = PA_agreementDependentBCT_08_T1,
  'PA identity reflection' = PA_agreementDependentBCT_09_T1,
  'aligning PA with life values' = PA_agreementDependentBCT_10_T1) %>%
 rowwise() %>% 
 mutate(
  'has plan' = mean(c(`own plan`, `plan by other`), na.rm = TRUE),
  'barriers identified or planned for' = mean(c(`problem solving`, `barrier identification`), na.rm = TRUE),
  'identity, life values' = mean(c(`PA identity reflection` == 1, `aligning PA with life values`), na.rm = TRUE)) %>% 
  dplyr::select(-`plan by other`, -`own plan`, 
         -`barrier identification`, -`problem solving`, # closely related
         -`PA identity reflection`, -`aligning PA with life values`) %>% # closely related
  mutate_all(as.numeric)

# Create means for filling nodes
# piefill_ggm <- S.total_ggm %>% 
#   dplyr::select(-contains("MVPA"), -girl, -intervention) %>%
#   summarise_all(funs(median(., na.rm = TRUE) / 6)) 
# 
# piefill_ggm$MVPA <- median(S.total_ggm$MVPA, na.rm = TRUE) / (60*24) 
# piefill_ggm$girl <- mean(S.total_ggm$girl, na.rm = TRUE)
# piefill_ggm$intervention <- mean(S.total_ggm$intervention, na.rm = TRUE)
# 
# piefill_ggm <- piefill_ggm %>% dplyr::select(MVPA, girl, intervention, everything())


```

```{r combinedAgreementBcts-ggm, echo = FALSE, results = 'hide'}
# Estimate a network

combinedAgreementBcts_network <- bootnet::estimateNetwork(combinedAgreementBcts_ggm_df, default="EBICglasso")

bootnetgraph <- plot(combinedAgreementBcts_network, edge.labels = TRUE,
                     title = "partial correlation network, with LASSO regularisation and EBIC model selection")

corgraph <- qgraph::qgraph(qgraph::cor_auto(combinedAgreementBcts_ggm_df), graph = "cor",
       labels = names(combinedAgreementBcts_ggm_df),
       edge.labels = TRUE, 
       title = "bivariate correlation network")

pcorgraph <- qgraph::qgraph(qgraph::cor_auto(combinedAgreementBcts_ggm_df), graph = "pcor",
       labels = names(combinedAgreementBcts_ggm_df),
       edge.labels = TRUE,
       title = "partial correlation network")

```

```{r combinedAgreementBcts-ggm2}


# Average the layout of three previous plots, and plot each according to that
avlayout <- qgraph::averageLayout(bootnetgraph, corgraph, pcorgraph)

corgraph <- qgraph::qgraph(qgraph::cor_auto(combinedAgreementBcts_ggm_df), graph = "cor",
       labels = names(combinedAgreementBcts_ggm_df),
       edge.labels = TRUE, 
       layout = avlayout, 
       title = "bivariate correlation network",
       theme = "colorblind",
       maximum = max(c(bootnetgraph$graph$Graph$maximum,
                     pcorgraph$graph$Graph$maximum, 
                     corgraph$graph$Graph$maximum)),
       label.scale = FALSE)

# To help with visual comparison, that last argument takes the maximum edge of the three 
# graphs and places that as the benchmark for the thickest line in all plots.

pcorgraph <- qgraph::qgraph(qgraph::cor_auto(combinedAgreementBcts_ggm_df), graph = "pcor",
       labels = names(combinedAgreementBcts_ggm_df),
       edge.labels = TRUE, 
       layout = avlayout,
       title = "partial correlation network",
       theme = "colorblind",
       maximum = max(c(bootnetgraph$graph$Graph$maximum,
                     pcorgraph$graph$Graph$maximum, 
                     corgraph$graph$Graph$maximum)),
       label.scale = FALSE)

bootnetgraph <- plot(combinedAgreementBcts_network, 
                     edge.labels = TRUE, 
                     layout = avlayout, 
                     title = "partial correlation network, with LASSO regularisation and EBIC model selection",
       maximum = max(c(bootnetgraph$graph$Graph$maximum,
                     pcorgraph$graph$Graph$maximum, 
                     corgraph$graph$Graph$maximum)),
       label.scale = FALSE)

qgraph::flow(bootnetgraph, "PA selfrep", theme = "colorblind", vsize = 8)
qgraph::flow(bootnetgraph, "PA accelerometer", theme = "colorblind", vsize = 8)

```

### Centrality and stability

```{r combinedAgreementBcts-stability}
combinedAgreementBcts_centralityPlot <- qgraph::centralityPlot(bootnetgraph)

qgraph::centralityPlot(bootnetgraph, 
               include = c("Strength", "ExpectedInfluence"),
               orderBy = "ExpectedInfluence")

qgraph::centrality(bootnetgraph)$InDegree
scale(qgraph::centrality(bootnetgraph)$InDegree)
qgraph::centrality(bootnetgraph)$Closeness
qgraph::centrality(bootnetgraph)$Betweenness

cor(qgraph::centrality(bootnetgraph)$InDegree, qgraph::centrality(bootnetgraph)$Betweenness, 
    method = "spearman") 

# bootnet_stability_combinedAgreementBcts <- bootnet::bootnet(combinedAgreementBcts_network, nBoots=1000)
# save(bootnet_stability_combinedAgreementBcts, file = "./Rdata_files/bootnet_stability_combinedAgreementBcts.Rdata")
load("./Rdata_files/bootnet_stability_combinedAgreementBcts.Rdata")

plot(bootnet_stability_combinedAgreementBcts, labels = TRUE, order = "sample") 
plot(bootnet_stability_combinedAgreementBcts, "edge", plot = "difference", onlyNonZero = TRUE, order = "sample")

# bootnet_centrality_stability_combinedAgreementBcts <- bootnet::bootnet(combinedAgreementBcts_network, nBoots=1000,nCores=8, type="case")
# save(bootnet_centrality_stability_combinedAgreementBcts, file = "./Rdata_files/bootnet_centrality_stability_combinedAgreementBcts.Rdata")
load("./Rdata_files/bootnet_centrality_stability_combinedAgreementBcts.Rdata")

plot(bootnet_centrality_stability_combinedAgreementBcts)
plot(bootnet_centrality_stability_combinedAgreementBcts, perNode=T, "strength")

bootnet::corStability(bootnet_centrality_stability_combinedAgreementBcts)

```

### Heterogeneity

The smallest track (IT) has 163 observations. According to the heuristic sample size for p variables for Gaussian data, (p*(p-1)/2 + p), we could estimate about 7 variables. (based on [these slides](https://cvborkulo.files.wordpress.com/2014/09/winterschool2017.pdf) referring to this source: Bühlmann, P. & van de Geer, S. (2011). Statistics for High-Dimensional Data: Methods, Theory and Applications. Springer.)

All tracks seem sufficiently similar on these BCTs.

```{r combinedAgreementBcts-heterogeneity}

combinedAgreementBcts_tracks_df <- df %>% 
  dplyr::select(
  'PA selfrep' = padaysLastweek_T1,
  # 'PA accelerometer' = mvpaAccelerometer_T1,
  'Autonomous' = PA_autonomous_T1,
  'goal setting' = PA_agreementDependentBCT_01_T1,
  'own plan' = PA_agreementDependentBCT_02_T1,
  # 'plan by other' = PA_agreementDependentBCT_03_T1,
  'reminder of plan' = PA_agreementDependentBCT_04_T1,
  'subgoals' = PA_agreementDependentBCT_05_T1,
  # 'trying new PA' = PA_agreementDependentBCT_06_T1,
  'barrier identification' = PA_agreementDependentBCT_07_T1,
  'problem solving' = PA_agreementDependentBCT_08_T1,
  'PA identity reflection' = PA_agreementDependentBCT_09_T1,
  'aligning PA with life values' = PA_agreementDependentBCT_10_T1) %>%
 rowwise() %>% 
 mutate(
  'barriers identified or planned for' = mean(c(`problem solving`, `barrier identification`), na.rm = TRUE), 
  'identity, life values' = mean(c(`PA identity reflection` == 1, `aligning PA with life values`), na.rm = TRUE)) %>% 
  dplyr::select( 
         -`barrier identification`, -`problem solving`, # closely related
         -`PA identity reflection`, -`aligning PA with life values`) %>% # closely related
  mutate_all(as.numeric) 

combinedAgreementBcts_tracks_df <- cbind(track = df$track, combinedAgreementBcts_tracks_df) 

combinedAgreementBcts_tracks_df %>% dplyr::group_by(track) %>% summarise(n = n())

heterogeneity_Nur <- combinedAgreementBcts_tracks_df %>% 
  dplyr::filter(track == "Nur") %>% 
  na.omit() %>% 
  dplyr::select(-track)

heterogeneity_HRC <- combinedAgreementBcts_tracks_df %>% 
  dplyr::filter(track == "HRC") %>% 
  na.omit() %>%  
  dplyr::select(-track)

heterogeneity_BA <- combinedAgreementBcts_tracks_df %>% 
  dplyr::filter(track == "BA") %>% 
  na.omit() %>%  
  dplyr::select(-track)

heterogeneity_IT <- combinedAgreementBcts_tracks_df %>% 
  dplyr::filter(track == "IT") %>% 
  na.omit() %>% 
  dplyr::select(-track)

network_Nur <- bootnet::estimateNetwork(heterogeneity_Nur, default="EBICglasso")
network_HRC <- bootnet::estimateNetwork(heterogeneity_HRC, default="EBICglasso")
network_BA <- bootnet::estimateNetwork(heterogeneity_BA, default="EBICglasso")
network_IT <- bootnet::estimateNetwork(heterogeneity_IT, default="EBICglasso")

graph_Nur <- plot(network_Nur, layout="spring", cut=0, label.scale = FALSE, title = "Practical nurse")
graph_HRC <- plot(network_HRC, layout="spring", cut=0, label.scale = FALSE, title = "HRC")
graph_BA <- plot(network_BA, layout="spring", cut=0, label.scale = FALSE, title = "BA")
graph_IT <- plot(network_IT, layout="spring", cut=0, label.scale = FALSE, title = "IT")

maxedge <- max(c(graph_Nur$graphAttributes$Graph$maximum, 
                 graph_HRC$graphAttributes$Graph$maximum, 
                 graph_BA$graphAttributes$Graph$maximum, 
                 graph_IT$graphAttributes$Graph$maximum))

L <- qgraph::averageLayout(graph_Nur, graph_HRC, graph_BA, graph_IT)

layout(matrix(1:4, nrow = 2, byrow = TRUE))
graph_Nur <- plot(network_Nur, layout=L, cut=0, label.scale = FALSE, title = "Practical nurse", 
                  maximum = maxedge)
graph_HRC <- plot(network_HRC, layout=L, cut=0, label.scale = FALSE, title = "HRC",
                  maximum = maxedge)
graph_BA <- plot(network_BA, layout=L, cut=0, label.scale = FALSE, title = "BA", 
                 maximum = maxedge)
graph_IT <- plot(network_IT, layout=L, cut=0, label.scale = FALSE, title = "IT",
                 maximum = maxedge)

# nct_results <- NetworkComparisonTest::NCT(heterogeneity_Nur, heterogeneity_IT, it=1000, binary.data=FALSE, paired=FALSE, test.edges=TRUE,
# edges='all', progressbar=TRUE)
# 
# save(nct_results, file = "./Rdata_files/nct_results.Rdata")
load("./Rdata_files/nct_results.Rdata")
```

```{r combinedAgreementBcts-heterogeneity-nct}

print("These are the sizes of educational tracks:")
combinedAgreementBcts_tracks_df %>% dplyr::group_by(track) %>% summarise(n = n()) %>% 
  papaja::apa_table()

print("Similarity")
cat("Correlation between Nur and IT edge strengths:", cor(qgraph::centrality(network_Nur)$InDegree, qgraph::centrality(network_IT)$InDegree))

cat("Correlation between Nur and IT networks:", cor(network_Nur$graph[lower.tri(network_Nur$graph)], network_IT$graph[lower.tri(network_Nur$graph)], method="spearman"))

print("Difference")
cat("P-value for the test of identical network structure:", nct_results$nwinv.pval)
cat("P-value for the test of identical connectivity in networks:", nct_results$glstrinv.pval)
nct_results$einv.pvals %>% 
  papaja::apa_table(caption = "p-values on difference test in edges between Nur and IT")

cat("Number of edges, which appear different (p<0.05):", sum(nct_results$einv.pvals$"p-value" < 0.05))

```


# Ising networks

## Plot with only the BCTs

Prepare and dichotomise data (lots of skew in distributions).

```{r onlyAllBctsIsing-dataprep}
nItems <- 19

bctdf <- df %>% dplyr::select(id,
  intervention,
  group,
  school,
  girl,
  'goal setting' = PA_agreementDependentBCT_01_T1,
  'own plan' = PA_agreementDependentBCT_02_T1,
  'plan by other' = PA_agreementDependentBCT_03_T1,
  'reminder of plan' = PA_agreementDependentBCT_04_T1,
  'subgoals' = PA_agreementDependentBCT_05_T1,
  'trying new PA' = PA_agreementDependentBCT_06_T1,
  'barrier identification' = PA_agreementDependentBCT_07_T1,
  'problem solving' = PA_agreementDependentBCT_08_T1,
  'PA identity reflection' = PA_agreementDependentBCT_09_T1,
  'aligning PA with life values' = PA_agreementDependentBCT_10_T1,
  'remind of PA benefits' = PA_frequencyDependentBCT_01_T1,
  'self-monitor (paper)' = PA_frequencyDependentBCT_02_T1,
  'self-monitor (app)' = PA_frequencyDependentBCT_03_T1,
  'memory cues' = PA_frequencyDependentBCT_04_T1,
  'goal review' = PA_frequencyDependentBCT_05_T1,
  'personal relevance reflection' = PA_frequencyDependentBCT_06_T1,
  'environmental changes (home)' = PA_frequencyDependentBCT_07_T1,
  'social support' = PA_frequencyDependentBCT_08_T1,
  'failure contemplated' = PA_frequencyDependentBCT_09_T1) %>%
 mutate(
  'goal setting' = ifelse(`goal setting` == 1, 0, 1),
  'own plan' = ifelse(`own plan` == 1, 0, 1),
  'plan by other' = ifelse(`plan by other` == 1, 0, 1),
  'reminder of plan' = ifelse(`reminder of plan` == 1, 0, 1),
  'subgoals' = ifelse(`subgoals` == 1, 0, 1),
  'trying new PA' = ifelse(`trying new PA` == 1, 0, 1),
  'barrier identification' = ifelse(`barrier identification` == 1, 0, 1),
  'problem solving' = ifelse(`problem solving` == 1, 0, 1),
  'PA identity reflection' = ifelse(`PA identity reflection` == 1, 0, 1),
  'aligning PA with life values' = ifelse(`aligning PA with life values` == 1, 0, 1),
  'remind of PA benefits' = ifelse(`remind of PA benefits` == 1, 0, 1),
  'self-monitor (paper)' = ifelse(`self-monitor (paper)` == 1, 0, 1),
  'self-monitor (app)' = ifelse(`self-monitor (app)` == 1, 0, 1),
  'memory cues' = ifelse(`memory cues` == 1, 0, 1),
  'goal review' = ifelse(`goal review` == 1, 0, 1),
  'personal relevance reflection' = ifelse(`personal relevance reflection` == 1, 0, 1),
  'environmental changes (home)' = ifelse(`environmental changes (home)` == 1, 0, 1),
  'social support' = ifelse(`social support` == 1, 0, 1),
  'failure contemplated' = ifelse(`failure contemplated` == 1, 0, 1)) 

S.boys <- bctdf %>% filter(girl == "boy") %>% dplyr::select(`goal setting`:ncol(bctdf)) %>% na.omit(.) 
S.girls <- bctdf %>% filter(girl == "girl") %>% dplyr::select(`goal setting`:ncol(bctdf)) %>% na.omit(.)
nwBoys <- bootnet::estimateNetwork(S.boys, default="IsingFit")
nwGirls <- bootnet::estimateNetwork(S.girls, default="IsingFit")

# Create means for filling nodes

girlmeans <- bctdf %>%
  dplyr::filter(girl == "girl") %>% 
  summarise_at(vars(-(id:girl)),
  funs(mean(., na.rm = TRUE))) 

boymeans <- bctdf %>%
  dplyr::filter(girl == "boy") %>% 
  summarise_at(vars(-(id:girl)),
  funs(mean(., na.rm = TRUE))) 

```

For girls and boys.

```{r onlyAllBctsIsing-girlsboys}

# Find average layout for comparability and plot graphs next to each other

Layout <- qgraph::averageLayout(nwGirls, nwBoys)

layout(t(1:2))

plot(nwGirls, layout = Layout, label.scale = FALSE, title = "Girls", label.cex = 0.75,
     pie = girlmeans, 
     color = "skyblue",
     pieBorder = 1)

plot(nwBoys, layout = Layout, label.scale = FALSE, title = "Boys", label.cex = 0.75, 
     pie = boymeans, 
     color = "skyblue",
     pieBorder = 1)

```

### Network comparison test: boys vs. girls

```{r nctboysgirls, cache = TRUE, results = "asis"}

# nct_results <- NetworkComparisonTest::NCT(S.boys, S.girls, it=1000, binary.data=TRUE, paired=FALSE, test.edges=TRUE, edges='all', progressbar=TRUE)

# save(nct_results, file = "./Rdata_files/nct_results.Rdata")
load("./Rdata_files/nct_results.Rdata")

cat("P-value of network structure difference test:", nct_results$nwinv.pval)
cat("P-value of global connectivity difference test:", nct_results$glstrinv.pval)
nct_results$einv.pvals %>% 
  dplyr::filter(`p-value` < 1) %>%      #p values testing diffs for all individual edges 
  knitr::kable(caption = "P-values for edge strength differences among boys and girls. Omitted edges where p = 1.")

```

For all participants.

```{r onlyAllBctsIsing-allparticipants}

S.total <- bctdf %>% dplyr::select(6:ncol(bctdf))
nwBCT <- bootnet::estimateNetwork(S.total, default="IsingFit")

# Create means for filling nodes
piefill <- S.total %>%
  summarise_all(funs(mean(., na.rm = TRUE))) 

# Plot network
Ising_fit <- plot(nwBCT, layout = "spring", 
     label.scale = FALSE, title = "Ising fit", label.cex = 0.75,
     pie = piefill, 
     color = "skyblue",
     pieBorder = 1,
     # DoNotPlot = TRUE
     )

# # Estimate ising network without regularisation DOES NOT CONVERGE --> OMITTED
# nwBCT_nonreg <- bootnet::estimateNetwork(S.total, default="IsingSampler")
# 
# nonreg <- plot(nwBCT_nonreg, layout = "spring", 
#      label.scale = FALSE, title = "Non-regularised Ising model", label.cex = 0.75,
#      pie = piefill, 
#      color = "skyblue",
#      pieBorder = 1,
#      DoNotPlot = TRUE)
# 
# layout_allParticipants <- qgraph::averageLayout(Ising_fit, nonreg)
# 
# # Plot network
# plot(nwBCT, layout = "layout_allParticipants", 
#      label.scale = FALSE, title = "Ising fit", label.cex = 0.75,
#      pie = piefill, 
#      color = "skyblue",
#      pieBorder = 1)
# 
# plot(nwBCT_nonreg, layout = "layout_allParticipants", 
#      label.scale = FALSE, title = "Non-regularised Ising model", label.cex = 0.75,
#      pie = piefill, 
#      color = "skyblue",
#      pieBorder = 1)
```

## Ising network Combined items 

```{r onlyCombinedBctsIsing-dataprep}
nItems <- 17

bctdf <- df %>% dplyr::select(id,
  intervention,
  group,
  school,
  girl,
  'goal setting' = PA_agreementDependentBCT_01_T1,
  'own plan' = PA_agreementDependentBCT_02_T1,
  'plan by other' = PA_agreementDependentBCT_03_T1,
  'reminder of plan' = PA_agreementDependentBCT_04_T1,
  'subgoals' = PA_agreementDependentBCT_05_T1,
  'trying new PA' = PA_agreementDependentBCT_06_T1,
  'barrier identification' = PA_agreementDependentBCT_07_T1,
  'problem solving' = PA_agreementDependentBCT_08_T1,
  'PA identity reflection' = PA_agreementDependentBCT_09_T1,
  'aligning PA with life values' = PA_agreementDependentBCT_10_T1,
  'remind of PA benefits' = PA_frequencyDependentBCT_01_T1,
  'self-monitor (paper)' = PA_frequencyDependentBCT_02_T1,
  'self-monitor (app)' = PA_frequencyDependentBCT_03_T1,
#  'memory cues' = PA_frequencyDependentBCT_04_T1,
  'goal review' = PA_frequencyDependentBCT_05_T1,
  'personal relevance reflection' = PA_frequencyDependentBCT_06_T1,
  'environmental changes (home)' = PA_frequencyDependentBCT_07_T1,
  'social support' = PA_frequencyDependentBCT_08_T1,
  'failure contemplated' = PA_frequencyDependentBCT_09_T1) %>%
 mutate(
  'goal setting' = ifelse(`goal setting` == 1, 0, 1),
  'own plan' = ifelse(`own plan` == 1 & `plan by other` == 1, 0, 1),
  'reminder of plan' = ifelse(`reminder of plan` == 1, 0, 1),
  'subgoals' = ifelse(`subgoals` == 1, 0, 1),
  'trying new PA' = ifelse(`trying new PA` == 1, 0, 1),
  'barrier identification' = ifelse(`barrier identification` == 1, 0, 1),
  'problem solving' = ifelse(`problem solving` == 1, 0, 1),
  'PA identity reflection' = ifelse(`PA identity reflection` == 1, 0, 1),
  'aligning PA with life values' = ifelse(`aligning PA with life values` == 1, 0, 1),
  'remind of PA benefits' = ifelse(`remind of PA benefits` == 1, 0, 1),
  'self-monitor' = ifelse(`self-monitor (paper)` == 1 & `self-monitor (app)` == 1, 0, 1),
#  'memory cues' = ifelse(`memory cues` == 1, 0, 1),
  'goal review' = ifelse(`goal review` == 1, 0, 1),
  'personal relevance reflection' = ifelse(`personal relevance reflection` == 1, 0, 1),
  'environmental changes (home)' = ifelse(`environmental changes (home)` == 1, 0, 1),
  'social support' = ifelse(`social support` == 1, 0, 1),
  'failure contemplated' = ifelse(`failure contemplated` == 1, 0, 1)) %>%
  dplyr::select(-`self-monitor (paper)`, -`self-monitor (app)`, -`plan by other`) %>% 
  mutate_all(as.numeric)

# Network for all participants

S.total <- bctdf %>% dplyr::select(6:ncol(bctdf))
nwBCT <- bootnet::estimateNetwork(S.total, default="IsingFit")

# Create means for filling nodes
piefill <- S.total %>%
  summarise_all(funs(mean(., na.rm = TRUE))) 

# Plot network
plot(nwBCT, layout = "spring", label.scale = FALSE, title = "Ising fit", label.cex = 0.75,
     pie = piefill, 
     color = "skyblue",
     pieBorder = 1)

# # Estimate ising network without regularisation
# nwBCT_nonreg <- bootnet::estimateNetwork(S.total, default="IsingSampler")
# 
# plot(nwBCT_nonreg, layout = "spring", label.scale = FALSE, title = "Non-regularised Ising model", label.cex = 0.75,
#      pie = piefill, 
#      color = "skyblue",
#      pieBorder = 1)
```

#### Centrality and stability

```{r onlyCombinedBctsIsing-stability, cache = TRUE}

onlyCombinedBctsIsing <- nwBCT_ggm

onlyCombinedBctsIsing_centralityPlot <- qgraph::centralityPlot(onlyCombinedBctsIsing)

qgraph::centrality(onlyCombinedBctsIsing)$InDegree
scale(qgraph::centrality(onlyCombinedBctsIsing)$InDegree)
qgraph::centrality(onlyCombinedBctsIsing)$Closeness
qgraph::centrality(onlyCombinedBctsIsing)$Betweenness

cor(qgraph::centrality(onlyCombinedBctsIsing)$InDegree, qgraph::centrality(onlyCombinedBctsIsing)$Betweenness, 
    method = "spearman") 

# bootnet_stability_onlyCombinedBctsIsing <- bootnet::bootnet(onlyCombinedBctsIsing, nBoots=1000)
# save(bootnet_stability_onlyCombinedBctsIsing, file = "./Rdata_files/bootnet_stability_onlyCombinedBctsIsing.Rdata")
load("./Rdata_files/bootnet_stability_onlyCombinedBctsIsing.Rdata")

plot(bootnet_stability_onlyCombinedBctsIsing, labels = FALSE, order = "sample") 
plot(bootnet_stability_onlyCombinedBctsIsing, labels = FALSE, "edge", plot = "difference", onlyNonZero = TRUE, order = "sample")

# bootnet_centrality_stability_onlyCombinedBctsIsing <- bootnet::bootnet(onlyCombinedBctsIsing, nBoots=1000,nCores=8, type="case")
# save(bootnet_centrality_stability_onlyCombinedBctsIsing, file = "./Rdata_files/bootnet_centrality_stability_onlyCombinedBctsIsing.Rdata")
load("./Rdata_files/bootnet_centrality_stability_onlyCombinedBctsIsing.Rdata")

plot(bootnet_centrality_stability_onlyCombinedBctsIsing)
plot(bootnet_centrality_stability_onlyCombinedBctsIsing, perNode=T, "strength")

bootnet::corStability(bootnet_centrality_stability_onlyCombinedBctsIsing)

```

### GGM BCTs & motivation 

The pie on nodes represents the median, as proportion of the theoretical maximum value (i.e. highest value on the questionnaire scale).

```{r bct-moti-ggm-noncombined}
library(corrgram)

nItems <- 19

bctdf <- df %>% dplyr::select(id,
  intervention,
  group,
  school,
  girl,
  'Autonomous' = PA_autonomous_T1,
  'Controlled' = PA_controlled_T1,
  'goal setting' = PA_agreementDependentBCT_01_T1,
  'own plan' = PA_agreementDependentBCT_02_T1,
  'plan by other' = PA_agreementDependentBCT_03_T1,
  'reminder of plan' = PA_agreementDependentBCT_04_T1,
  'subgoals' = PA_agreementDependentBCT_05_T1,
  'trying new PA' = PA_agreementDependentBCT_06_T1,
  'barrier identification' = PA_agreementDependentBCT_07_T1,
  'problem solving' = PA_agreementDependentBCT_08_T1,
  'PA identity reflection' = PA_agreementDependentBCT_09_T1,
  'aligning PA with life values' = PA_agreementDependentBCT_10_T1,
  'remind of PA benefits' = PA_frequencyDependentBCT_01_T1,
  'self-monitor (paper)' = PA_frequencyDependentBCT_02_T1,
  'self-monitor (app)' = PA_frequencyDependentBCT_03_T1,
#  'memory cues' = PA_frequencyDependentBCT_04_T1,
  'goal review' = PA_frequencyDependentBCT_05_T1,
  'personal relevance reflection' = PA_frequencyDependentBCT_06_T1,
  'environmental changes (home)' = PA_frequencyDependentBCT_07_T1,
  'social support' = PA_frequencyDependentBCT_08_T1,
  'failure contemplated' = PA_frequencyDependentBCT_09_T1) %>%
  rowwise() %>% 
  mutate( 
  #'has plan' = mean(c(`own plan`, `plan by other`), na.rm = TRUE),
  'self-monitor' = mean(c(`self-monitor (paper)`, `self-monitor (app)`), na.rm = TRUE)) %>%
  dplyr::select(-`self-monitor (paper)`, -`self-monitor (app)`) %>%
  mutate_all(as.numeric)

# Network for all participants

S.total <- bctdf %>% dplyr::select(`Autonomous`:ncol(bctdf))
nwBCT <- bootnet::estimateNetwork(S.total, default="EBICglasso")

# Plot correlations (minmax crowds the diagonal as it plots the minimum and maximum values for each variable).
labs <- colnames(S.total)
corrgram::corrgram(S.total, 
         cor.method = "spearman", 
         # diag.panel=panel.minmax, 
         # lower.panel=panel.shade, 
         # lower.panel=panel.ellipse,
         # lower.panel=panel.cor,
         upper.panel=corrgram::panel.conf,
         lower.panel=corrgram::panel.conf,
         outer.labels=list(
           bottom=list(labels=labs,cex=.75, srt=60),
           left=list(labels=labs,cex=.75, srt=30))
         )

# Create means for filling nodes
piefill <- S.total %>%
  dplyr::select(-Autonomous, -Controlled) %>%
  data.frame() %>% 
  summarise_all(funs(mean(., na.rm = TRUE) / 6)) 

piefill$Autonomous <- median(S.total$Autonomous, na.rm = TRUE) / 5
piefill$Controlled <- median(S.total$Controlled, na.rm = TRUE) / 5

piefill <- piefill %>% select(Autonomous, Controlled, everything())

# Plot network
plot(nwBCT, layout = "spring", label.scale = FALSE, title = "GGM: BCTs & motivation", label.cex = 0.75,
     pie = piefill, 
     color = "skyblue",
     pieBorder = 1)



```

Network after combining goal setting and own planning, as well as barrier identification and problem solving:

```{r bct-moti-ggm-combined}
# Combine items further:
bctdf2 <- bctdf %>% rowwise %>% 
  dplyr::mutate('goals and plans' = mean(c(`goal setting`, `own plan`), na.rm = TRUE)) %>% 
  dplyr::mutate('barriers identified\nand planned for' = mean(c(`barrier identification`, `problem solving`), na.rm = TRUE)) %>% 
  dplyr::select(-`goal setting`, -`own plan`, -`barrier identification`, -`problem solving`)

S.total2 <- bctdf2 %>% dplyr::select(`Autonomous`:ncol(bctdf2))
nwBCT2 <- bootnet::estimateNetwork(S.total2, default="EBICglasso")

# Create means for filling nodes
piefill2 <- S.total2 %>%
  dplyr::select(-Autonomous, -Controlled) %>%
  data.frame() %>% 
  summarise_all(funs(median(., na.rm = TRUE) / 6)) 

piefill2$Autonomous <- median(S.total$Autonomous, na.rm = TRUE) / 5
piefill2$Controlled <- median(S.total$Controlled, na.rm = TRUE) / 5

piefill2 <- piefill2 %>% select(Autonomous, Controlled, everything())

# Plot network
plot(nwBCT2, layout = "spring", label.scale = FALSE, title = "GGM, BCTs & motivation, items combined", label.cex = 0.75,
     pie = piefill2, 
     color = "skyblue",
     pieBorder = 1)

```



#### Stability and robustness

Robustness test 

```{r bct-robustness}
print("Original items:")
qgraph::centralityPlot(nwBCT)

print("Combined items:")
qgraph::centralityPlot(nwBCT2)

# BCTboot1 <- bootnet::bootnet(nwBCT, nBoots = 2500)
# BCTboot2 <- bootnet::bootnet(nwBCT2, nBoots = 2500)
# save(BCTboot1, file = "./Rdata_files/BCTboot1.Rdata")
# save(BCTboot2, file = "./Rdata_files/BCTboot2.Rdata")

load("./Rdata_files/BCTboot1.Rdata")
load("./Rdata_files/BCTboot2.Rdata")

print("Original items:")
plot(BCTboot1, labels = FALSE, order = "sample")

print("Combined items:")
plot(BCTboot2, labels = FALSE, order = "sample")

autEdges <- summary(BCTboot1, statistics = "edge", rank = TRUE) %>% 
  dplyr::arrange(mean) %>% 
  dplyr::filter(stringr::str_detect(node1, 'Autonomous')) %>% # str_detect(id, 'Autonomous|Controlled') for both
  dplyr::filter(!(node2 == 'Controlled')) %>% 
  data.frame() %>% 
  dplyr::select(CIlower, mean, CIupper, node2)

contEdges <- summary(BCTboot1, statistics = "edge", rank = TRUE) %>% 
  dplyr::arrange(mean) %>% 
  dplyr::filter(stringr::str_detect(node1, 'Controlled')) %>% # str_detect(id, 'Autonomous|Controlled') for both
  data.frame() %>% 
  dplyr::select(CIlower, mean, CIupper, node2)

userfriendlyscience::diamondPlot(autEdges, 
            ciCols = c("CIlower", "mean", "CIupper"), 
            color = viridis::viridis(2, end = 0.8)[1], 
            alpha = 0.3, 
            yLabels = autEdges$node2, 
            fixedSize = 0.3, 
            xlab = NULL) +
  userfriendlyscience::diamondPlot(contEdges, 
              ciCols = c("CIlower", "mean", "CIupper"), 
              color = viridis::viridis(2, end = 0.8)[2], 
              alpha = 0.3, 
              yLabels = autEdges$node2, 
              fixedSize = 0.3, 
              xlab = NULL, 
              returnLayerOnly = TRUE) +
  geom_rect(aes(xmin=Inf, xmax=Inf, ymin=Inf, ymax=Inf, fill = "Controlled"), 
            colour=NA, alpha=0.05) + # Create invisible rectangle for legend
  geom_rect(aes(xmin=Inf, xmax=Inf, ymin=Inf, ymax=Inf, fill = "Autonomous"), 
            colour=NA, alpha=0.05) + # Create invisible rectangle for legend
  scale_fill_manual('Connected node',
                      values = viridis::viridis(2, end = 0.8)[1:2],  
                      guide = guide_legend(override.aes = list(alpha = 1))) +
  ggtitle("Relative strengths of edges containing autonomous \nor controlled motivation (model with all items)")
  
# Combined items

autEdges <- summary(BCTboot2, statistics = "edge", rank = TRUE) %>% 
  dplyr::arrange(mean) %>% 
  dplyr::filter(stringr::str_detect(node1, 'Autonomous')) %>% # str_detect(id, 'Autonomous|Controlled') for both
  dplyr::filter(!(node2 == 'Controlled')) %>% 
  data.frame() %>% 
  dplyr::select(CIlower, mean, CIupper, node2)

contEdges <- summary(BCTboot2, statistics = "edge", rank = TRUE) %>% 
  dplyr::arrange(mean) %>% 
  dplyr::filter(stringr::str_detect(node1, 'Controlled')) %>% # str_detect(id, 'Autonomous|Controlled') for both
  data.frame() %>% 
  dplyr::select(CIlower, mean, CIupper, node2)

userfriendlyscience::diamondPlot(autEdges, 
            ciCols = c("CIlower", "mean", "CIupper"), 
            color = viridis::viridis(2, end = 0.8)[1], 
            alpha = 0.3, 
            yLabels = autEdges$node2, 
            fixedSize = 0.3, 
            xlab = NULL) +
  userfriendlyscience::diamondPlot(contEdges, 
              ciCols = c("CIlower", "mean", "CIupper"), 
              color = viridis::viridis(2, end = 0.8)[2], 
              alpha = 0.3, 
              yLabels = autEdges$node2, 
              fixedSize = 0.3, 
              xlab = NULL, 
              returnLayerOnly = TRUE) +
  geom_rect(aes(xmin=Inf, xmax=Inf, ymin=Inf, ymax=Inf, fill = "Controlled"), 
            colour=NA, alpha=0.05) + # Create invisible rectangle for legend
  geom_rect(aes(xmin=Inf, xmax=Inf, ymin=Inf, ymax=Inf, fill = "Autonomous"), 
            colour=NA, alpha=0.05) + # Create invisible rectangle for legend
  scale_fill_manual('Connected node',
                      values = viridis::viridis(2, end = 0.8)[1:2],  
                      guide = guide_legend(override.aes = list(alpha = 1))) +
  ggtitle("Relative strengths of edges containing autonomous \nor controlled motivation (model with combined items)")

# summary(BCTboot1, statistics = "edge", rank = TRUE) %>% 
#   dplyr::arrange(mean) %>% 
#   dplyr::filter(stringr::str_detect(id, 'Controlled')) %>%
#   data.frame() %>% 
#   dplyr::select(CIlower, mean, CIupper, id) %>% 
#   userfriendlyscience::diamondPlot(ciCols = c("CIlower", "mean", "CIupper"), ylabels = id)

```

#### Add accelerometer-measured MVPA

```{r bct-pa-motivation-ggm}

nItems_PA <- 20

bctdf_PA <- df %>% dplyr::select(id,
  intervention,
  group,
  school,
  girl,
  'MVPA' = mvpaAccelerometer_T1,
  'Autonomous' = PA_autonomous_T1,
  'Controlled' = PA_controlled_T1,
  'goal setting' = PA_agreementDependentBCT_01_T1,
  'own plan' = PA_agreementDependentBCT_02_T1,
  'plan by other' = PA_agreementDependentBCT_03_T1,
  'reminder of plan' = PA_agreementDependentBCT_04_T1,
  'subgoals' = PA_agreementDependentBCT_05_T1,
  'trying new PA' = PA_agreementDependentBCT_06_T1,
  'barrier identification' = PA_agreementDependentBCT_07_T1,
  'problem solving' = PA_agreementDependentBCT_08_T1,
  'PA identity reflection' = PA_agreementDependentBCT_09_T1,
  'aligning PA with life values' = PA_agreementDependentBCT_10_T1,
  'remind of PA benefits' = PA_frequencyDependentBCT_01_T1,
  'self-monitor (paper)' = PA_frequencyDependentBCT_02_T1,
  'self-monitor (app)' = PA_frequencyDependentBCT_03_T1,
#  'memory cues' = PA_frequencyDependentBCT_04_T1,
  'goal review' = PA_frequencyDependentBCT_05_T1,
  'personal relevance reflection' = PA_frequencyDependentBCT_06_T1,
  'environmental changes (home)' = PA_frequencyDependentBCT_07_T1,
  'social support' = PA_frequencyDependentBCT_08_T1,
  'failure contemplated' = PA_frequencyDependentBCT_09_T1) %>%
  rowwise() %>% 
  mutate( 
  #'has plan' = mean(c(`own plan`, `plan by other`), na.rm = TRUE),
  'self-monitor' = mean(c(`self-monitor (paper)`, `self-monitor (app)`), na.rm = TRUE)) %>%
  dplyr::select(-`self-monitor (paper)`, -`self-monitor (app)`) %>% 
  mutate_all(as.numeric)

# Network for all participants

S.total_PA <- bctdf_PA %>% dplyr::select(`MVPA`:ncol(bctdf_PA))
nwBCT_PA <- bootnet::estimateNetwork(S.total_PA, default="EBICglasso")

labs <- colnames(S.total_PA)

# Create means for filling nodes
piefill <- S.total_PA %>% 
  dplyr::select(-MVPA, -Autonomous, -Controlled) %>% 
  data.frame() %>% 
  summarise_all(funs(median(., na.rm = TRUE) / 6))   

piefill$MVPA <- median(S.total_PA$MVPA, na.rm = TRUE) / (60*24) 
piefill$Autonomous <- median(S.total_PA$Autonomous, na.rm = TRUE) / 5
piefill$Controlled <- median(S.total_PA$Controlled, na.rm = TRUE) / 5

piefill <- piefill %>% dplyr::select(MVPA, Autonomous, Controlled, everything())

# Plot network
plot(nwBCT_PA, layout = "spring", label.scale = FALSE, title = "GGM: Accelerometer-MVPA, BCTs & motivation (all items)", label.cex = 0.75,
     pie = piefill, 
     color = "skyblue",
     pieBorder = 1)

# Combine items further:
bctdf_PA2 <- bctdf_PA %>% rowwise %>% 
  mutate('goals and plans' = mean(c(`goal setting`, `own plan`), na.rm = TRUE)) %>% 
  mutate('barriers identified\nand planned for' = mean(c(`barrier identification`, `problem solving`), na.rm = TRUE)) %>% 
  dplyr::select(-`goal setting`, -`own plan`, -`barrier identification`, -`problem solving`) %>% 
  data.frame

S.total_PA2 <- bctdf_PA2 %>% dplyr::select(MVPA:ncol(bctdf_PA2))
nwBCT_PA2 <- bootnet::estimateNetwork(S.total_PA2, default="EBICglasso")

# Create means for filling nodes
piefill_PA2 <- S.total_PA2 %>% 
  dplyr::select(-MVPA, -Autonomous, -Controlled) %>%
  data.frame() %>% 
  summarise_all(funs(median(., na.rm = TRUE) / 6)) 

piefill_PA2$MVPA <- median(S.total_PA2$MVPA, na.rm = TRUE) / (60*24) 
piefill_PA2$Autonomous <- median(S.total_PA2$Autonomous, na.rm = TRUE) / 5
piefill_PA2$Controlled <- median(S.total_PA2$Controlled, na.rm = TRUE) / 5

piefill_PA2 <- piefill_PA2 %>% dplyr::select(MVPA, everything())


# Plot network
plot(nwBCT_PA2, layout = "spring", label.scale = FALSE, title = "GGM: Accelerometer-MVPA, BCTs & motivation (combined items)", label.cex = 0.75,
     pie = piefill_PA2, 
     color = "skyblue",
     pieBorder = 1)


```

#### Centrality and stability

```{r}
# BCTbootPA <- bootnet::bootnet(nwBCT_PA2, nBoots = 2500)
# save(BCTbootPA, file = "./Rdata_files/BCTbootPA.Rdata")

load("./Rdata_files/BCTbootPA.Rdata")

qgraph::centralityPlot(nwBCT_PA2)

plot(BCTbootPA, labels = FALSE, order = "sample")


```

```{r diamondEdges-PAmodel, eval = FALSE, include = FALSE}
# TODO? The edge order doesn't match and plot is hence wrong

autEdges <- summary(BCTbootPA, statistics = "edge", rank = TRUE) %>% 
  dplyr::arrange(mean) %>% 
  dplyr::filter(stringr::str_detect(node1, 'Autonomous') | stringr::str_detect(node2, 'Autonomous')) %>% # str_detect(id, 'Autonomous|Controlled') for both
  dplyr::filter(!(node2 == 'Controlled') & !(node1 == 'Controlled')) %>% 
  data.frame() %>% 
  dplyr::select(CIlower, mean, CIupper, node2, node1) %>% 
  dplyr::mutate(node2 = ifelse(node2 == "Autonomous", "MVPA", node2))

contEdges <- summary(BCTbootPA, statistics = "edge", rank = TRUE) %>% 
  dplyr::arrange(mean) %>% 
  dplyr::filter(stringr::str_detect(node1, 'Controlled') | stringr::str_detect(node2, 'Controlled')) %>% # str_detect(id, 'Autonomous|Controlled') for both
  dplyr::filter(!(node2 == 'Autonomous') & !(node1 == 'Autonomous')) %>% 
  data.frame() %>% 
  dplyr::select(CIlower, mean, CIupper, node2, node1) %>% 
  dplyr::mutate(node2 = ifelse(node2 == "Controlled", "MVPA", node2))

userfriendlyscience::diamondPlot(autEdges, 
            ciCols = c("CIlower", "mean", "CIupper"), 
            color = viridis::viridis(2, end = 0.8)[1], 
            alpha = 0.3, 
            yLabels = autEdges$node2, 
            fixedSize = 0.3, 
            xlab = NULL) +
  userfriendlyscience::diamondPlot(contEdges, 
              ciCols = c("CIlower", "mean", "CIupper"), 
              color = viridis::viridis(2, end = 0.8)[2], 
              alpha = 0.3, 
              yLabels = autEdges$node2, 
              fixedSize = 0.3, 
              xlab = NULL, 
              returnLayerOnly = TRUE) +
  geom_rect(aes(xmin=Inf, xmax=Inf, ymin=Inf, ymax=Inf, fill = "Controlled"), 
            colour=NA, alpha=0.05) + # Create invisible rectangle for legend
  geom_rect(aes(xmin=Inf, xmax=Inf, ymin=Inf, ymax=Inf, fill = "Autonomous"), 
            colour=NA, alpha=0.05) + # Create invisible rectangle for legend
  scale_fill_manual('Connected node',
                      values = viridis::viridis(2, end = 0.8)[1:2],  
                      guide = guide_legend(override.aes = list(alpha = 1))) +
  ggtitle("Relative strengths of edges containing autonomous \nor controlled motivation (model with MVPA & combined items)")

```


## Demonstrating the Ising network

... in PA, autonomous motivation, and top-5 BCTs

Variables are binarised:
* If one reports not using the BCT, they get a zero, otherwise a 1
* If one reports not having done no MVPA during the last week, they get a zero, otherwise a 1
* On the autonomous motivation sum score, if one reports lower agreement than 3 (indicating "sometimes true for me") on average, they get a zero, otherwise a 1

We include the top 5 BCTs according to their bivariate Spearman correlations with self-reported PA. Self-report instead of accelerometer due to higher sample size and accounting for e.g. gym.

1. I have tried out new ways for me to be physically active.
2. I have personally made a specific plan ("what, where, how") to implement my PA.
3. I have a PA plan, which has been made by someone else, e.g. my sports club (e.g. a workout schedule).
4. I have set PA goals for myself.
5. I have broken down larger PA goals to smaller subgoals.

When a person has tried out a new PA way to be physically active, they have almost (because question time scales don't overlap completely) by definition done MVPA lately. Therefore, we substitute this with:

6. I have compared my actualized PA with the PA goal I have set.

```{r ising-demo-pa-autmot-top5bcts}


top5Bcts_df <- df %>% dplyr::select(
  MVPA = padaysLastweek_T1,
  Autonomous = PA_autonomous_T1, 
  'goal review' = PA_frequencyDependentBCT_05_T1,
  'own plan' = PA_agreementDependentBCT_02_T1,
  'plan by other' = PA_agreementDependentBCT_03_T1,
  'goal setting' = PA_agreementDependentBCT_01_T1,
  'subgoals' = PA_agreementDependentBCT_05_T1) %>% 
 mutate(
  'MVPA' = ifelse(`MVPA` == 0, 0, 1),
  'Autonomous' = ifelse(`Autonomous` < 3, 0, 1),
  'goal review' = ifelse(`goal review` == 1, 0, 1),
  'own plan' = ifelse(`own plan` == 1, 0, 1),
  'plan by other' = ifelse(`plan by other` == 1, 0, 1),
  'goal setting' = ifelse(`goal setting` == 1, 0, 1),
  'subgoals' = ifelse(`subgoals` == 1, 0, 1))  

allMeans <- top5Bcts_df %>%
  summarise_all(funs(mean(., na.rm = TRUE))) 

network_all <- bootnet::estimateNetwork(top5Bcts_df, default="IsingFit")

graph_cor <- qgraph::qgraph(qgraph::cor_auto(top5Bcts_df), graph = "cor", layout="spring", cut=0, 
                  label.scale = FALSE, edge.labels = TRUE, labels = names(top5Bcts_df),
                  pie = allMeans, pieBorder = 1, title = "Bivariate correlations")
graph_Ising <- plot(network_all, layout="spring", cut=0, label.scale = FALSE,
                  pie = allMeans, pieBorder = 1, title = "Ising model")

# maxedge <- max(c(graph_Ising$graphAttributes$Graph$maximum, 
#                  graph_cor$graphAttributes$Graph$maximum))

L <- qgraph::averageLayout(graph_cor, graph_Ising)

layout(matrix(1:2, nrow = 1, byrow = TRUE))
graph_cor <- qgraph::qgraph(qgraph::cor_auto(top5Bcts_df), graph = "cor", layout=L, cut=0, 
                  label.scale = FALSE, edge.labels = TRUE, labels = names(top5Bcts_df), label.cex = 0.8,
                  pie = allMeans, pieBorder = 1, title = "Bivariate correlations")
graph_Ising <- plot(network_all, layout=L, cut=0, label.scale = FALSE,
                  pie = allMeans, pieBorder = 1, title = "Ising model", label.cex = 0.8)

qgraph::flow(graph_Ising, 
             "MVPA", 
             groups = c("A", "B", rep("C", 5)),
             legend = FALSE,
             title = "",
             vsize = 15,
             label.cex = 1.5,
             colors = viridis::viridis(3),
             label.color = c("white", rep("black", 6)))

```

Centrality and stability:

```{r top5Bcts-stability}
Ising_centralityPlot <- qgraph::centralityPlot(graph_Ising)

qgraph::centrality(graph_Ising)$InDegree
scale(qgraph::centrality(graph_Ising)$InDegree)
qgraph::centrality(graph_Ising)$Closeness
qgraph::centrality(graph_Ising)$Betweenness

cor(qgraph::centrality(graph_Ising)$InDegree, qgraph::centrality(graph_Ising)$Betweenness, 
    method = "spearman") 

# bootnet_stability_top5Bcts <- bootnet::bootnet(network_all, nBoots=1000)
# save(bootnet_stability_top5Bcts, file = "./Rdata_files/bootnet_stability_top5Bcts.Rdata")
load("./Rdata_files/bootnet_stability_top5Bcts.Rdata")

plot(bootnet_stability_top5Bcts, labels = TRUE, order = "sample") 
plot(bootnet_stability_top5Bcts, "edge", plot = "difference", onlyNonZero = TRUE, order = "sample")

# bootnet_centrality_stability_top5Bcts <- bootnet::bootnet(network_all, nBoots=1000,nCores=8, type="case")
# save(bootnet_centrality_stability_top5Bcts, file = "./Rdata_files/bootnet_centrality_stability_top5Bcts.Rdata")
load("./Rdata_files/bootnet_centrality_stability_top5Bcts.Rdata")

plot(bootnet_centrality_stability_top5Bcts)
plot(bootnet_centrality_stability_top5Bcts, perNode=T, "strength")

bootnet::corStability(bootnet_centrality_stability_top5Bcts) 

```

### Heterogeneity check

```{r top5Bcts-heterogeneity}

top5Bcts_tracks_df <- df %>% dplyr::select(
  track,
  PA = padaysLastweek_T1,
  Autonomous = PA_autonomous_T1, 
  'trying new PA' = PA_agreementDependentBCT_06_T1,
  'own plan' = PA_agreementDependentBCT_02_T1,
  'plan by other' = PA_agreementDependentBCT_03_T1,
  'goal setting' = PA_agreementDependentBCT_01_T1,
  'subgoals' = PA_agreementDependentBCT_05_T1) %>% 
 mutate(
  'PA' = ifelse(`PA` == 0, 0, 1),
  'Autonomous' = ifelse(`Autonomous` < 3, 0, 1),
  'trying new PA' = ifelse(`trying new PA` == 1, 0, 1),
  'own plan' = ifelse(`own plan` == 1, 0, 1),
  'plan by other' = ifelse(`plan by other` == 1, 0, 1),
  'goal setting' = ifelse(`goal setting` == 1, 0, 1),
  'subgoals' = ifelse(`subgoals` == 1, 0, 1))

heterogeneity_Nur <- top5Bcts_tracks_df %>% 
  dplyr::filter(track == "Nur") %>% 
  dplyr::select(-track) %>% 
  na.omit() 
NurMeans <- heterogeneity_Nur %>%
  summarise_all(funs(mean(., na.rm = TRUE))) 

heterogeneity_HRC <- top5Bcts_tracks_df %>%
  dplyr::filter(track == "HRC") %>% 
  dplyr::select(-track) %>% 
  na.omit()
HRCMeans <- heterogeneity_HRC %>%
  summarise_all(funs(mean(., na.rm = TRUE))) 

heterogeneity_BA <- top5Bcts_tracks_df %>% 
  dplyr::filter(track == "BA") %>% 
  dplyr::select(-track) %>% 
  na.omit()
BAMeans <- heterogeneity_BA %>%
  summarise_all(funs(mean(., na.rm = TRUE))) 

heterogeneity_IT <- top5Bcts_tracks_df %>% 
  dplyr::filter(track == "IT") %>% 
  dplyr::select(-track) %>% 
  na.omit() 
ITMeans <- heterogeneity_IT %>%
  summarise_all(funs(mean(., na.rm = TRUE))) 

network_Nur <- bootnet::estimateNetwork(heterogeneity_Nur, default="IsingFit")
network_HRC <- bootnet::estimateNetwork(heterogeneity_HRC, default="IsingFit")
network_BA <- bootnet::estimateNetwork(heterogeneity_BA, default="IsingFit")
network_IT <- bootnet::estimateNetwork(heterogeneity_IT, default="IsingFit")

graph_Nur <- plot(network_Nur, layout="spring", cut=0, label.scale = FALSE,
                  pie = NurMeans, pieBorder = 1, title = "Practical nurse")
graph_HRC <- plot(network_HRC, layout="spring", cut=0, label.scale = FALSE,
                  pie = HRCMeans, pieBorder = 1, title = "HRC")
graph_BA <- plot(network_BA, layout="spring", cut=0, label.scale = FALSE,
                  pie = BAMeans, pieBorder = 1, title = "BA")
graph_IT <- plot(network_IT, layout="spring", cut=0, label.scale = FALSE,
                  pie = ITMeans, pieBorder = 1, title = "IT")

maxedge <- max(c(graph_Nur$graphAttributes$Graph$maximum, 
                 graph_HRC$graphAttributes$Graph$maximum, 
                 graph_BA$graphAttributes$Graph$maximum, 
                 graph_IT$graphAttributes$Graph$maximum))

L <- qgraph::averageLayout(graph_Nur, graph_HRC, graph_BA, graph_IT)

layout(matrix(1:4, nrow = 2, byrow = TRUE))
graph_Nur <- plot(network_Nur, layout=L, cut=0, label.scale = FALSE, title = "Practical nurse", 
                  maximum = maxedge, pie = NurMeans, pieBorder = 1)
graph_HRC <- plot(network_HRC, layout=L, cut=0, label.scale = FALSE, title = "HRC",
                  maximum = maxedge, pie = HRCMeans, pieBorder = 1)
graph_BA <- plot(network_BA, layout=L, cut=0, label.scale = FALSE, title = "BA", 
                 maximum = maxedge, pie = BAMeans, pieBorder = 1)
graph_IT <- plot(network_IT, layout=L, cut=0, label.scale = FALSE, title = "IT",
                 maximum = maxedge, pie = ITMeans, pieBorder = 1)


# nct_results_top5Bcts <- NetworkComparisonTest::NCT(heterogeneity_Nur, heterogeneity_IT, it=1000, binary.data=FALSE, paired=FALSE, test.edges=TRUE,
# edges='all', progressbar=TRUE)
# 
# save(nct_results_top5Bcts, file = "./Rdata_files/nct_results_top5Bcts.Rdata")
# alternatively, load 
load("./Rdata_files/nct_results_top5Bcts.Rdata")

```

Results from the network comparison test between Nur and IT on "top-5" BCTs:

```{r top5bcts-nct-results, results = "asis"}

print("Similarity")
cat("Correlation between Nur and IT edge strengths:", cor(qgraph::centrality(network_Nur)$InDegree, qgraph::centrality(network_IT)$InDegree))

cat("Correlation between Nur and IT networks:", cor(network_Nur$graph[lower.tri(network_Nur$graph)], network_IT$graph[lower.tri(network_Nur$graph)], method="spearman"))

print("Difference")
cat("P-value for the test of identical network structure:", nct_results_top5Bcts$nwinv.pval)
cat("P-value for the test of identical connectivity in networks:", nct_results_top5Bcts$glstrinv.pval)
nct_results_top5Bcts$einv.pvals %>% 
  papaja::apa_table(caption = "p-values on difference test in edges between Nur and IT")

cat("Number of edges, which appear different (p<0.05):", sum(nct_results_top5Bcts$einv.pvals$"p-value" < 0.05))

```

<!-- # BCT-SDT Regression analyses -->

<!-- Here's the classical linear model. -->

```{r bct-sdt-regression, results = "asis", eval = FALSE, include = FALSE, echo = FALSE}

bctdf <- df %>% dplyr::select(id,
  intervention,
  group,
  school,
  girl,
  'Autonomous' = PA_autonomous_T1,
  'Controlled' = PA_controlled_T1,
  'Intrinsic' = PA_intrinsic_T1,
  'Identified' = PA_identified_T1,
  'Integrated' = PA_integrated_T1,
  'Introjected' = PA_introjected_T1,
  'Extrinsic' = PA_extrinsic_T1,
  'goal setting' = PA_agreementDependentBCT_01_T1,
  'own plan' = PA_agreementDependentBCT_02_T1,
  'plan by other' = PA_agreementDependentBCT_03_T1,
  'reminder of plan' = PA_agreementDependentBCT_04_T1,
  'subgoals' = PA_agreementDependentBCT_05_T1,
  'trying new PA' = PA_agreementDependentBCT_06_T1,
  'barrier identification' = PA_agreementDependentBCT_07_T1,
  'problem solving' = PA_agreementDependentBCT_08_T1,
  'PA identity reflection' = PA_agreementDependentBCT_09_T1,
  'aligning PA with life values' = PA_agreementDependentBCT_10_T1,
  'remind of PA benefits' = PA_frequencyDependentBCT_01_T1,
  'self-monitor (paper)' = PA_frequencyDependentBCT_02_T1,
  'self-monitor (app)' = PA_frequencyDependentBCT_03_T1,
#  'memory cues' = PA_frequencyDependentBCT_04_T1,
  'goal review' = PA_frequencyDependentBCT_05_T1,
  'personal relevance reflection' = PA_frequencyDependentBCT_06_T1,
  'environmental changes (home)' = PA_frequencyDependentBCT_07_T1,
  'social support' = PA_frequencyDependentBCT_08_T1,
  'failure contemplated' = PA_frequencyDependentBCT_09_T1) %>%
  rowwise() %>% 
  mutate( 
  #'has plan' = mean(c(`own plan`, `plan by other`), na.rm = TRUE),
  'self-monitor' = mean(c(`self-monitor (paper)`, `self-monitor (app)`), na.rm = TRUE)) %>%
  dplyr::select(-`self-monitor (paper)`, -`self-monitor (app)`) %>% 
  data.frame # %>% 
  # mutate_all(as.numeric)

outcomevars <- c('Autonomous', 
  'Controlled', 
  'Intrinsic',
  'Identified', 
  'Integrated', 
  'Introjected',
  'Extrinsic')

for (i in outcomevars) {
m <- lm(paste0(i, " ~ 
  'goal setting' +
  'own plan' +
  'plan by other' +
  'reminder of plan' +
  'subgoals' +
  'trying new PA' +
  'barrier identification' +
  'problem solving' +
  'PA identity reflection' +
  'aligning PA with life values' +
  'remind of PA benefits'"), 
  data = bctdf)

cat("\n\nEstimates for", i, "regulation", sep = " ")
summary(m) %>% broom::tidy() %>% dplyr::arrange(desc(estimate)) %>% papaja::apa_table() 
}


```

# PA determinants: unregularised correlations visualised

```{r pa-determinants-correlations-raw}
# Network without motivation variables
data <- df %>% dplyr::select('PA' = mvpaAccelerometer_T1, 'SB' = sitLieAccelerometer_T1,
'fat%' = fatpct_T1,'action planning' = PA_actionplan_T1, 'coping planning' = PA_copingplan_T1, 'frequency-related BCTs' = PA_frequencyDependentBCT_T1, 'agreement-related BCTs' = PA_agreementDependentBCT_T1, 'amotivation' = PA_amotivation_T1, 'autonomous motivation' = PA_autonomous_T1, 'controlled motivation' = PA_controlled_T1, 'descriptive norm' = PA_descriptiveNorm_T1, 'injunctive norm' = PA_injunctiveNorm_T1, 'intention' = PA_intention_T1, 'outcome expectations' = PA_outcomeExpectations_T1, 'self-efficacy / perceivedBehaviouralControl' = PA_selfEfficacyperceivedBehaviouralControl_T1, 'perceived opportunities' = PA_opportunities_T1) %>% 
  mutate_all(as.numeric)

names <- df %>% dplyr::select('PA' = mvpaAccelerometer_T1, 'SB' = sitLieAccelerometer_T1,
'fat%' = fatpct_T1,'action planning' = PA_actionplan_T1, 'coping planning' = PA_copingplan_T1, 'frequency-related BCTs' = PA_frequencyDependentBCT_T1, 'agreement-related BCTs' = PA_agreementDependentBCT_T1, 'amotivation' = PA_amotivation_T1, 'autonomous motivation' = PA_autonomous_T1, 'controlled motivation' = PA_controlled_T1, 'descriptive norm' = PA_descriptiveNorm_T1, 'injunctive norm' = PA_injunctiveNorm_T1, 'intention' = PA_intention_T1, 'outcome expectations' = PA_outcomeExpectations_T1, 'self-efficacy / perceivedBehaviouralControl' = PA_selfEfficacyperceivedBehaviouralControl_T1, 'perceived opportunities' = PA_opportunities_T1) %>% names

# Spinglass algorithm detects communities. Tutorial here: http://psych-networks.com/r-tutorial-identify-communities-items-networks/

cormatrix <- qgraph::cor_auto(data) 

piefill <- data %>%
  summarise_all(funs(mean(., na.rm = TRUE))) %>% 
  mutate_at(vars(PA, SB),
            funs(. / (24*60))) %>% # proportion of day used doing the behaviour
  mutate_at(vars(`action planning`, `coping planning`),
            funs(. / 4)) %>% 
  mutate_at(vars(6:ncol(data)),
            funs(. / 7)) %>% 
  mutate_at(vars(`fat%`),
            funs(. / 100))  

nodeColors <- c(rep(viridis::viridis(7, begin = 0.3, end = 1)[1], 2), # PA, SB
                rep(viridis::viridis(7, begin = 0.3, end = 1)[2], 1), # fat
                rep(viridis::viridis(7, begin = 0.3, end = 1)[3], 2), # Action, coping planning
                rep(viridis::viridis(7, begin = 0.3, end = 1)[4], 2), # 2x bcts
                rep(viridis::viridis(7, begin = 0.3, end = 1)[5], 3), # Motivations
                rep(viridis::viridis(7, begin = 0.3, end = 1)[6], 2), # norms
                rep(viridis::viridis(7, begin = 0.3, end = 1)[7], 1), # intention
                rep(viridis::viridis(7, begin = 0.3, end = 1)[6], 3)) # OE, SE/perceivedBehaviouralControl, Opportunities


qgraph::qgraph(qgraph::cor_auto(data), layout = "spring", labels = TRUE, 
       # groups = group.spinglass, 
     color=nodeColors,
     label.cex = 0.75,
     label.scale = TRUE,
     pie = piefill, 
     color = "skyblue",
     nodeNames = names,
     pieBorder = 1,
     legend.cex = 0.4,
     theme = "colorblind",
     edge.labels = TRUE,
     edge.label.cex = 0.75,
     minimum = 0.1,
     title = "Bivariate correlations of PA determinants (<0.1 not shown)")


```

<!-- Out of a hundred iterations, spinglass algorithm found `  table(matrix_spinglass)[[1]]` instances of ` table(matrix_spinglass)[1] %>% names` communities, `  table(matrix_spinglass)[[2]]` instances of `  table(matrix_spinglass)[2] %>% names` communities, and `  table(matrix_spinglass)[[3]]` instances of `  table(matrix_spinglass)[3] %>% names` communities. Thus, a random seed which found four communities was chosen.   -->

## Symptom network: all

```{r symptoms-all}

sympdf <- df %>% dplyr::select(id,
  intervention,
  group,
  school,
  girl,
  "Neck and shoulder pain" = symptom_neckShoulderPain_T1,
  "Lower back pain" = symptom_lowerBackPain_T1,
  "Stomach ache" = symptom_stomachAche_T1,
  "Tension or nervousness" = symptom_tensionNervousness_T1,
  "Irritability or anger bursts" = symptom_irritabilityAngerbursts_T1,
  "Difficulty with sleep" = symptom_sleepDifficulty_T1,
  "Headache" = symptom_headAche_T1,
  "Tiredness or faintness" = symptom_tirednessFaintness_T1,
  "Fat pct" = fatpct_T1,
  "PA" = mvpaAccelerometer_T1,
  "SB" = sitLieAccelerometer_T1
) %>% 
  mutate(
    'Neck and shoulder pain' = ifelse(`Neck and shoulder pain` == 1, 0, 1),
    'Lower back pain' = ifelse(`Lower back pain` == 1, 0, 1),
    'Stomach ache' = ifelse(`Stomach ache` == 1, 0, 1),
    'Tension or nervousness' = ifelse(`Tension or nervousness` == 1, 0, 1),
    'Irritability or anger bursts' = ifelse(`Irritability or anger bursts` == 1, 0, 1),
    'Difficulty with sleep' = ifelse(`Difficulty with sleep` == 1, 0, 1),
    'Headache' = ifelse(`Headache` == 1, 0, 1),
    'Tiredness or faintness' = ifelse(`Tiredness or faintness` == 1, 0, 1),
    'Fat pct' = `Fat pct` / 100) %>% 
  data.frame

S.all <- sympdf %>% dplyr::select(6:ncol(sympdf)) %>% na.omit(.) 

nwAll <- bootnet::estimateNetwork(S.all, default="mgm")

allmeans <- sympdf %>%  
  summarise_at(vars(6:16),
  funs(mean(., na.rm = TRUE))) %>%  
  mutate_at(vars(PA, SB),
            funs(. / (24*60)))  # proportion of day used doing the behaviour


plot(nwAll, label.scale = FALSE, title = "All", label.cex = 0.75, 
     pie = allmeans, 
     color = "skyblue",
     pieBorder = 1)


```


## Symptom network: boys and girls

```{r symptoms-boygirl}

sympdf <- df %>% dplyr::select(id,
  intervention,
  group,
  school,
  girl,
  "Neck and shoulder pain" = symptom_neckShoulderPain_T1,
  "Lower back pain" = symptom_lowerBackPain_T1,
  "Stomach ache" = symptom_stomachAche_T1,
  "Tension or nervousness" = symptom_tensionNervousness_T1,
  "Irritability or anger bursts" = symptom_irritabilityAngerbursts_T1,
  "Difficulty with sleep" = symptom_sleepDifficulty_T1,
  "Headache" = symptom_headAche_T1,
  "Tiredness or faintness" = symptom_tirednessFaintness_T1,
  "Fat pct" = fatpct_T1,
  "PA" = mvpaAccelerometer_T1,
  "SB" = sitLieAccelerometer_T1
) %>% 
  mutate(
    'Neck and shoulder pain' = ifelse(`Neck and shoulder pain` == 1, 0, 1),
    'Lower back pain' = ifelse(`Lower back pain` == 1, 0, 1),
    'Stomach ache' = ifelse(`Stomach ache` == 1, 0, 1),
    'Tension or nervousness' = ifelse(`Tension or nervousness` == 1, 0, 1),
    'Irritability or anger bursts' = ifelse(`Irritability or anger bursts` == 1, 0, 1),
    'Difficulty with sleep' = ifelse(`Difficulty with sleep` == 1, 0, 1),
    'Headache' = ifelse(`Headache` == 1, 0, 1),
    'Tiredness or faintness' = ifelse(`Tiredness or faintness` == 1, 0, 1),
    'Fat pct' = `Fat pct` / 100)

S.boys <- sympdf %>% filter(girl == "boy") %>% dplyr::select("Neck and shoulder pain":ncol(sympdf)) %>% na.omit(.) 
S.girls <- sympdf %>% filter(girl == "girl") %>% dplyr::select("Neck and shoulder pain":ncol(sympdf)) %>% na.omit(.)
nwBoys <- bootnet::estimateNetwork(S.boys, default="mgm")
nwGirls <- bootnet::estimateNetwork(S.girls, default="mgm")

girlmeans <- sympdf %>% group_by(girl) %>% 
  summarise_at(vars("Neck and shoulder pain":"SB"),
  funs(mean(., na.rm = TRUE))) %>% 
  filter(girl == "girl") %>% 
  mutate_at(vars(PA, SB),
            funs(. / (24*60))) %>% # proportion of day used doing the behaviour
  dplyr::select(-(girl))

boymeans <- sympdf %>% group_by(girl) %>% 
  summarise_at(vars("Neck and shoulder pain":"SB"),
  funs(mean(., na.rm = TRUE))) %>% 
  filter(girl == "boy") %>% 
  mutate_at(vars(PA, SB),
            funs(. / (24*60))) %>% # proportion of day used doing the behaviour
  dplyr::select(-(girl))


layout(t(1:2))
plot(nwGirls, label.scale = FALSE, title = "Girls", label.cex = 0.75,
     pie = girlmeans, 
     color = "skyblue",
     pieBorder = 1)

plot(nwBoys, label.scale = FALSE, title = "Boys", label.cex = 0.75, 
     pie = boymeans, 
     color = "skyblue",
     pieBorder = 1)

```

## symptom network: educational tracks

```{r, include = FALSE, eval = FALSE}
library(bootnet)
library(qgraph)
library(tidyverse)

sympdf <- df %>% dplyr::select(id,
  intervention,
  track,
  school,
  girl,
  "Neck and shoulder pain" = symptom_neckShoulderPain_T1,
  "Lower back pain" = symptom_lowerBackPain_T1,
  "Stomach ache" = symptom_stomachAche_T1,
  "Tension or nervousness" = symptom_tensionNervousness_T1,
  "Irritability or anger bursts" = symptom_irritabilityAngerbursts_T1,
  "Difficulty with sleep" = symptom_sleepDifficulty_T1,
  "Headache" = symptom_headAche_T1,
  "Tiredness or faintness" = symptom_tirednessFaintness_T1,
  "Fat pct" = fatpct_T1,
  "PA" = mvpaAccelerometer_T1,
  "SB" = sitLieAccelerometer_T1
) %>% 
  mutate(
    'Neck and shoulder pain' = ifelse(`Neck and shoulder pain` == 1, 0, 1),
    'Lower back pain' = ifelse(`Lower back pain` == 1, 0, 1),
    'Stomach ache' = ifelse(`Stomach ache` == 1, 0, 1),
    'Tension or nervousness' = ifelse(`Tension or nervousness` == 1, 0, 1),
    'Irritability or anger bursts' = ifelse(`Irritability or anger bursts` == 1, 0, 1),
    'Difficulty with sleep' = ifelse(`Difficulty with sleep` == 1, 0, 1),
    'Headache' = ifelse(`Headache` == 1, 0, 1),
    'Tiredness or faintness' = ifelse(`Tiredness or faintness` == 1, 0, 1),
    'Fat pct' = `Fat pct` / 100) %>% 
  data.frame

# S.other <- sympdf %>% filter(track == "Other") %>% dplyr::select(6:ncol(sympdf)) %>% na.omit(.)
# S.it <- sympdf %>% filter(track == "Business IT") %>% dplyr::select(6:ncol(sympdf))
# S.admin <- sympdf %>% filter(track == "Business Admin") %>% dplyr::select(6:ncol(sympdf))
# S.hrc <- sympdf %>% filter(track == "HRC") %>% dplyr::select(6:ncol(sympdf))
# S.nursing <- sympdf %>% filter(track == "Nursing") %>% dplyr::select(6:ncol(sympdf))

# S.other <- sympdf %>% filter(track == 1) %>% dplyr::select(6:ncol(sympdf))
S.it <- sympdf %>% filter(track == 2) %>% dplyr::select(6:ncol(sympdf))
S.admin <- sympdf %>% filter(track == 3) %>% dplyr::select(6:ncol(sympdf))
S.hrc <- sympdf %>% filter(track == 4) %>% dplyr::select(6:ncol(sympdf))
S.nursing <- sympdf %>% filter(track == 5) %>% dplyr::select(6:ncol(sympdf))

# nwOther <- bootnet::estimateNetwork(S.other, default="mgm")
nwIt <- bootnet::estimateNetwork(S.it, default="mgm")
nwAdmin <- bootnet::estimateNetwork(S.admin, default="mgm")
nwHrc <- bootnet::estimateNetwork(S.hrc, default="mgm")
nwNursing <- bootnet::estimateNetwork(S.nursing, default="mgm")

# othermeans <- sympdf %>% group_by(track) %>% 
#   summarise_at(vars(5:15),
#   funs(mean(., na.rm = TRUE))) %>% 
#   filter(track == "Other") %>% 
#   mutate_at(vars(PA, SB),
#             funs(. / (24*60))) %>% # proportion of day used doing the behaviour
#   dplyr::select(-1)

# itmeans <- sympdf %>% group_by(track) %>% 
#   summarise_at(vars(5:15),
#   funs(mean(., na.rm = TRUE))) %>% 
#   filter(track == "Business IT") %>% 
#   mutate_at(vars(PA, SB),
#             funs(. / (24*60))) %>% # proportion of day used doing the behaviour
#   dplyr::select(-1)

itmeans <- sympdf %>% group_by(track) %>% 
  summarise_at(vars(5:15),
  funs(mean(., na.rm = TRUE))) %>% 
  filter(track == 2) %>% 
  mutate_at(vars(PA, SB),
            funs(. / (24*60))) %>% # proportion of day used doing the behaviour
  dplyr::select(-1)

# adminmeans <- sympdf %>% group_by(track) %>% 
#   summarise_at(vars(5:15),
#   funs(mean(., na.rm = TRUE))) %>% 
#   filter(track == "Business Admin") %>% 
#   mutate_at(vars(PA, SB),
#             funs(. / (24*60))) %>% # proportion of day used doing the behaviour
#   dplyr::select(-1)

adminmeans <- sympdf %>% group_by(track) %>% 
  summarise_at(vars(5:15),
  funs(mean(., na.rm = TRUE))) %>% 
  filter(track == 3) %>% 
  mutate_at(vars(PA, SB),
            funs(. / (24*60))) %>% # proportion of day used doing the behaviour
  dplyr::select(-1)

# hrcmeans <- sympdf %>% group_by(track) %>% 
#   summarise_at(vars(5:15),
#   funs(mean(., na.rm = TRUE))) %>% 
#   filter(track == "HRC") %>% 
#   mutate_at(vars(PA, SB),
#             funs(. / (24*60))) %>% # proportion of day used doing the behaviour
#   dplyr::select(-1)

hrcmeans <- sympdf %>% group_by(track) %>% 
  summarise_at(vars(5:15),
  funs(mean(., na.rm = TRUE))) %>% 
  filter(track == 4) %>% 
  mutate_at(vars(PA, SB),
            funs(. / (24*60))) %>% # proportion of day used doing the behaviour
  dplyr::select(-1)

# nursingmeans <- sympdf %>% group_by(track) %>% 
#   summarise_at(vars(5:15),
#   funs(mean(., na.rm = TRUE))) %>% 
#   filter(track == "Nursing") %>% 
#   mutate_at(vars(PA, SB),
#             funs(. / (24*60))) %>% # proportion of day used doing the behaviour
#   dplyr::select(-1)

nursingmeans <- sympdf %>% group_by(track) %>% 
  summarise_at(vars(5:15),
  funs(mean(., na.rm = TRUE))) %>% 
  filter(track == 5) %>% 
  mutate_at(vars(PA, SB),
            funs(. / (24*60))) %>% # proportion of day used doing the behaviour
  dplyr::select(-1)

averagelayout <- qgraph::averageLayout(nwIt, nwAdmin, nwHrc, nwNursing)
# plot(nwOther, label.scale = FALSE, title = "Girls", label.cex = 0.75,
#      pie = othermeans, 
#      color = "skyblue",
#      pieBorder = 1)

layout(t(1:4))
plot(nwIt, label.scale = FALSE, title = "Business IT", layout = averagelayout, label.cex = 0.75, 
     pie = itmeans, 
     color = "skyblue",
     pieBorder = 1)

plot(nwAdmin, label.scale = FALSE, title = "Business admin", layout = averagelayout, label.cex = 0.75, 
     pie = adminmeans, 
     color = "skyblue",
     pieBorder = 1)

plot(nwHrc, label.scale = FALSE, title = "Hotel, restaurant and catering", layout = averagelayout, label.cex = 0.75, 
     pie = hrcmeans, 
     color = "skyblue",
     pieBorder = 1)

plot(nwNursing, label.scale = FALSE, title = "Nursing", layout = averagelayout, label.cex = 0.75, 
     pie = nursingmeans, 
     color = "skyblue",
     pieBorder = 1)




```


```{r, include = FALSE, eval = FALSE}

colfill <- c(1,2,3,4,5)

# Create data frame
densplot <- d
levels(densplot$intervention) <- list("Intervention" = "1", "Control" = "0")
levels(densplot$girl) <- list("Girl" = "1", "Boy" = "0")

# This gives side-by-side plots
layout(t(1:2), 1)

# Intervention vs. control
# Choose only the variables needed and drop NA
dens <- densplot %>% dplyr::select(fatpct_T1, intervention) %>% 
  filter(complete.cases(.))

# Set random number generator for reproducibility of bootstrap test of equal densities
set.seed(10)

# Make plot
sm.fatpct_T1_1 <- sm.density.compare2(as.numeric(dens$fatpct_T1), as.factor(dens$intervention), xlab="Percentage", col=colfill, lty=c(1,2), bandcol='LightGray', model="equal", lwd=(c(2,2)))
legend("topright", levels(dens$intervention), fill=c(1, 2))

# Girls vs. boys
# Choose only the variables needed and drop NA
dens <- densplot %>% dplyr::select(fatpct_T1, girl) %>% 
  filter(complete.cases(.))

# Set random number generator for reproducibility of bootstrap test of equal densities
set.seed(10)

# Make plot
sm.fatpct_T1_2 <- sm.density.compare2(as.numeric(dens$fatpct_T1), as.factor(dens$girl), xlab="Percentage", col=colfill, lty=c(1,2), bandcol='LightGray', model="equal", lwd=(c(2,2)))
legend("topright", levels(dens$girl), fill=c(1, 2))

sm.fatpct_T1_2 <- sm.density.compare2(as.numeric(dens$fatpct_T1), as.factor(dens$girl), xlab="Percentage", col=colfill, lty=c(1,2), bandcol='LightGray', model="equal", lwd=(c(2,2)))
legend("topright", levels(dens$girl), fill=c(1, 2))
```



# PA determinant network

```{r determinants}

data <- df %>% 
  dplyr::select(
    "MVPA accelerometer" = mvpaAccelerometer_T1, 
    "planning" = PA_actCop_T1, 
    "BCT" = PA_frequencyDependentBCT_T1, 
    "amotivation" = PA_amotivation_T1, 
    "autonomous" = PA_autonomous_T1, 
    "controlled" = PA_controlled_T1, 
    "descriptive norm" = PA_descriptiveNorm_T1, 
    "fat pct" = fatpct_T1, 
    "injunctive norm" = PA_injunctiveNorm_T1, 
    "intention" = PA_intention_T1, 
    "outcome expectations" = PA_outcomeExpectations_T1, 
    "opportunities" = PA_opportunities_T1, 
    "self-efficacy perceivedBehaviouralControl" = PA_selfEfficacyperceivedBehaviouralControl_T1) %>% 
  mutate_all(funs(as.numeric(.))) 

covMatrix <- data %>% cov(use = "pairwise.complete.obs")

# Transform the matrix so, that lower diagonal of the matrix shows partial correlations,
# while the upper one shows bivariate correlations.
matrix_corLower_parcorUpper <- covMatrix %>% ggm::correlations()

# Show the matrix
matrix_corLower_parcorUpper %>% papaja::apa_table(caption = "Correlation matrix of hypothesised determinants. Lower diagonal shows bivariate correlations, upper diagonal shows partial correlations")

# Plot the matrix as a correlogram
matrix_corLower_parcorUpper %>% corrgram::corrgram(
  type = "cor",
  lower.panel = corrgram::panel.pie,
  upper.panel = corrgram::panel.pie,
  main = "Bivariate (upper diagonal) and partial (lower diagonal)\ncorrelations of PA determinants")

```

## ggm estimation

```{r determinants-ggm}

# Estimate a network

determinants_ggm_network <- bootnet::estimateNetwork(data, default="EBICglasso")

bootnetgraph <- plot(determinants_ggm_network, edge.labels = TRUE, labels = names(data), label.scale = FALSE,
       title = "partial correlation network, with LASSO regularisation and EBIC model selection")

corgraph <- qgraph::qgraph(qgraph::cor_auto(data), graph = "cor",
       labels = names(data),
       label.scale = FALSE,
       edge.labels = TRUE, 
       title = "bivariate correlation network")

pcorgraph <- qgraph::qgraph(qgraph::cor_auto(data), graph = "pcor",
       labels = names(data),
       label.scale = FALSE,
       edge.labels = TRUE, 
       title = "partial correlation network")

# Average the layout and plot all according to that
avlayout <- qgraph::averageLayout(bootnetgraph, corgraph, pcorgraph)

corgraph <- qgraph::qgraph(qgraph::cor_auto(data), graph = "cor",
       labels = names(data),
       edge.labels = TRUE, 
       layout = avlayout, 
       title = "bivariate correlation network",
       theme = "colorblind",
       maximum = max(c(bootnetgraph$graph$Graph$maximum,
                     pcorgraph$graph$Graph$maximum, 
                     corgraph$graph$Graph$maximum)),
       label.scale = FALSE)

# To help with visual comparison, that last argument takes the maximum edge of the three 
# graphs and places that as the benchmark for the thickest line in all plots.

pcorgraph <- qgraph::qgraph(qgraph::cor_auto(data), graph = "pcor",
       labels = names(data),
       edge.labels = TRUE, 
       layout = avlayout,
       title = "partial correlation network",
       theme = "colorblind",
       maximum = max(c(bootnetgraph$graph$Graph$maximum,
                     pcorgraph$graph$Graph$maximum, 
                     corgraph$graph$Graph$maximum)),
       label.scale = FALSE)



bootnetgraph <- plot(determinants_ggm_network, 
                     edge.labels = TRUE, 
                     layout = avlayout, 
                     title = "partial correlation network, with LASSO regularisation and EBIC model selection",
       maximum = max(c(bootnetgraph$graph$Graph$maximum,
                     pcorgraph$graph$Graph$maximum, 
                     corgraph$graph$Graph$maximum)),
       label.scale = FALSE)
```

A dressed-up version of the last graph. Pies indicate mean as a proportion of the maximum observed value in that variable in question. 

```{r determinants-ggm-2}

data <- df %>% 
  dplyr::select(
    "MVPA accelerometer" = mvpaAccelerometer_T1, 
    "planning" = PA_actCop_T1, 
    "BCT" = PA_frequencyDependentBCT_T1, 
    "amotivation" = PA_amotivation_T1, 
    "autonomous" = PA_autonomous_T1, 
    "controlled" = PA_controlled_T1, 
    "descriptive norm" = PA_descriptiveNorm_T1, 
    "fat pct" = fatpct_T1, 
    "injunctive norm" = PA_injunctiveNorm_T1, 
    "intention" = PA_intention_T1, 
    "outcome expectations" = PA_outcomeExpectations_T1, 
    "opportunities" = PA_opportunities_T1, 
    "self-efficacy perceivedBehaviouralControl" = PA_selfEfficacyperceivedBehaviouralControl_T1) %>% 
  mutate_all(funs(as.numeric(.))) 

piefill_determinantggm2 <- data %>% mutate_all(funs(mean(., na.rm = TRUE) / max(., na.rm = TRUE)))
piefill_determinantggm2 <- piefill_determinantggm2[1, ]

itemGroups <- c("Objective", "Determinants", "BCTs",
                rep("Motivation", 3),
                "Determinants", "Objective", 
                rep("Determinants", 5))

determinantgraph <- plot(
  determinants_ggm_network, 
  edge.labels = FALSE, 
  layout = "spring",
  label.scale = FALSE,
  groups = itemGroups,
  pie = piefill_determinantggm2,
  cut = 0.1,
  pieBorder = 1,
  legend = FALSE,
  color = viridis::viridis(5, begin = 0.5, option = "D"))


```

### Centrality and stability

```{r determinants-stability}

determinants_centralityPlot <- qgraph::centralityPlot(bootnetgraph)

qgraph::centralityPlot(bootnetgraph, 
               include = c("Strength", "ExpectedInfluence"),
               orderBy = "ExpectedInfluence")

qgraph::centrality(bootnetgraph)$InDegree
scale(qgraph::centrality(bootnetgraph)$InDegree)
qgraph::centrality(bootnetgraph)$Closeness
qgraph::centrality(bootnetgraph)$Betweenness

cor(qgraph::centrality(bootnetgraph)$InDegree, qgraph::centrality(bootnetgraph)$Betweenness, 
    method = "spearman") 

# bootnet_stability_determinants <- bootnet::bootnet(determinants_bootnet, nBoots=1000)
# save(bootnet_stability_determinants, file = "./Rdata_files/bootnet_stability_determinants.Rdata")
load("./Rdata_files/bootnet_stability_determinants.Rdata")

plot(bootnet_stability_determinants, labels = TRUE, order = "sample") 
plot(bootnet_stability_determinants, "edge", plot = "difference", onlyNonZero = TRUE, order = "sample")

# bootnet_centrality_stability_determinants <- bootnet::bootnet(determinants_bootnet, nBoots=1000,nCores=8, type="case")
# save(bootnet_centrality_stability_determinants, file = "./Rdata_files/bootnet_centrality_stability_determinants.Rdata")
load("./Rdata_files/bootnet_centrality_stability_determinants.Rdata")

plot(bootnet_centrality_stability_determinants)
plot(bootnet_centrality_stability_determinants, perNode=T, "strength")

bootnet::corStability(bootnet_centrality_stability_determinants)
```

<!-- ### PA network without SDT motivations -->

```{r, include = FALSE, eval = FALSE}
# Network without motivation variables
data <- df %>% dplyr::select(PA = mvpaAccelerometer_T1, actCop = PA_actcop_T1, BCT = PA_frequencyDependentBCT_T1, amot = PA_amotivation_T1, auton = PA_autonomous_T1, cont = PA_controlled_T1, descriptiveNorm = PA_descriptiveNorm_T1, fatpct = fatpct_T1, injunctiveNorm = PA_injunctiveNorm_T1, intent = PA_intention_T1, outcomeExpectations = PA_outcomeExpectations_T1, opp = PA_opportunities_T1, seperceivedBehaviouralControl = PA_selfEfficacyperceivedBehaviouralControl_T1) %>% data.frame() %>% 
  dplyr::select(-auton, -cont, -amot)

# Spinglass algorithm detects communities. Tutorial here: http://psych-networks.com/r-tutorial-identify-communities-items-networks/

cormatrix <- qgraph::cor_auto(data)

graph1<-qgraph(cormatrix, graph="glasso", layout="spring", sampleSize = nrow(data),
              vsize=7, cut=0, maximum=.45, border.width=1.5)

g = as.igraph(graph1, attributes=TRUE)

sgc <- spinglass.community(g)

sgc$membership

# Without SDT motivations
group.spinglass<- list(c(1, 2, 3, 7), 
                       c(4, 6), 
                       c(5), 
                       c(8, 9, 10))

set.seed(2)

network1 <- bootnet::estimateNetwork(data, default="EBICglasso")

plot(network1, layout = "spring", labels = TRUE, groups = group.spinglass, color=c("olivedrab2", "orange", "mediumpurple1", "lightblue"))

```

<!-- ### PA network without BCTs and SDT -->

```{r, include = FALSE, eval = FALSE}
# Network without motivation variables
data <- df %>% dplyr::select(PA = mvpaAccelerometer_T1, 'action and coping planning' = PA_actcop_T1, 'Frequency-related BCTs' = PA_frequencyDependentBCT_T1, 'amotivation' = PA_amotivation_T1, 'autonomous motivation' = PA_autonomous_T1, 'controlled motivation' = PA_controlled_T1, 'descriptive norm' = PA_descriptiveNorm_T1, 'injunctive norm' = PA_injunctiveNorm_T1, "fat pct" = fatpct_T1, 'intention' = PA_intention_T1, 'outcome expectations' = PA_outcomeExpectations_T1, 'Self-efficacy / perceivedBehaviouralControl' = PA_selfEfficacyperceivedBehaviouralControl_T1, 'perceived opportunities' = PA_opportunities_T1) %>% 
            dplyr::select(-`autonomous motivation`, -`controlled motivation`, -`amotivation`, -`Frequency-related BCTs`) %>% 
  data.frame

# Spinglass algorithm detects communities. Tutorial here: http://psych-networks.com/r-tutorial-identify-communities-items-networks/

cormatrix <- qgraph::cor_auto(data)

graph1 <- qgraph(cormatrix, graph="glasso", layout="spring", sampleSize = nrow(data),
              vsize=7, cut=0, maximum=.45, border.width=1.5)

g = as.igraph(graph1, attributes=TRUE)

set.seed(4)

sgc <- spinglass.community(g)

sgc$membership

# Without SDT motivations

group.spinglass<- list(c(1, 2, 6), 
                       c(3, 4), 
                       c(5),
                       c(7, 8, 9))

network1 <- bootnet::estimateNetwork(data, default="EBICglasso")

piefill <- data %>%
  summarise_all(funs(mean(., na.rm = TRUE))) %>% 
  mutate_at(vars(PA),
            funs(. / (24*60))) %>% # proportion of day used doing the behaviour
  mutate_at(vars(action.and.coping.planning),
            funs(. / 4)) %>% 
  mutate_at(vars(3, 4, 6, 7, 8, 9),
            funs(. / 7)) %>% 
  mutate_at(vars(5),
            funs(. / 100))  

plot(network1, layout = "spring", labels = TRUE, groups = group.spinglass, color=c("olivedrab2", "orange", "mediumpurple1", "lightblue"),
     label.cex = 0.75,
     label.scale = FALSE,
     pie = piefill, 
     color = "skyblue",
     pieBorder = 1)


plot(nwBoys, label.scale = FALSE, title = "Boys", label.cex = 0.75, 
     pie = boymeans, 
     color = "skyblue",
     pieBorder = 1)
```

<!-- ### PA network without BCTs and SDT, intention, MVPA, fat% -->

```{r, include = FALSE, eval = FALSE}
# Network without motivation variables
data <- df %>% dplyr::select(PA = mvpaAccelerometer_T1, 'action and coping planning' = PA_actcop_T1, 'Frequency-related BCTs' = PA_frequencyDependentBCT_T1, 'amotivation' = PA_amotivation_T1, 'autonomous motivation' = PA_autonomous_T1, 'controlled motivation' = PA_controlled_T1, 'descriptive norm' = PA_descriptiveNorm_T1, 'injunctive norm' = PA_injunctiveNorm_T1, "fat pct" = fatpct_T1, 'intention' = PA_intention_T1, 'outcome expectations' = PA_outcomeExpectations_T1, 'Self-efficacy / perceivedBehaviouralControl' = PA_selfEfficacyperceivedBehaviouralControl_T1, 'perceived opportunities' = PA_opportunities_T1) %>% 
            dplyr::select(-`autonomous motivation`, -`controlled motivation`, -`amotivation`, -`Frequency-related BCTs`, -PA, -`intention`, -`fat pct`) %>% 
  data.frame

# Spinglass algorithm detects communities. Tutorial here: http://psych-networks.com/r-tutorial-identify-communities-items-networks/

cormatrix <- qgraph::cor_auto(data)

graph1 <- qgraph(cormatrix, graph="glasso", layout="spring", sampleSize = nrow(data),
              vsize=7, cut=0, maximum=.45, border.width=1.5)

g = as.igraph(graph1, attributes=TRUE)

set.seed(1)

sgc <- spinglass.community(g)

sgc$membership

group.spinglass<- list(c(1, 4:6), 
                       c(2, 3))

# Estimate and plot graph


network1 <- bootnet::estimateNetwork(data, default="EBICglasso")

piefill <- data %>%
  summarise_all(funs(mean(., na.rm = TRUE))) %>%
  mutate_at(vars(action.and.coping.planning),
            funs(. / 4)) %>% 
  mutate_at(vars(2:6),
            funs(. / 7))

plot(network1, layout = "spring", labels = TRUE, groups = group.spinglass, color=c("olivedrab2", "orange", "mediumpurple1", "lightblue"),
     label.cex = 0.75,
     label.scale = FALSE,
     pie = piefill, 
     color = "skyblue",
     pieBorder = 1)


```

<!-- ## Robustness test  -->

```{r, include = FALSE, eval = FALSE}

Network1 <- bootnet::estimateNetwork(data1, default = "EBICglasso")
plot(Network1, layout = "spring", labels = TRUE)

qgraph::centralityPlot(Network1)

boot1 <- bootnet::bootnet(Network1, nBoots = 2500, nCores = 2)

plot(boot1, labels = TRUE, order = "sample")

Network2 <- bootnet::estimateNetwork(data1, default = "pcor")
plot(Network2, layout = "spring", labels = TRUE)

boot2 <- bootnet::bootnet(Network2, nBoots = 2500, nCores = 2)

qgraph::centralityPlot(Network)
qgraph::centralityPlot(Network2)
```

<!-- ## Centrality stability -->

```{r, eval = FALSE}
boot2 <- bootnet::bootnet(Network1, nBoots = 2500, type = "case", nCores = 2)
bootnet::corStability(boot2)

plot(boot2)

differenceTest(boot1, "auton", "intent",  measure = c("strength", "closeness", "betweenness"))

plot(boot1, "edge", plot = "difference", onlyNonZero = TRUE, order = "sample")

plot(boot1, "strength")
plot(boot1, "betweenness")
plot(boot1, "closeness")
```

<!-- ## Network comparison test: girls and boys -->

```{r, include = FALSE, eval = FALSE}

# here goes your data; call it "data"
data <- df %>% dplyr::select(paT1, girl, actcop_T1, frequencyDependentBCT_T1, amotivation_T1, autonomous_T1, controlled_T1, descriptiveNorm_T1, fatpct_T1, injunctiveNorm_T1, intention_T1, outcomeExpectations_T1, opportunities_T1, seperceivedBehaviouralControl_T1) 

### Split data into girls and boys
data1 <- data %>% filter(girl == "girl") %>% dplyr::select(-girl) %>% as.data.frame

data2 <- data %>% filter(girl == "boy") %>% dplyr::select(-girl) %>% as.data.frame

# ---------------------------------------------------------------------------------------
# ---------- 3. NCT ------------------------------------------------------------------
# ---------------------------------------------------------------------------------------


### estimate networks and compare visually; use averageLayout function, then plot via layout(t(1:2))
network1 <- bootnet::estimateNetwork(data1, default="EBICglasso")
network2 <- bootnet::estimateNetwork(data2, default="EBICglasso")

bladibla <- qgraph::averageLayout(network1$graph, network2$graph)

layout(t(1:2))
graph1 <- plot(network1, layout=bladibla, cut=0)
graph2 <- plot(network2, layout=bladibla, cut=0)

### run NCT 

nct_results <- NetworkComparisonTest::NCT(data1, data2, it=1000, binary.data=FALSE, paired=TRUE, test.edges=TRUE, edges='all', progressbar=TRUE)

nct_results$nwinv.pval  # p value of network structure diff test
nct_results$glstrinv.pval  # p value of global connectivity diff test
nct_results$einv.pvals     #p values testing diffs for all individual edges
sum(nct_results$einv.pvals$"p-value" < 0.05)  # how many edges are different

```

<!-- ## Robustness test  -->

```{r, include = FALSE, eval = FALSE}
data <- data %>% dplyr::select(BCT = agreementDependentBCT_T1,
    AUT = autonomous_T1,
    Intn = intention_T1,
    perceivedBehaviouralControl = perceivedBehaviouralControl_T1,
    outcomeExpectations = outcomeExpectations_T1,
    descriptiveNorm = norm_T1)

Network <- bootnet::estimateNetwork(data, default = "EBICglasso")

boot1 <- bootnet::bootnet(Network, nBoots = 2500, nCores = 2)

plot(boot1, labels = TRUE, order = "sample")

plot(Network, layout = "spring", labels = TRUE)

Network2 <- bootnet::estimateNetwork(data, default = "pcor")
plot(Network2, layout = "spring", labels = TRUE)

boot1 <- bootnet::bootnet(Network2, nBoots = 2500, nCores = 2)

qgraph::centralityPlot(Network)
qgraph::centralityPlot(Network2)
```

<!-- # Centrality stability -->

```{r, include = FALSE, eval = FALSE}
boot2 <- bootnet::bootnet(Network, nBoots = 2500, type = "case", nCores = 2)
bootnet::corStability(boot2)

plot(boot2)

differenceTest(boot1, "AUT", "Intn",  measure = c("strength", "closeness", "betweenness"))

plot(boot1, "edge", plot = "difference", onlyNonZero = TRUE, order = "sample")

plot(boot1, "strength")
plot(boot1, "betweenness")
plot(boot1, "closeness")
```

# PA motivation examined

## Motivation correlation matrix

```{r motivation-corrmatrix, results = "asis"}
regulations.df <- df %>% dplyr::select(
  mvpaAccelerometer_T1,
  padaysLastweek_T1,
  PA_amotivation_02_T1,
  PA_amotivation_01_T1,
  PA_amotivation_03_T1,
  PA_amotivation_04_T1,
  PA_extrinsic_01_T1,
  PA_extrinsic_02_T1,
  PA_extrinsic_03_T1,
  PA_introjected_01_T1,
  PA_introjected_02_T1,
  PA_identified_01_T1,
  PA_identified_02_T1,
  PA_identified_03_T1,
  PA_integrated_01_T1, 
  PA_integrated_02_T1,
  PA_integrated_03_T1, 
  PA_intrinsic_01_T1,
  PA_intrinsic_02_T1,
  PA_intrinsic_03_T1,
  Autonomous_sumscore = PA_autonomous_T1,
  Controlled_sumscore = PA_controlled_T1,
  weartimeAccelerometer_T1) %>% 
  mutate(mvpaAccelerometer_percentageWeartime_T1 = mvpaAccelerometer_T1 / weartimeAccelerometer_T1)

# Create a covariance matrix of the data
covMatrix <- regulations.df %>% cov(use = "pairwise.complete.obs")

# Transform the matrix so, that lower diagonal of the matrix shows partial correlations,
# while the upper one shows bivariate correlations.
matrix_corLower_parcorUpper <- covMatrix %>% ggm::correlations()

# Show the matrix
matrix_corLower_parcorUpper %>% papaja::apa_table(caption = "Correlation matrix of key variables of interest. Lower diagonal shows bivariate correlations, upper diagonal shows partial correlations")

labs <- names(regulations.df)
# Plot the matrix as a correlogram
matrix_corLower_parcorUpper %>% corrgram::corrgram(
  type = "cor",
  lower.panel = corrgram::panel.pie,
  upper.panel = corrgram::panel.pie,
  outer.labels = list(bottom = list(labels = labs, cex = 0.75, srt = 30),
                      left = list(labels = labs, cex = 0.75, srt = 30)),
  main = "Bivariate (upper diagonal) and partial (lower diagonal)\ncorrelations of BCTs, motivation and self-reported MVPA")

corMatrix_motivations <- regulations.df %>% cor(use = "pairwise.complete.obs", method = "spearman")

variableNames <- labels(corMatrix_motivations)[[1]] # Extract list of variable names to use in the next call

corMatrix_motivations %>%
  as.data.frame(.) %>% 
  dplyr::mutate(Variable = variableNames) %>% 
  dplyr::select(Variable, 
                `MVPA accelerometer` = mvpaAccelerometer_T1, `MVPA self report` = padaysLastweek_T1, 
                `MVPA accelerometer (% weartime)` = mvpaAccelerometer_percentageWeartime_T1, 
                `Accelerometer wear time` = weartimeAccelerometer_T1) %>%
  dplyr::arrange(desc(`MVPA accelerometer`)) %>% 
  DT::datatable(caption = "Bivariate correlations between motivation and MVPA. Sorted by correlation strength with MVPA accelerometer.")

corMatrix_motivations %>%
  as.data.frame(.) %>% 
  dplyr::transmute(Variable = variableNames,
                   "Accelerometer minus self-report" = mvpaAccelerometer_T1 - padaysLastweek_T1,
                   "Accelerometer minus accelerometer-as-%-weartime" = mvpaAccelerometer_T1 - mvpaAccelerometer_percentageWeartime_T1) %>% 
  dplyr::arrange(desc(`Accelerometer minus self-report`)) %>% 
  DT::datatable(caption = "Differences in correlations among the measures")

```

## Motivational regulations network

```{r sdt-network}
## TEE TÄNNE PIEFILL? tummempi sama väri tai opacity?

# Was going to do fused graphical lasso, but the items not normal...

# s1 <- regulations.df %>% filter(school == 1) %>% dplyr::select(6:ncol(regulations.df)) # %>% na.omit(.) 
# s2 <- regulations.df %>% filter(school == 2) %>% dplyr::select(6:ncol(regulations.df)) # %>% na.omit(.)
# s3 <- regulations.df %>% filter(school == 3) %>% dplyr::select(6:ncol(regulations.df)) # %>% na.omit(.) 
# s4 <- regulations.df %>% filter(school == 4) %>% dplyr::select(6:ncol(regulations.df)) # %>% na.omit(.)
# s5 <- regulations.df %>% filter(school == 5) %>% dplyr::select(6:ncol(regulations.df)) # %>% na.omit(.)
# 
# network2 <- EstimateGroupNetwork(list("1" = s1,
#                                       "2" = s2,
#                                       "3" = s3,
#                                       "4" = s4,
#                                       "5" = s5),
#                                  n = c(nrow(s1), nrow(s2), nrow(s3), nrow(s4), nrow(s5)))
# 
regulations.df <- df %>% dplyr::select(
  id,
  intervention,
  group,
  school,
  girl,
  PA_amotivation_02_T1,
  PA_amotivation_01_T1,
  PA_amotivation_03_T1,
  PA_amotivation_04_T1,
  PA_extrinsic_01_T1,
  PA_extrinsic_02_T1,
  PA_extrinsic_03_T1,
  PA_introjected_01_T1,
  PA_introjected_02_T1,
  PA_identified_01_T1,
  PA_identified_02_T1,
  PA_identified_03_T1,
  PA_integrated_01_T1, 
  PA_integrated_02_T1,
  PA_integrated_03_T1, 
  PA_intrinsic_01_T1,
  PA_intrinsic_02_T1,
  PA_intrinsic_03_T1)

regulations.df <- regulations.df %>% mutate(
PA_amotivation_02_T1 = ifelse(PA_amotivation_02_T1 == 1, 0, 1),
PA_amotivation_01_T1 = ifelse(PA_amotivation_01_T1 == 1, 0, 1),
PA_amotivation_03_T1 = ifelse(PA_amotivation_03_T1 == 1, 0, 1),
PA_amotivation_04_T1 = ifelse(PA_amotivation_04_T1 == 1, 0, 1),
PA_extrinsic_01_T1 = ifelse(PA_extrinsic_01_T1 == 1, 0, 1),
PA_extrinsic_02_T1 = ifelse(PA_extrinsic_02_T1 == 1, 0, 1),
PA_extrinsic_03_T1 = ifelse(PA_extrinsic_03_T1 == 1, 0, 1),
PA_introjected_01_T1 = ifelse(PA_introjected_01_T1 == 1, 0, 1),
PA_introjected_02_T1 = ifelse(PA_introjected_02_T1 == 1, 0, 1),
PA_identified_01_T1 = ifelse(PA_identified_01_T1 == 1, 0, 1),
PA_identified_02_T1 = ifelse(PA_identified_02_T1 == 1, 0, 1),
PA_identified_03_T1 = ifelse(PA_identified_03_T1 == 1, 0, 1),
PA_integrated_01_T1 = ifelse(PA_integrated_01_T1 == 1, 0, 1),
PA_integrated_02_T1 = ifelse(PA_integrated_02_T1 == 1, 0, 1),
PA_integrated_03_T1 = ifelse(PA_integrated_03_T1 == 1, 0, 1),
PA_intrinsic_01_T1 = ifelse(PA_intrinsic_01_T1 == 1, 0, 1),
PA_intrinsic_02_T1 = ifelse(PA_intrinsic_02_T1 == 1, 0, 1),
PA_intrinsic_03_T1 = ifelse(PA_intrinsic_03_T1 == 1, 0, 1))


### GIRLS AND BOYS

S.boys <- regulations.df %>% filter(girl == "boy") %>% dplyr::select(6:ncol(regulations.df)) # %>% na.omit(.) 
S.girls <- regulations.df %>% filter(girl == "girl") %>% dplyr::select(6:ncol(regulations.df)) # %>% na.omit(.)
nwBoys <- bootnet::estimateNetwork(S.boys, default="IsingFit")
nwGirls <- bootnet::estimateNetwork(S.girls, default="IsingFit")

data1 <- regulations.df %>% dplyr::select(6:ncol(regulations.df))
names(data1) <- c(paste0(rep("Amoti", 4), 1:4),
                paste0(rep("Extri", 3), 1:3),
                paste0(rep("Intro", 2), 1:2),
                paste0(rep("Ident", 3), 1:3),
                paste0(rep("Integ", 3), 1:3),
                paste0(rep("Intri", 3), 1:3))
nwAll <- bootnet::estimateNetwork(data1, default="IsingFit")

# Create means for filling nodes
# girlmeans <- regulations.df %>% group_by(girl) %>% 
#   summarise_at(vars(5:(5+nItems-1)),
#   funs(mean(., na.rm = TRUE))) %>% 
#   filter(girl == "girl") %>% 
#   dplyr::select(-1)
# 
# boymeans <- regulations.df %>% group_by(girl) %>% 
#   summarise_at(vars(5:(5+nItems-1)),
#   funs(mean(., na.rm = TRUE))) %>% 
#   filter(girl == "boy") %>% 
#   dplyr::select(-1)

# Find average layout for comparability and plot graphs next to each other

Layout <- qgraph::averageLayout(nwGirls, nwBoys)


layout(t(1:2))
plot(nwGirls, layout = Layout, label.scale = FALSE, title = "Girls", label.cex = 0.5,
     # pie = girlmeans, 
     color = "skyblue",
     pieBorder = 1)

plot(nwBoys, layout = Layout, label.scale = FALSE, title = "Boys", label.cex = 0.5, 
     # pie = boymeans, 
     color = "skyblue",
     pieBorder = 1)

itemNames <- c('I can\'t see why I should bother exercising',
  'I do not see why I should have to exercise',
  ' I do not see the point in exercising',
  ' I think exercising is a waste of time',
  ' I exercise because other people say I should',
  ' I exercise because others will not be pleased with me if I do not',
  ' I feel under pressure from my friends/family to exercise',
  ' I feel guilty when I do not exercise',
  ' I feel like a failure when I have not exercised in a while',
  ' I think it is important to make the effort to exercise regularly',
  ' I value the benefits of exercise',
  ' it is important to me to exercise regularly',
  ' I exercise because it is consistent with my life goals.',
  ' I consider exercise consistent with my values.',
  ' I consider exercise a fundamental part of who I am.',
  ' I get pleasure and satisfaction from participating in exercise',
  ' I exercise because it is fun',
  ' I enjoy my exercise sessions')

itemGroups <- c(rep("Amotivation", 4),
                rep("Extrinsic", 3),
                rep("Introjected", 2),
                rep("Identified", 3),
                rep("Integrated", 3),
                rep("Intrinsic", 3))

```

```{r sdt-network-all}

plot(nwAll, groups = itemGroups, nodeNames = itemNames, legend.cex = 0.25)

```

# Session information

Description of the R environment can be found below.

```{r session-info, results = 'markup'}
devtools::session_info()

pander::pander(sessionInfo())
```
