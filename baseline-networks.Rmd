---
title: "Network analyses"
---

```{r setup}

source("baseline-datasetup.R")

```

Clicking the "Code"-buttons on the right shows code for each chunk.

# Chunked BCTs, PA, motivation 

This section shows the correlations structure between BCTs (lumped into chunks based on whether they relate to frequency or agreement), motivational regulations and PA (self-reported PA the previous week and accelerometer-measured PA the following week).

Note: This is only to demonstrate data exploration, as many assumptions (such as multivariate normality, homogeneity, multilevel structure) are not accounted for.   

## Bivariate correlations

```{r bivariate-correlations, results = "asis"}

bivariate_BCTs <- df %>% dplyr::select(
  'goal setting' = PA_agrbct_01_T1,
  'implementation plan' = PA_agrbct_02_T1,
  'plan by other' = PA_agrbct_03_T1,
  'reminder of plan' = PA_agrbct_04_T1,
  'subgoals' = PA_agrbct_05_T1,
  'new PA options' = PA_agrbct_06_T1,
  'barrier identification' = PA_agrbct_07_T1,
  'coping planning' = PA_agrbct_08_T1,
  'PA identity' = PA_agrbct_09_T1,
  'PA life values' = PA_agrbct_10_T1,
  'positive consequences' = PA_frqbct_01_T1,
  'log on paper' = PA_frqbct_02_T1,
  'smartphone' = PA_frqbct_03_T1,
  'mnemonic cues' = PA_frqbct_04_T1,
  'goal contrast' = PA_frqbct_05_T1,
  'relevance of PA' = PA_frqbct_06_T1,
  'changes at home' = PA_frqbct_07_T1,
  'social support' = PA_frqbct_08_T1,
  'failure contemplated' = PA_frqbct_09_T1,
  'PA accelerometer' = paAccelerometer_T1,
  'PA self-report' = padaysLastweek_T1,
  'autonomous' = PA_autonomous_T1,
  'controlled' = PA_controlled_T1) %>%
 rowwise() %>% 
  dplyr::select(`PA accelerometer`, `PA self-report`, autonomous, controlled, everything()) %>% 
  mutate_all(as.numeric)

# Create a covariance matrix of the data
covMatrix <- bivariate_BCTs %>% cov(use = "pairwise.complete.obs")

# Transform the matrix so, that lower diagonal of the matrix shows partial correlations,
# while the upper one shows bivariate correlations.
matrix_corLower_parcorUpper <- covMatrix %>% ggm::correlations()

# Show the matrix
matrix_corLower_parcorUpper %>% 
  papaja::apa_table(caption = "Correlation matrix of key variables of interest. Upper diagonal shows bivariate correlations, lower diagonal shows partial correlations")

# Plot the matrix as a correlogram
matrix_corLower_parcorUpper %>% corrgram::corrgram(
  type = "cor",
  lower.panel = corrgram::panel.pie,
  upper.panel = corrgram::panel.pie,
  main = "Bivariate (upper diagonal) and partial (lower diagonal)\ncorrelations of key PA variables")

corMatrix_BCTs <- bivariate_BCTs %>% cor(use = "pairwise.complete.obs", method = "spearman")

as.data.frame(as.table(corMatrix_BCTs)) %>% 
  dplyr::filter(Var1 == "PA accelerometer" | Var1 == "PA self report") %>% 
  dplyr::mutate("Spearman correlation" = Freq) %>% 
  dplyr::select(-Freq) %>% 
  dplyr::filter(`Spearman correlation` != 1) %>% 
  dplyr::arrange(desc(`Spearman correlation`)) %>% 
  papaja::apa_table(caption = "Bivariate correlations between BCTs, motivation and PA. Sorted by strength.")

```

Highest bivariate (Spearman) correlations with self-reported PA:

1. I have tried out new ways for me to be physically active.
2. I have personally made a specific plan ("what, where, how") to implement my PA.
3. I have a PA plan, which has been made by someone else, e.g. my sports club (e.g. a workout schedule).
4. I have set PA goals for myself.
5. I have broken down larger PA goals to smaller subgoals.
6. I have compared my actualized PA with the PA goal I have set.
7. I have attempted to find ways to exercise so, that it won't obstruct but instead helps actualise my other life values.
8. I have thought about which reasons to do PA are important to me personally.
9. I have monitored my PA by marking the PA occasions on an exercise log on paper.
10. I have a way by which I remind myself of my PA plan, e.g. I write it down in the calendar.

## Prepare data and show correlation structure

```{r chunked-dataprep-corr, results = "asis"}
bctdf_chunks <- df %>% dplyr::select(
  'agr-BCTs' = PA_agrbct_T1,
  'frq-BCTs' = PA_frqbct_T1,
  'Accelerometer' = paAccelerometer_T1,
  'Self-report' = padaysLastweek_T1,
  'intrinsic' = PA_intrinsic_T1,
  'identified' = PA_identified_T1,
  'introjected' = PA_introjected_T1,
  'extrinsic' = PA_extrinsic_T1) %>%
  rowwise() %>% 
  mutate_all(as.numeric)

labs <- names(bctdf_chunks)

bctdf_chunks %>% 
  corrgram::corrgram( 
         cor.method = "pearson", 
         # diag.panel=panel.minmax, 
         # lower.panel=panel.shade, 
         # lower.panel=panel.ellipse,
         # lower.panel=panel.cor,
         upper.panel=corrgram::panel.conf,
         lower.panel=corrgram::panel.pie,
         outer.labels=list(
           bottom=list(labels=labs,cex=.75, srt=60),
           left=list(labels=labs,cex=.75, srt=30))
         )

# Create a covariance matrix of the data
covMatrix <- bctdf_chunks %>% cov(use = "pairwise.complete.obs")

# Transform the matrix so, that lower diagonal of the matrix shows partial correlations,
# while the upper one shows bivariate correlations.
matrix_corLower_parcorUpper <- covMatrix %>% ggm::correlations()

# Show the matrix
matrix_corLower_parcorUpper %>% 
  papaja::apa_table(caption = "Correlation matrix of key variables of interest. Upper diagonal shows bivariate correlations, lower diagonal shows partial correlations")

# Plot the matrix as a correlogram
matrix_corLower_parcorUpper %>% corrgram::corrgram(
  type = "cor",
  lower.panel = corrgram::panel.pie,
  upper.panel = corrgram::panel.pie,
  main = "Bivariate (upper diagonal) and partial (lower diagonal)\ncorrelations of key PA variables")
```

## Estimate and plot networks

```{r chunked-networks}

# Estimate a network

nwBCT_chunks <- bootnet::estimateNetwork(bctdf_chunks, default="EBICglasso")

bootnetgraph <- plot(nwBCT_chunks, edge.labels = TRUE)

corgraph <- qgraph::qgraph(qgraph::cor_auto(bctdf_chunks), graph = "cor",
       labels = names(bctdf_chunks),
       edge.labels = TRUE)

pcorgraph <- qgraph::qgraph(qgraph::cor_auto(bctdf_chunks), graph = "pcor",
       labels = names(bctdf_chunks),
       edge.labels = TRUE)

# Average the layout and plot all according to that
avlayout <- qgraph::averageLayout(bootnetgraph, corgraph, pcorgraph)

corgraph <- qgraph::qgraph(qgraph::cor_auto(bctdf_chunks), graph = "cor",
       labels = names(bctdf_chunks),
       edge.labels = TRUE, 
       layout = avlayout, 
       title = "bivariate correlation network",
       theme = "colorblind",
       maximum = max(c(bootnetgraph$graph$Graph$maximum,
                     pcorgraph$graph$Graph$maximum, 
                     corgraph$graph$Graph$maximum)))

# To help with visual comparison, that last argument takes the maximum edge of the three 
# graphs and places that as the benchmark for the thickest line in all plots.

pcorgraph <- qgraph::qgraph(qgraph::cor_auto(bctdf_chunks), graph = "pcor",
       labels = names(bctdf_chunks),
       edge.labels = TRUE, 
       layout = avlayout,
       title = "partial correlation network",
       theme = "colorblind",
       maximum = max(c(bootnetgraph$graph$Graph$maximum,
                     pcorgraph$graph$Graph$maximum, 
                     corgraph$graph$Graph$maximum)))

bootnetgraph <- plot(nwBCT_chunks, 
                     edge.labels = TRUE, 
                     layout = avlayout, 
                     title = "partial correlation network, with LASSO regularisation and EBIC model selection",
       maximum = max(c(bootnetgraph$graph$Graph$maximum,
                     pcorgraph$graph$Graph$maximum, 
                     corgraph$graph$Graph$maximum)))

```

### Stability

```{r chunked-stability}
# bootnet_stability_output <- bootnet::bootnet(nwBCT_chunks, nBoots=1000)
# save(bootnet_stability_output, file = "bootnet_stability_output.Rdata")
load("bootnet_stability_output.Rdata")

plot(bootnet_stability_output, labels = TRUE, order = "sample") 
plot(bootnet_stability_output, "edge", plot = "difference", onlyNonZero = TRUE, order = "sample")

# bootnet_centrality_stability_output <- bootnet::bootnet(nwBCT_chunks, nBoots=1000,nCores=8, type="case")
# save(bootnet_centrality_stability_output, file = "bootnet_centrality_stability_output.Rdata")
load("bootnet_centrality_stability_output.Rdata")

plot(bootnet_centrality_stability_output)
plot(bootnet_centrality_stability_output, perNode=T, "strength")


```

# Individual agreement-related BCTs and PA 

Network without combining nodes

```{r individualAgreementBCTs-dataprep-corr, results = "asis"}

bctdf_pa_mgm <- df %>% dplyr::select(
#  id,
#  intervention,
#  group,
#  school,
  'PA selfrep' = padaysLastweek_T1,
  'PA accelerometer' = paAccelerometer_T1,
  'goal setting' = PA_agrbct_01_T1,
  'implementation plan' = PA_agrbct_02_T1,
  'plan by other' = PA_agrbct_03_T1,
  'reminder of plan' = PA_agrbct_04_T1,
  'subgoals' = PA_agrbct_05_T1,
  'new PA options' = PA_agrbct_06_T1,
  'barrier identification' = PA_agrbct_07_T1,
  'coping planning' = PA_agrbct_08_T1,
  'PA identity' = PA_agrbct_09_T1,
  'PA life values' = PA_agrbct_10_T1) %>%
 rowwise() %>% 
 mutate(
  'goal setting' = ifelse(`goal setting` == 1, 0, 1),
  # 'has plan' = ifelse(`implementation plan` == 1 & `plan by other` == 1, 0, 1),
  'implementation plan' = ifelse(`implementation plan` == 1, 0, 1),
  'reminder of plan' = ifelse(`reminder of plan` == 1, 0, 1),
  'subgoals' = ifelse(`subgoals` == 1, 0, 1),
  'new PA options' = ifelse(`new PA options` == 1, 0, 1),
  'plan by other' = ifelse(`plan by other` == 1, 0, 1),
 'barrier identification' = ifelse(`barrier identification` == 1, 0, 1),
 'coping planning' = ifelse(`coping planning` == 1, 0, 1),
  # 'barriers identified or planned for' = ifelse(`coping planning` == 1 & `barrier identification` == 1, 0, 1),
 'PA identity' = ifelse(`PA identity` == 1, 0, 1),
 'PA life values' = ifelse(`PA life values` == 1, 0, 1)) %>% 
  # 'identity, life values' = ifelse(`PA identity` == 1 & `PA life values` == 1, 0, 1),
  # dplyr::select(-`log on paper`, -`smartphone`, -`plan by other`, -`implementation plan`, -identified, -intrinsic,
  #        -`failure contemplated`, # only concerns those who haven't reached goals
  #        -`barrier identification`, -`coping planning`, # closely related
  #        -`PA identity`, -`PA life values`) %>% # closely related
#  dplyr::select(-controlled) %>% # Not really gaussian at all 
  data.frame %>% 
  mutate_all(as.numeric)

# bctdf_mgm$autonomous[is.nan(bctdf_mgm$autonomous)] <- NA

# Create a covariance matrix of the data
covMatrix <- bctdf_pa_mgm %>% cov(use = "pairwise.complete.obs")

# Transform the matrix so, that lower diagonal of the matrix shows partial correlations,
# while the upper one shows bivariate correlations.
matrix_corLower_parcorUpper <- covMatrix %>% ggm::correlations()

# Show the matrix
matrix_corLower_parcorUpper %>% papaja::apa_table(caption = "Correlation matrix of key variables of interest. Upper diagonal shows bivariate correlations, lower diagonal shows partial correlations")

# Plot the matrix as a correlogram
matrix_corLower_parcorUpper %>% corrgram::corrgram(
  type = "cor",
  lower.panel = corrgram::panel.pie,
  upper.panel = corrgram::panel.pie,
  main = "Bivariate (upper diagonal) and partial (lower diagonal)\ncorrelations of agreement-BCTs and PA")

```

## mgm estimation

```{r individualAgreementBCTs-mgm}
# devtools::install_github("jmbh/mgm")
# Restart R for the latest package
# .r.restartR()

# mgm wants full data, see package missForest for imputation
bctdf_pa_mgm_fullobs <- bctdf_pa_mgm %>% na.omit()

mgm_pa_variable_types <- c("c", "g", rep("c", 10))
mgm_pa_variable_levels <- c("8", "1", rep("2", 10))
data.frame(mgm_pa_variable_types, mgm_pa_variable_levels, names(bctdf_pa_mgm_fullobs))

mgm_obj <- mgm::mgm(data = bctdf_pa_mgm_fullobs,
  type = mgm_pa_variable_types,
  level = mgm_pa_variable_levels,
  lambdaSel = "CV",
  lambdaFolds = 10,
  pbar = FALSE, 
  binarySign = TRUE)

pred_obj <- predict(object = mgm_obj,
                         data = bctdf_pa_mgm_fullobs)

pred_obj$errors

# Take R2 from gaussian, CC from categorical variables 
pie_errors <- c(pred_obj$errors[1, 4],
                pred_obj$errors[2, 3],
                pred_obj$errors[3:nrow(pred_obj$errors), 4])

# PLOT NETWORK 

node_colors <- c(viridis::viridis(4, begin = 0.3, end = 0.8)[1], 
                 viridis::viridis(4, begin = 0.3, end = 0.8)[2],
                 rep(viridis::viridis(4, begin = 0.3, end = 0.8)[3], 10))

BCT_mgm <- qgraph::qgraph(mgm_obj$pairwise$wadj, 
            layout = "spring",
            repulsion = 0.90, # To nudge the network from originally bad visual state
            title = "agreement-measured BCTs and PA (accelerometer & self-reported)",
            edge.color = ifelse(mgm_obj$pairwise$edgecolor == "darkgreen", "blue", mgm_obj$pairwise$edgecolor),
            pie = pie_errors,
            pieColor = viridis::viridis(4, begin = 0.3, end = 0.8)[4],
            color = node_colors,
            labels = names(bctdf_pa_mgm_fullobs),
            label.cex = 0.75,
            label.scale = FALSE,
            label.color = c(rep("black", 12)),
            theme = "colorblind")
```

## ggm estimation

```{r individualAgreementBCTs-ggm}

# Estimate a network

individualAgreementBCTs <- bootnet::estimateNetwork(bctdf_pa_mgm, default="EBICglasso")

bootnetgraph <- plot(individualAgreementBCTs, edge.labels = TRUE)

corgraph <- qgraph::qgraph(qgraph::cor_auto(bctdf_pa_mgm), graph = "cor",
       labels = names(bctdf_pa_mgm),
       edge.labels = TRUE)

pcorgraph <- qgraph::qgraph(qgraph::cor_auto(bctdf_pa_mgm), graph = "pcor",
       labels = names(bctdf_pa_mgm),
       edge.labels = TRUE)

# Average the layout and plot all according to that
avlayout <- qgraph::averageLayout(bootnetgraph, corgraph, pcorgraph)

corgraph <- qgraph::qgraph(qgraph::cor_auto(bctdf_pa_mgm), graph = "cor",
       labels = names(bctdf_pa_mgm),
       edge.labels = TRUE, 
       layout = avlayout, 
       title = "bivariate correlation network",
       theme = "colorblind",
       maximum = max(c(bootnetgraph$graph$Graph$maximum,
                     pcorgraph$graph$Graph$maximum, 
                     corgraph$graph$Graph$maximum)),
       label.scale = FALSE)

# To help with visual comparison, that last argument takes the maximum edge of the three 
# graphs and places that as the benchmark for the thickest line in all plots.

pcorgraph <- qgraph::qgraph(qgraph::cor_auto(bctdf_pa_mgm), graph = "pcor",
       labels = names(bctdf_pa_mgm),
       edge.labels = TRUE, 
       layout = avlayout,
       title = "partial correlation network",
       theme = "colorblind",
       maximum = max(c(bootnetgraph$graph$Graph$maximum,
                     pcorgraph$graph$Graph$maximum, 
                     corgraph$graph$Graph$maximum)),
       label.scale = FALSE)

bootnetgraph <- plot(individualAgreementBCTs, 
                     edge.labels = TRUE, 
                     layout = avlayout, 
                     title = "partial correlation network, with LASSO regularisation and EBIC model selection",
       maximum = max(c(bootnetgraph$graph$Graph$maximum,
                     pcorgraph$graph$Graph$maximum, 
                     corgraph$graph$Graph$maximum)),
       label.scale = FALSE)
```

### Centrality and stability

```{r individualAgreementBCTs-stability}

combinedAgreementBcts_centralityPlot <- qgraph::centralityPlot(bootnetgraph)

qgraph::centrality(bootnetgraph)$InDegree
scale(qgraph::centrality(bootnetgraph)$InDegree)
qgraph::centrality(bootnetgraph)$Closeness
qgraph::centrality(bootnetgraph)$Betweenness

cor(qgraph::centrality(bootnetgraph)$InDegree, qgraph::centrality(bootnetgraph)$Betweenness, 
    method = "spearman") 

# bootnet_stability_individualAgreementBcts <- bootnet::bootnet(individualAgreementBCTs, nBoots=1000)
# save(bootnet_stability_individualAgreementBcts, file = "bootnet_stability_individualAgreementBcts.Rdata")
load("bootnet_stability_individualAgreementBcts.Rdata")

plot(bootnet_stability_individualAgreementBcts, labels = TRUE, order = "sample") 
plot(bootnet_stability_individualAgreementBcts, "edge", plot = "difference", onlyNonZero = TRUE, order = "sample")

# bootnet_centrality_stability_individualAgreementBcts <- bootnet::bootnet(individualAgreementBCTs, nBoots=1000,nCores=8, type="case")
# save(bootnet_centrality_stability_individualAgreementBcts, file = "bootnet_centrality_stability_individualAgreementBcts.Rdata")
load("bootnet_centrality_stability_individualAgreementBcts.Rdata")

plot(bootnet_centrality_stability_individualAgreementBcts)
plot(bootnet_centrality_stability_individualAgreementBcts, perNode=T, "strength")

bootnet::corStability(bootnet_centrality_stability_individualAgreementBcts)
```

# Combined agreement-related BCTs and PA

```{r combinedAgreementBcts-mgm-dataprep-corr}

bctdf_pa_combinedAgreementBcts <- df %>% dplyr::select(
  'PA selfrep' = padaysLastweek_T1,
  'PA accelerometer' = paAccelerometer_T1,
  'goal setting' = PA_agrbct_01_T1,
  'implementation plan' = PA_agrbct_02_T1,
  'plan by other' = PA_agrbct_03_T1,
  'reminder of plan' = PA_agrbct_04_T1,
  'subgoals' = PA_agrbct_05_T1,
  'new PA options' = PA_agrbct_06_T1,
  'barrier identification' = PA_agrbct_07_T1,
  'coping planning' = PA_agrbct_08_T1,
  'PA identity' = PA_agrbct_09_T1,
  'PA life values' = PA_agrbct_10_T1) %>%
 rowwise() %>% 
 mutate(
  'goal setting' = ifelse(`goal setting` == 1, 0, 1),
  'has plan' = ifelse(`implementation plan` == 1 & `plan by other` == 1, 0, 1),
  # 'implementation plan' = ifelse(`implementation plan` == 1, 0, 1),
  'reminder of plan' = ifelse(`reminder of plan` == 1, 0, 1),
  'subgoals' = ifelse(`subgoals` == 1, 0, 1),
  'new PA options' = ifelse(`new PA options` == 1, 0, 1),
  # 'plan by other' = ifelse(`plan by other` == 1, 0, 1), 
  # 'barrier identification' = ifelse(`barrier identification` == 1, 0, 1),
  # 'coping planning' = ifelse(`coping planning` == 1, 0, 1),
  'barriers identified or planned for' = ifelse(`coping planning` == 1 & `barrier identification` == 1, 0, 1),
  # 'PA identity' = ifelse(`PA identity` == 1, 0, 1),
  # 'PA life values' = ifelse(`PA life values` == 1, 0, 1)) %>% 
  'identity, life values' = ifelse(`PA identity` == 1 & `PA life values` == 1, 0, 1)) %>% 
  dplyr::select(-`plan by other`, -`implementation plan`,
         -`barrier identification`, -`coping planning`, # closely related
         -`PA identity`, -`PA life values`) %>% # closely related
  data.frame


```

#### mgm estimation

```{r combinedAgreementBcts-mgm}
# devtools::install_github("jmbh/mgm")
# Restart R for the latest package
# .r.restartR()

# mgm wants full data, see package missForest for imputation
bctdf_pa_combinedAgreementBcts <- bctdf_pa_combinedAgreementBcts %>% na.omit()
bctdf_pa_combinedAgreementBcts %>% names()
mgm_pa_variable_types <- c("g", "g", rep("c", 7))
mgm_pa_variable_levels <- c("1", "1", rep("2", 7))
data.frame(mgm_pa_variable_types, mgm_pa_variable_levels, names(bctdf_pa_combinedAgreementBcts))

mgm_obj <- mgm::mgm(data = bctdf_pa_combinedAgreementBcts,
  type = mgm_pa_variable_types,
  level = mgm_pa_variable_levels,
  lambdaSel = "CV",
  lambdaFolds = 10,
  pbar = FALSE, 
  binarySign = TRUE)

pred_obj <- predict(object = mgm_obj,
                         data = bctdf_pa_combinedAgreementBcts)

pred_obj$errors

# Take R2 from gaussian, CC from categorical variables 
pie_errors <- c(pred_obj$errors[1, 3],
                pred_obj$errors[2, 3],
                pred_obj$errors[3:nrow(pred_obj$errors), 4])

# PLOT NETWORK 

node_colors <- c(viridis::viridis(4, begin = 0.3, end = 0.8)[1], 
                 viridis::viridis(4, begin = 0.3, end = 0.8)[2],
                 rep(viridis::viridis(4, begin = 0.3, end = 0.8)[3], 7))

BCT_mgm <- qgraph::qgraph(mgm_obj$pairwise$wadj, 
            layout = "spring",
            repulsion = 1, # To nudge the network from originally bad visual state
            title = "agreement-measured BCTs and PA",
            edge.color = ifelse(mgm_obj$pairwise$edgecolor == "darkgreen", "blue", mgm_obj$pairwise$edgecolor),
            pie = pie_errors,
            pieColor = viridis::viridis(4, begin = 0.3, end = 0.8)[4],
            color = node_colors,
            labels = names(bctdf_pa_combinedAgreementBcts),
            label.cex = 0.75,
            label.scale = FALSE,
            label.color = c(rep("black", 9)),
            theme = "colorblind")
```

## GGM plot

```{r combinedAgreementBcts-ggm-dataprep}

combinedAgreementBcts_ggm_df <- df %>% dplyr::select(
  'PA selfrep' = padaysLastweek_T1,
  'PA accelerometer' = paAccelerometer_T1,
  'goal setting' = PA_agrbct_01_T1,
  'implementation plan' = PA_agrbct_02_T1,
  'plan by other' = PA_agrbct_03_T1,
  'reminder of plan' = PA_agrbct_04_T1,
  'subgoals' = PA_agrbct_05_T1,
  'new PA options' = PA_agrbct_06_T1,
  'barrier identification' = PA_agrbct_07_T1,
  'coping planning' = PA_agrbct_08_T1,
  'PA identity' = PA_agrbct_09_T1,
  'PA life values' = PA_agrbct_10_T1) %>%
 rowwise() %>% 
 mutate(
  'has plan' = mean(c(`implementation plan`, `plan by other`), na.rm = TRUE),
  'barriers identified or planned for' = mean(c(`coping planning`, `barrier identification`), na.rm = TRUE),
  'identity, life values' = mean(c(`PA identity` == 1, `PA life values`), na.rm = TRUE)) %>% 
  dplyr::select(-`plan by other`, -`implementation plan`, 
         -`barrier identification`, -`coping planning`, # closely related
         -`PA identity`, -`PA life values`) %>% # closely related
  mutate_all(as.numeric) %>% 
  data.frame

# Create means for filling nodes
# piefill_ggm <- S.total_ggm %>% 
#   dplyr::select(-contains("MVPA"), -girl, -intervention) %>%
#   summarise_all(funs(median(., na.rm = TRUE) / 6)) 
# 
# piefill_ggm$MVPA <- median(S.total_ggm$MVPA, na.rm = TRUE) / (60*24) 
# piefill_ggm$girl <- mean(S.total_ggm$girl, na.rm = TRUE)
# piefill_ggm$intervention <- mean(S.total_ggm$intervention, na.rm = TRUE)
# 
# piefill_ggm <- piefill_ggm %>% dplyr::select(MVPA, girl, intervention, everything())


```

```{r combinedAgreementBcts-ggm}
# Estimate a network

combinedAgreementBcts_network <- bootnet::estimateNetwork(combinedAgreementBcts_ggm_df, default="EBICglasso")

bootnetgraph <- plot(combinedAgreementBcts_network, edge.labels = TRUE)

corgraph <- qgraph::qgraph(qgraph::cor_auto(combinedAgreementBcts_ggm_df), graph = "cor",
       labels = names(combinedAgreementBcts_ggm_df),
       edge.labels = TRUE)

pcorgraph <- qgraph::qgraph(qgraph::cor_auto(combinedAgreementBcts_ggm_df), graph = "pcor",
       labels = names(combinedAgreementBcts_ggm_df),
       edge.labels = TRUE)

# Average the layout and plot all according to that
avlayout <- qgraph::averageLayout(bootnetgraph, corgraph, pcorgraph)

corgraph <- qgraph::qgraph(qgraph::cor_auto(combinedAgreementBcts_ggm_df), graph = "cor",
       labels = names(combinedAgreementBcts_ggm_df),
       edge.labels = TRUE, 
       layout = avlayout, 
       title = "bivariate correlation network",
       theme = "colorblind",
       maximum = max(c(bootnetgraph$graph$Graph$maximum,
                     pcorgraph$graph$Graph$maximum, 
                     corgraph$graph$Graph$maximum)),
       label.scale = FALSE)

# To help with visual comparison, that last argument takes the maximum edge of the three 
# graphs and places that as the benchmark for the thickest line in all plots.

pcorgraph <- qgraph::qgraph(qgraph::cor_auto(combinedAgreementBcts_ggm_df), graph = "pcor",
       labels = names(combinedAgreementBcts_ggm_df),
       edge.labels = TRUE, 
       layout = avlayout,
       title = "partial correlation network",
       theme = "colorblind",
       maximum = max(c(bootnetgraph$graph$Graph$maximum,
                     pcorgraph$graph$Graph$maximum, 
                     corgraph$graph$Graph$maximum)),
       label.scale = FALSE)

bootnetgraph <- plot(combinedAgreementBcts_network, 
                     edge.labels = TRUE, 
                     layout = avlayout, 
                     title = "partial correlation network, with LASSO regularisation and EBIC model selection",
       maximum = max(c(bootnetgraph$graph$Graph$maximum,
                     pcorgraph$graph$Graph$maximum, 
                     corgraph$graph$Graph$maximum)),
       label.scale = FALSE)
```

### Centrality and stability

```{r combinedAgreementBcts-stability}
combinedAgreementBcts_centralityPlot <- qgraph::centralityPlot(bootnetgraph)

qgraph::centrality(bootnetgraph)$InDegree
scale(qgraph::centrality(bootnetgraph)$InDegree)
qgraph::centrality(bootnetgraph)$Closeness
qgraph::centrality(bootnetgraph)$Betweenness

cor(qgraph::centrality(bootnetgraph)$InDegree, qgraph::centrality(bootnetgraph)$Betweenness, 
    method = "spearman") 

# bootnet_stability_combinedAgreementBcts <- bootnet::bootnet(combinedAgreementBcts_network, nBoots=1000)
# save(bootnet_stability_combinedAgreementBcts, file = "bootnet_stability_combinedAgreementBcts.Rdata")
load("bootnet_stability_combinedAgreementBcts.Rdata")

plot(bootnet_stability_combinedAgreementBcts, labels = TRUE, order = "sample") 
plot(bootnet_stability_combinedAgreementBcts, "edge", plot = "difference", onlyNonZero = TRUE, order = "sample")

# bootnet_centrality_stability_combinedAgreementBcts <- bootnet::bootnet(combinedAgreementBcts_network, nBoots=1000,nCores=8, type="case")
# save(bootnet_centrality_stability_combinedAgreementBcts, file = "bootnet_centrality_stability_combinedAgreementBcts.Rdata")
load("bootnet_centrality_stability_combinedAgreementBcts.Rdata")

plot(bootnet_centrality_stability_combinedAgreementBcts)
plot(bootnet_centrality_stability_combinedAgreementBcts, perNode=T, "strength")

bootnet::corStability(bootnet_centrality_stability_combinedAgreementBcts)

```

### Heterogeneity

The smallest track (IT) has 163 observations. According to the heuristic sample size for p variables for Gaussian data, (p*(p-1)/2 + p), we could estimate about 7 variables. (based on [these slides](https://cvborkulo.files.wordpress.com/2014/09/winterschool2017.pdf) referring to this source: Bühlmann, P. & van de Geer, S. (2011). Statistics for High-Dimensional Data: Methods, Theory and Applications. Springer.)

All tracks seem sufficiently similar on these BCTs.

```{r combinedAgreementBcts-heterogeneity}

combinedAgreementBcts_tracks_df <- df %>% 
  dplyr::select(
  'PA selfrep' = padaysLastweek_T1,
  # 'PA accelerometer' = paAccelerometer_T1,
  'Autonomous' = PA_autonomous_T1,
  'goal setting' = PA_agrbct_01_T1,
  'implementation plan' = PA_agrbct_02_T1,
  # 'plan by other' = PA_agrbct_03_T1,
  'reminder of plan' = PA_agrbct_04_T1,
  'subgoals' = PA_agrbct_05_T1,
  # 'new PA options' = PA_agrbct_06_T1,
  'barrier identification' = PA_agrbct_07_T1,
  'coping planning' = PA_agrbct_08_T1,
  'PA identity' = PA_agrbct_09_T1,
  'PA life values' = PA_agrbct_10_T1) %>%
 rowwise() %>% 
 mutate(
  'barriers identified or planned for' = mean(c(`coping planning`, `barrier identification`), na.rm = TRUE), 
  'identity, life values' = mean(c(`PA identity` == 1, `PA life values`), na.rm = TRUE)) %>% 
  dplyr::select( 
         -`barrier identification`, -`coping planning`, # closely related
         -`PA identity`, -`PA life values`) %>% # closely related
  mutate_all(as.numeric) 

combinedAgreementBcts_tracks_df <- cbind(track = df$track, combinedAgreementBcts_tracks_df) 

combinedAgreementBcts_tracks_df %>% dplyr::group_by(track) %>% summarise(n = n())

heterogeneity_Nur <- combinedAgreementBcts_tracks_df %>% 
  dplyr::filter(track == "Nur") %>% 
  dplyr::select(-track)

heterogeneity_HRC <- combinedAgreementBcts_tracks_df %>% 
  dplyr::filter(track == "HRC") %>% 
  dplyr::select(-track)

heterogeneity_BA <- combinedAgreementBcts_tracks_df %>% 
  dplyr::filter(track == "BA") %>% 
  dplyr::select(-track)

heterogeneity_IT <- combinedAgreementBcts_tracks_df %>% 
  dplyr::filter(track == "IT") %>% 
  dplyr::select(-track)

network_Nur <- bootnet::estimateNetwork(heterogeneity_Nur, default="EBICglasso")
network_HRC <- bootnet::estimateNetwork(heterogeneity_HRC, default="EBICglasso")
network_BA <- bootnet::estimateNetwork(heterogeneity_BA, default="EBICglasso")
network_IT <- bootnet::estimateNetwork(heterogeneity_IT, default="EBICglasso")

graph_Nur <- plot(network_Nur, layout="spring", cut=0, label.scale = FALSE)
graph_HRC <- plot(network_HRC, layout="spring", cut=0, label.scale = FALSE)
graph_BA <- plot(network_BA, layout="spring", cut=0, label.scale = FALSE)
graph_IT <- plot(network_IT, layout="spring", cut=0, label.scale = FALSE)

maxedge <- max(c(graph_Nur$graphAttributes$Graph$maximum, 
                 graph_HRC$graphAttributes$Graph$maximum, 
                 graph_BA$graphAttributes$Graph$maximum, 
                 graph_IT$graphAttributes$Graph$maximum))

L <- qgraph::averageLayout(graph_Nur, graph_HRC, graph_BA, graph_IT)

layout(matrix(1:4, nrow = 2, byrow = TRUE))
graph_Nur <- plot(network_Nur, layout=L, cut=0, label.scale = FALSE, title = "Practical nurse", 
                  maximum = maxedge)
graph_HRC <- plot(network_HRC, layout=L, cut=0, label.scale = FALSE, title = "HRC",
                  maximum = maxedge)
graph_BA <- plot(network_BA, layout=L, cut=0, label.scale = FALSE, title = "BA", 
                 maximum = maxedge)
graph_IT <- plot(network_IT, layout=L, cut=0, label.scale = FALSE, title = "IT",
                 maximum = maxedge)

### similarity: statistical
cor(qgraph::centrality(network_Nur)$InDegree, qgraph::centrality(network_IT)$InDegree)

cor(network_Nur$graph[lower.tri(network_Nur$graph)], network_IT$graph[lower.tri(network_Nur$graph)], method="spearman")

### difference: statistical
nct_results <- NetworkComparisonTest::NCT(heterogeneity_Nur, heterogeneity_IT, it=1000, binary.data=FALSE, paired=FALSE, test.edges=TRUE,
edges='all', progressbar=TRUE)
# alternatively, load 
save(nct_results, file="NCT.Rdata")
# load("NCT.Rdata")

nct_results$nwinv.pval
nct_results$glstrinv.pval
nct_results$einv.pvals
sum(nct_results$einv.pvals$"p-value" < 0.05)
```



# Agreement and frequency BCTs with motivation and survey MVPA

This section presents a Mixed Graphical Model (MGM) and a Gaussian Graphical Model (GGM). In the MGM, we opted to dichotomise the BCTs in order to increase interpretability while not violating model assumptions. Results are nearly identical.

```{r allBctsMotiSurveyPA-dataprep}
bctdf_mgm <- df %>% dplyr::select(
#  id,
#  intervention,
#  group,
#  school,
#  girl,
  'goal setting' = PA_agrbct_01_T1,
  'implementation plan' = PA_agrbct_02_T1,
  'plan by other' = PA_agrbct_03_T1,
  'reminder of plan' = PA_agrbct_04_T1,
  'subgoals' = PA_agrbct_05_T1,
  'new PA options' = PA_agrbct_06_T1,
  'barrier identification' = PA_agrbct_07_T1,
  'coping planning' = PA_agrbct_08_T1,
  'PA identity' = PA_agrbct_09_T1,
  'PA life values' = PA_agrbct_10_T1,
  'positive consequences' = PA_frqbct_01_T1,
  'log on paper' = PA_frqbct_02_T1,
  'smartphone' = PA_frqbct_03_T1,
#  'mnemonic cues' = PA_frqbct_04_T1,
  'goal contrast' = PA_frqbct_05_T1,
  'relevance of PA' = PA_frqbct_06_T1,
  'changes at home' = PA_frqbct_07_T1,
  'social support' = PA_frqbct_08_T1,
  'failure contemplated' = PA_frqbct_09_T1,
  'MVPA' = padaysLastweek_T1,
  'intrinsic' = PA_intrinsic_T1,
  'identified' = PA_identified_T1,
  'controlled' = PA_controlled_T1) %>%
 rowwise() %>% 
 mutate(
  'goal setting' = ifelse(`goal setting` == 1, 0, 1),
#  'has plan' = ifelse(`implementation plan` == 1 & `plan by other` == 1, 0, 1),
  'implementation plan' = ifelse(`implementation plan` == 1, 0, 1),
  'plan by other' = ifelse(`plan by other` == 1, 0, 1),
  'reminder of plan' = ifelse(`reminder of plan` == 1, 0, 1),
  'subgoals' = ifelse(`subgoals` == 1, 0, 1),
  'new PA options' = ifelse(`new PA options` == 1, 0, 1),
#  'barrier identification' = ifelse(`barrier identification` == 1, 0, 1),
#  'coping planning' = ifelse(`coping planning` == 1, 0, 1),
  'barriers identified or planned for' = ifelse(`coping planning` == 1 & `barrier identification` == 1, 0, 1),
#  'PA identity' = ifelse(`PA identity` == 1, 0, 1),
#  'PA life values' = ifelse(`PA life values` == 1, 0, 1),
  'identity, life values' = ifelse(`PA identity` == 1 & `PA life values` == 1, 0, 1),
  'positive consequences' = ifelse(`positive consequences` == 1, 0, 1),
  'monitored PA' = ifelse(`log on paper` == 1 & `smartphone` == 1, 0, 1),
#  'mnemonic cues' = ifelse(`mnemonic cues` == 1, 0, 1),
  'goal contrast' = ifelse(`goal contrast` == 1, 0, 1),
  'relevance of PA' = ifelse(`relevance of PA` == 1, 0, 1),
  'changes at home' = ifelse(`changes at home` == 1, 0, 1),
  'social support' = ifelse(`social support` == 1, 0, 1),
  'failure contemplated' = ifelse(`failure contemplated` == 1, 0, 1),
  'autonomous' = mean(c(identified, intrinsic), na.rm = T),
#  'girl' = ifelse(girl == "girl", 1, 0),
  'controlled' = ifelse(controlled < 3, 0, 1)) %>%  # If "at least partly" or more true, input 1. Normality otherwise a problem. 
#  'intervention' = ifelse(intervention == "1", 1, 0)) %>% 
  dplyr::select(-`log on paper`, -`smartphone`, 
                # -`plan by other`, -`implementation plan`, 
                -identified, -intrinsic,
         -`failure contemplated`, # only concerns those who haven't reached goals
         -`barrier identification`, -`coping planning`, # closely related
         -`PA identity`, -`PA life values`) %>% # closely related
#  dplyr::select(-controlled) %>% # Not really gaussian at all 
  dplyr::select(MVPA, everything())

bctdf_mgm$autonomous[is.nan(bctdf_mgm$autonomous)] <- NA

labs <- names(bctdf_mgm)

```

#### mgm estimation

```{r allBctsMotiSurveyPA-mgm}
# devtools::install_github("jmbh/mgm")
# Restart R for the latest package
# .r.restartR()


# mgm wants full data, see package missForest for imputation
bctdf_mgm <- bctdf_mgm %>% na.omit(.)
bctdf_mgm %>% names()
mgm_variable_types <- c("g", rep("c", 15), "g")
mgm_variable_levels <- c("1", rep("2", 15), "1")
data.frame(mgm_variable_types, mgm_variable_levels, names(bctdf_mgm))

mgm_obj <- mgm::mgm(data = bctdf_mgm,
  type = mgm_variable_types,
  level = mgm_variable_levels,
  lambdaSel = "CV",
  lambdaFolds = 10,
  pbar = FALSE, 
  binarySign = TRUE)

pred_obj <- predict(object = mgm_obj,
                         data = bctdf_mgm)

pred_obj$errors

# Take R2 from gaussian, CC from categorical variables 
pie_errors <- c(pred_obj$errors[1, 3],
                pred_obj$errors[2:16, 4],
                pred_obj$errors[17, 3])


```

#### mgm plotting

This plot is presented in the manuscript.

```{r allBctsMotiSurveyPA-mgm-plot}
library(qgraph)
library(igraph)

node_colors <- c(viridis::viridis(5, begin = 0.3, end = 0.8)[1],
                 rep(viridis::viridis(5, begin = 0.3, end = 0.8)[2], 11),
                 rep(viridis::viridis(5, begin = 0.3, end = 0.8)[3], 1),   
                 rep(viridis::viridis(5, begin = 0.3, end = 0.8)[2], 3),
                 viridis::viridis(5, begin = 0.3, end = 0.8)[4])

BCT_mgm <- qgraph::qgraph(mgm_obj$pairwise$wadj, 
            layout = "spring",
            repulsion = 0.95, # To nudge the network from originally bad visual state
            title = "Mixed graphical model: PA, BCTs & motivation",
            edge.color = ifelse(mgm_obj$pairwise$edgecolor == "darkgreen", "blue", mgm_obj$pairwise$edgecolor),
            pie = pie_errors,
            pieColor = viridis::viridis(5, begin = 0.3, end = 0.8)[5],
            color = node_colors,
            labels = names(bctdf_mgm),
            label.cex = 0.75,
            label.scale = FALSE,
            label.color = c(rep("white", 1), rep("black", 16)),
            theme = "colorblind")

```

### ggm estimation & plotting

```{r allBctsMotiSurveyPA-ggm}

bctdf_ggm <- df %>% dplyr::select(
#  id,
#  intervention,
#  group,
#  school,
#  girl,
  'goal setting' = PA_agrbct_01_T1,
  'implementation plan' = PA_agrbct_02_T1,
  'plan by other' = PA_agrbct_03_T1,
  'reminder of plan' = PA_agrbct_04_T1,
  'subgoals' = PA_agrbct_05_T1,
  'new PA options' = PA_agrbct_06_T1,
  'barrier identification' = PA_agrbct_07_T1,
  'coping planning' = PA_agrbct_08_T1,
  'PA identity' = PA_agrbct_09_T1,
  'PA life values' = PA_agrbct_10_T1,
  'positive consequences' = PA_frqbct_01_T1,
  'log on paper' = PA_frqbct_02_T1,
  'smartphone' = PA_frqbct_03_T1,
#  'mnemonic cues' = PA_frqbct_04_T1,
  'goal contrast' = PA_frqbct_05_T1,
  'relevance of PA' = PA_frqbct_06_T1,
  'changes at home' = PA_frqbct_07_T1,
  'social support' = PA_frqbct_08_T1,
  'failure contemplated' = PA_frqbct_09_T1,
  'MVPA' = padaysLastweek_T1,
  'intrinsic' = PA_intrinsic_T1,
  'identified' = PA_identified_T1,
  'controlled' = PA_controlled_T1) %>%
 rowwise() %>% 
 mutate(
#  'has plan' = mean(c(`implementation plan`, `plan by other`), na.rm = TRUE),
  'barriers identified or planned for' = mean(c(`coping planning`, `barrier identification`), na.rm = TRUE),
  'identity, life values' = mean(c(`PA identity` == 1, `PA life values`), na.rm = TRUE),
  'monitored PA' = mean(c(`log on paper`, `smartphone`), na.rm = TRUE),
  'autonomous' = mean(c(identified, intrinsic), na.rm = T)) %>% 
#  'girl' = ifelse(girl == "girl", 1, 0),
#  'intervention' = ifelse(intervention == "1", 1, 0)) %>% 
  dplyr::select(-`log on paper`, -`smartphone`, 
#                -`plan by other`, -`implementation plan`,
                -identified, -intrinsic,
         -`failure contemplated`, # only concerns those who haven't reached goals
         -`barrier identification`, -`coping planning`, # closely related
         -`PA identity`, -`PA life values`) %>% # closely related
#  dplyr::select(-controlled) %>% # Not really gaussian at all 
  dplyr::select(MVPA, autonomous, controlled, everything()) %>% 
  dplyr::mutate_all(as.numeric)

# Network for all participants
S.total_ggm <- bctdf_ggm
nwBCT_ggm <- bootnet::estimateNetwork(S.total_ggm, default="EBICglasso")

labs_ggm <- colnames(S.total_ggm)

# Create means for filling nodes
piefill_ggm <- S.total_ggm %>% 
  dplyr::select(-MVPA, -autonomous, -controlled) %>% data.frame %>% 
  dplyr::summarise_all(funs(mean(., na.rm = TRUE) /6))

piefill_ggm$MVPA <- median(S.total_ggm$MVPA, na.rm = TRUE) / 7
piefill_ggm$autonomous <- median(S.total_ggm$autonomous, na.rm = TRUE) / 5
piefill_ggm$controlled <- median(S.total_ggm$controlled, na.rm = TRUE) / 5
  
piefill_ggm <- piefill_ggm %>% 
  dplyr::select(MVPA, autonomous, controlled, everything()) 

# Plot network

BCT_ggm <- plot(nwBCT_ggm, 
                layout = "spring", 
                repulsion = 0.99, # To nudge the network from originally bad visual state
                label.scale = FALSE, 
                title = "GGM: PA, BCTs & motivation", 
                label.cex = 0.75,
                pie = piefill_ggm,
                color = "skyblue",
                pieBorder = 1)

```

### Centrality and stability

```{r allBctsMotiSurveyPA-ggm-stability, results = "asis"}
allBctsMotiSurveyPA <- nwBCT_ggm

allBctsMotiSurveyPA_centralityPlot <- qgraph::centralityPlot(allBctsMotiSurveyPA)

qgraph::centrality(allBctsMotiSurveyPA)$InDegree
scale(qgraph::centrality(allBctsMotiSurveyPA)$InDegree)
qgraph::centrality(allBctsMotiSurveyPA)$Closeness
qgraph::centrality(allBctsMotiSurveyPA)$Betweenness

cor(qgraph::centrality(allBctsMotiSurveyPA)$InDegree, qgraph::centrality(allBctsMotiSurveyPA)$Betweenness, 
    method = "spearman") 

# bootnet_stability_allBctsMotiSurveyPA <- bootnet::bootnet(allBctsMotiSurveyPA, nBoots=1000)
# save(bootnet_stability_allBctsMotiSurveyPA, file = "bootnet_stability_allBctsMotiSurveyPA.Rdata")
load("bootnet_stability_allBctsMotiSurveyPA.Rdata")

plot(bootnet_stability_allBctsMotiSurveyPA, labels = FALSE, order = "sample") 
plot(bootnet_stability_allBctsMotiSurveyPA, labels = FALSE, "edge", plot = "difference", onlyNonZero = TRUE, order = "sample")

# bootnet_centrality_stability_allBctsMotiSurveyPA <- bootnet::bootnet(allBctsMotiSurveyPA, nBoots=1000,nCores=8, type="case")
# save(bootnet_centrality_stability_allBctsMotiSurveyPA, file = "bootnet_centrality_stability_allBctsMotiSurveyPA.Rdata")
load("bootnet_centrality_stability_allBctsMotiSurveyPA.Rdata")

plot(bootnet_centrality_stability_allBctsMotiSurveyPA)
plot(bootnet_centrality_stability_allBctsMotiSurveyPA, perNode=T, "strength")

bootnet::corStability(bootnet_centrality_stability_allBctsMotiSurveyPA)

```

## Visually compare ggm and mgm

```{r pa-bct-motivation-compare-ggm-mgm}

layout_mgm_ggm <- qgraph::averageLayout(BCT_ggm, BCT_mgm)

layout(t(1:2))



plot(nwBCT_ggm, layout = layout_mgm_ggm, label.scale = FALSE, title = "GGM: PA, BCTs & motivation", label.cex = 0.75,
     pie = piefill_ggm, 
     color = "skyblue",
     pieBorder = 1)

qgraph::qgraph(mgm_obj$pairwise$wadj, 
            layout = layout_mgm_ggm,
            title = "MGM: PA, BCTs & motivation",
            edge.color = ifelse(mgm_obj$pairwise$edgecolor == "darkgreen", "blue", mgm_obj$pairwise$edgecolor),
            pie = pie_errors,
            pieColor = viridis::viridis(6, begin = 0.3, end = 0.8)[6],
            color = node_colors,
            labels = names(bctdf_mgm),
            label.cex = 0.75,
            label.scale = FALSE,
            theme = "colorblind")

```

## Correlation and partial correlation networks visualised

As we can see, the bivariate correlation network is uninterpretable due to high number of edges. 

```{r pa-bct-moti-compare-correlation-partialcorrelation}

corgraph <- qgraph::qgraph(qgraph::cor_auto(bctdf_ggm), graph = "cor",
                           repulsion = 0.99,
       labels = names(bctdf_ggm),
       edge.labels = TRUE,
       edge.label.cex = 0.75,
       label.scale = FALSE,
       layout = qgraph::averageLayout(BCT_mgm, BCT_mgm), # get the mgm layout 
       title = "bivariate correlation network",
       theme = "colorblind",
       label.cex = 0.75,
       pie = piefill_ggm,
       pieBorder = 1,
       color = "skyblue")


pcorgraph <- qgraph::qgraph(qgraph::cor_auto(bctdf_ggm), graph = "pcor",
                           repulsion = 0.99,
       labels = names(bctdf_ggm),
       edge.labels = TRUE,
       edge.label.cex = 0.75,
       label.scale = FALSE,
       layout = qgraph::averageLayout(BCT_mgm, BCT_mgm), # get the mgm layout 
       title = "Partial correlation network",
       theme = "colorblind",
       label.cex = 0.75,
       pie = piefill_ggm,
       pieBorder = 1,
       color = "skyblue")

```

## Correlation matrix visualised

```{r allBctsMotiSurveyPA-corrmatrix, results = "asis"}
# Create a covariance matrix of the data
covMatrix <- bctdf_ggm %>% cov(use = "pairwise.complete.obs")

# Transform the matrix so, that lower diagonal of the matrix shows partial correlations,
# while the upper one shows bivariate correlations.
matrix_corLower_parcorUpper <- covMatrix %>% ggm::correlations()

# Show the matrix
matrix_corLower_parcorUpper %>% papaja::apa_table(caption = "Correlation matrix of key variables of interest. Upper diagonal shows bivariate correlations, lower diagonal shows partial correlations")

labs <- names(bctdf_ggm)
# Plot the matrix as a correlogram
matrix_corLower_parcorUpper %>% corrgram::corrgram(
  type = "cor",
  lower.panel = corrgram::panel.pie,
  upper.panel = corrgram::panel.pie,
  outer.labels = list(bottom = list(labels = labs, cex = 0.75, srt = 30),
                      left = list(labels = labs, cex = 0.75, srt = 30)),
  main = "Bivariate (upper diagonal) and partial (lower diagonal)\ncorrelations of BCTs, motivation and self-reported PA")

corMatrix_BCTs <- bivariate_BCTs %>% cor(use = "pairwise.complete.obs", method = "spearman")

as.data.frame(as.table(corMatrix_BCTs)) %>% 
  dplyr::filter(Var1 == "PA accelerometer" | Var1 == "PA self report") %>% 
  dplyr::mutate("Spearman correlation" = Freq) %>% 
  dplyr::select(-Freq) %>% 
  dplyr::filter(`Spearman correlation` != 1) %>% 
  dplyr::arrange(desc(`Spearman correlation`)) %>% 
  papaja::apa_table(caption = "Bivariate correlations between BCTs, motivation and self-reported PA. Sorted by strength.")

```


# Ising networks

## Plot with only the BCTs

Prepare and dichotomise data (lots of skew in distributions).

```{r onlyAllBctsIsing-dataprep}
nItems <- 19

bctdf <- df %>% dplyr::select(id,
  intervention,
  group,
  school,
  girl,
  'goal setting' = PA_agrbct_01_T1,
  'implementation plan' = PA_agrbct_02_T1,
  'plan by other' = PA_agrbct_03_T1,
  'reminder of plan' = PA_agrbct_04_T1,
  'subgoals' = PA_agrbct_05_T1,
  'new PA options' = PA_agrbct_06_T1,
  'barrier identification' = PA_agrbct_07_T1,
  'coping planning' = PA_agrbct_08_T1,
  'PA identity' = PA_agrbct_09_T1,
  'PA life values' = PA_agrbct_10_T1,
  'positive consequences' = PA_frqbct_01_T1,
  'log on paper' = PA_frqbct_02_T1,
  'smartphone' = PA_frqbct_03_T1,
  'mnemonic cues' = PA_frqbct_04_T1,
  'goal contrast' = PA_frqbct_05_T1,
  'relevance of PA' = PA_frqbct_06_T1,
  'changes at home' = PA_frqbct_07_T1,
  'social support' = PA_frqbct_08_T1,
  'failure contemplated' = PA_frqbct_09_T1) %>%
 mutate(
  'goal setting' = ifelse(`goal setting` == 1, 0, 1),
  'implementation plan' = ifelse(`implementation plan` == 1, 0, 1),
  'plan by other' = ifelse(`plan by other` == 1, 0, 1),
  'reminder of plan' = ifelse(`reminder of plan` == 1, 0, 1),
  'subgoals' = ifelse(`subgoals` == 1, 0, 1),
  'new PA options' = ifelse(`new PA options` == 1, 0, 1),
  'barrier identification' = ifelse(`barrier identification` == 1, 0, 1),
  'coping planning' = ifelse(`coping planning` == 1, 0, 1),
  'PA identity' = ifelse(`PA identity` == 1, 0, 1),
  'PA life values' = ifelse(`PA life values` == 1, 0, 1),
  'positive consequences' = ifelse(`positive consequences` == 1, 0, 1),
  'log on paper' = ifelse(`log on paper` == 1, 0, 1),
  'smartphone' = ifelse(`smartphone` == 1, 0, 1),
  'mnemonic cues' = ifelse(`mnemonic cues` == 1, 0, 1),
  'goal contrast' = ifelse(`goal contrast` == 1, 0, 1),
  'relevance of PA' = ifelse(`relevance of PA` == 1, 0, 1),
  'changes at home' = ifelse(`changes at home` == 1, 0, 1),
  'social support' = ifelse(`social support` == 1, 0, 1),
  'failure contemplated' = ifelse(`failure contemplated` == 1, 0, 1)) %>% 
  data.frame

S.boys <- bctdf %>% filter(girl == "boy") %>% dplyr::select(6:ncol(bctdf)) %>% na.omit(.) 
S.girls <- bctdf %>% filter(girl == "girl") %>% dplyr::select(6:ncol(bctdf)) %>% na.omit(.)
nwBoys <- bootnet::estimateNetwork(S.boys, default="IsingFit")
nwGirls <- bootnet::estimateNetwork(S.girls, default="IsingFit")

# Create means for filling nodes

girlmeans <- bctdf %>% group_by(girl) %>% 
  summarise_at(vars(5:(5+nItems-1)),
  funs(mean(., na.rm = TRUE))) %>% 
  filter(girl == "girl") %>% 
  dplyr::select(-1)

boymeans <- bctdf %>% group_by(girl) %>% 
  summarise_at(vars(5:(5+nItems-1)),
  funs(mean(., na.rm = TRUE))) %>% 
  filter(girl == "boy") %>% 
  dplyr::select(-1)

```

## Plot BCT Ising-networks 

For girls and boys.

```{r onlyAllBctsIsing-girlsboys}

# Find average layout for comparability and plot graphs next to each other

Layout <- qgraph::averageLayout(nwGirls, nwBoys)

layout(t(1:2))

plot(nwGirls, layout = Layout, label.scale = FALSE, title = "Girls", label.cex = 0.75,
     pie = girlmeans, 
     color = "skyblue",
     pieBorder = 1)

plot(nwBoys, layout = Layout, label.scale = FALSE, title = "Boys", label.cex = 0.75, 
     pie = boymeans, 
     color = "skyblue",
     pieBorder = 1)

```

For all participants.

```{r onlyAllBctsIsing-allparticipants}

S.total <- bctdf %>% dplyr::select(6:ncol(bctdf))
nwBCT <- bootnet::estimateNetwork(S.total, default="IsingFit")

# smallworldIndex(plot(nwBCT))

# Create means for filling nodes
piefill <- S.total %>%
  summarise_all(funs(mean(., na.rm = TRUE))) 

# Plot network
plot(nwBCT, layout = "spring", label.scale = FALSE, title = "Ising fit", label.cex = 0.75,
     pie = piefill, 
     color = "skyblue",
     pieBorder = 1)

# Estimate ising network without regularisation
nwBCT_nonreg <- bootnet::estimateNetwork(S.total, default="IsingSampler")

plot(nwBCT_nonreg, layout = "spring", label.scale = FALSE, title = "Non-regularised Ising model", label.cex = 0.75,
     pie = piefill, 
     color = "skyblue",
     pieBorder = 1)
```




## Ising network Combined items 

```{r onlyCombinedBctsIsing-dataprep}
nItems <- 17

bctdf <- df %>% dplyr::select(id,
  intervention,
  group,
  school,
  girl,
  'goal setting' = PA_agrbct_01_T1,
  'implementation plan' = PA_agrbct_02_T1,
  'plan by other' = PA_agrbct_03_T1,
  'reminder of plan' = PA_agrbct_04_T1,
  'subgoals' = PA_agrbct_05_T1,
  'new PA options' = PA_agrbct_06_T1,
  'barrier identification' = PA_agrbct_07_T1,
  'coping planning' = PA_agrbct_08_T1,
  'PA identity' = PA_agrbct_09_T1,
  'PA life values' = PA_agrbct_10_T1,
  'positive consequences' = PA_frqbct_01_T1,
  'log on paper' = PA_frqbct_02_T1,
  'smartphone' = PA_frqbct_03_T1,
#  'mnemonic cues' = PA_frqbct_04_T1,
  'goal contrast' = PA_frqbct_05_T1,
  'relevance of PA' = PA_frqbct_06_T1,
  'changes at home' = PA_frqbct_07_T1,
  'social support' = PA_frqbct_08_T1,
  'failure contemplated' = PA_frqbct_09_T1) %>%
 mutate(
  'goal setting' = ifelse(`goal setting` == 1, 0, 1),
  'implementation plan' = ifelse(`implementation plan` == 1 & `plan by other` == 1, 0, 1),
  'reminder of plan' = ifelse(`reminder of plan` == 1, 0, 1),
  'subgoals' = ifelse(`subgoals` == 1, 0, 1),
  'new PA options' = ifelse(`new PA options` == 1, 0, 1),
  'barrier identification' = ifelse(`barrier identification` == 1, 0, 1),
  'coping planning' = ifelse(`coping planning` == 1, 0, 1),
  'PA identity' = ifelse(`PA identity` == 1, 0, 1),
  'PA life values' = ifelse(`PA life values` == 1, 0, 1),
  'positive consequences' = ifelse(`positive consequences` == 1, 0, 1),
  'monitored PA' = ifelse(`log on paper` == 1 & `smartphone` == 1, 0, 1),
#  'mnemonic cues' = ifelse(`mnemonic cues` == 1, 0, 1),
  'goal contrast' = ifelse(`goal contrast` == 1, 0, 1),
  'relevance of PA' = ifelse(`relevance of PA` == 1, 0, 1),
  'changes at home' = ifelse(`changes at home` == 1, 0, 1),
  'social support' = ifelse(`social support` == 1, 0, 1),
  'failure contemplated' = ifelse(`failure contemplated` == 1, 0, 1)) %>%
  dplyr::select(-`log on paper`, -`smartphone`, -`plan by other`) %>% 
  mutate_all(as.numeric)

# Network for all participants

S.total <- bctdf %>% dplyr::select(6:ncol(bctdf))
nwBCT <- bootnet::estimateNetwork(S.total, default="IsingFit")

# Create means for filling nodes
piefill <- S.total %>%
  summarise_all(funs(mean(., na.rm = TRUE))) 

# Plot network
plot(nwBCT, layout = "spring", label.scale = FALSE, title = "Ising fit", label.cex = 0.75,
     pie = piefill, 
     color = "skyblue",
     pieBorder = 1)

# # Estimate ising network without regularisation
# nwBCT_nonreg <- bootnet::estimateNetwork(S.total, default="IsingSampler")
# 
# plot(nwBCT_nonreg, layout = "spring", label.scale = FALSE, title = "Non-regularised Ising model", label.cex = 0.75,
#      pie = piefill, 
#      color = "skyblue",
#      pieBorder = 1)
```

#### Centrality and stability

```{r onlyCombinedBctsIsing-stability, cache = TRUE}

onlyCombinedBctsIsing <- nwBCT_ggm

onlyCombinedBctsIsing_centralityPlot <- qgraph::centralityPlot(onlyCombinedBctsIsing)

qgraph::centrality(onlyCombinedBctsIsing)$InDegree
scale(qgraph::centrality(onlyCombinedBctsIsing)$InDegree)
qgraph::centrality(onlyCombinedBctsIsing)$Closeness
qgraph::centrality(onlyCombinedBctsIsing)$Betweenness

cor(qgraph::centrality(onlyCombinedBctsIsing)$InDegree, qgraph::centrality(onlyCombinedBctsIsing)$Betweenness, 
    method = "spearman") 

# bootnet_stability_onlyCombinedBctsIsing <- bootnet::bootnet(onlyCombinedBctsIsing, nBoots=1000)
# save(bootnet_stability_onlyCombinedBctsIsing, file = "bootnet_stability_onlyCombinedBctsIsing.Rdata")
load("bootnet_stability_onlyCombinedBctsIsing.Rdata")

plot(bootnet_stability_onlyCombinedBctsIsing, labels = FALSE, order = "sample") 
plot(bootnet_stability_onlyCombinedBctsIsing, labels = FALSE, "edge", plot = "difference", onlyNonZero = TRUE, order = "sample")

# bootnet_centrality_stability_onlyCombinedBctsIsing <- bootnet::bootnet(onlyCombinedBctsIsing, nBoots=1000,nCores=8, type="case")
# save(bootnet_centrality_stability_onlyCombinedBctsIsing, file = "bootnet_centrality_stability_onlyCombinedBctsIsing.Rdata")
load("bootnet_centrality_stability_onlyCombinedBctsIsing.Rdata")

plot(bootnet_centrality_stability_onlyCombinedBctsIsing)
plot(bootnet_centrality_stability_onlyCombinedBctsIsing, perNode=T, "strength")

bootnet::corStability(bootnet_centrality_stability_onlyCombinedBctsIsing)

```

#### Network comparison test: boys vs. girls

```{r nctboysgirls, eval = FALSE, cache = TRUE, results = "asis"}

nct_results <- NetworkComparisonTest::NCT(nwGirls, nwBoys, it=1000, binary.data=TRUE, paired=FALSE, test.edges=TRUE, edges='all', progressbar=TRUE)

nct_results$nwinv.pval  # p value of network structure diff test: 0.424
nct_results$glstrinv.pval  # p value of global connectivity diff test: 0.071
nct_results$einv.pvals     #p values testing diffs for all individual edges: lowest p-value 0.017, most = 1
sum(nct_results$einv.pvals$"p-value" < 0.05)  # how many edges are different0


```

### GGM BCTs & motivation 

```{r bct-moti-ggm}
library(corrgram)

nItems <- 19

bctdf <- df %>% dplyr::select(id,
  intervention,
  group,
  school,
  girl,
  'Autonomous' = PA_autonomous_T1,
  'Controlled' = PA_controlled_T1,
  'goal setting' = PA_agrbct_01_T1,
  'implementation plan' = PA_agrbct_02_T1,
  'plan by other' = PA_agrbct_03_T1,
  'reminder of plan' = PA_agrbct_04_T1,
  'subgoals' = PA_agrbct_05_T1,
  'new PA options' = PA_agrbct_06_T1,
  'barrier identification' = PA_agrbct_07_T1,
  'coping planning' = PA_agrbct_08_T1,
  'PA identity' = PA_agrbct_09_T1,
  'PA life values' = PA_agrbct_10_T1,
  'positive consequences' = PA_frqbct_01_T1,
  'log on paper' = PA_frqbct_02_T1,
  'smartphone' = PA_frqbct_03_T1,
#  'mnemonic cues' = PA_frqbct_04_T1,
  'goal contrast' = PA_frqbct_05_T1,
  'relevance of PA' = PA_frqbct_06_T1,
  'changes at home' = PA_frqbct_07_T1,
  'social support' = PA_frqbct_08_T1,
  'failure contemplated' = PA_frqbct_09_T1) %>%
  rowwise() %>% 
  mutate( 
  #'has plan' = mean(c(`implementation plan`, `plan by other`), na.rm = TRUE),
  'monitored PA' = mean(c(`log on paper`, `smartphone`), na.rm = TRUE)) %>%
  dplyr::select(-`log on paper`, -`smartphone`) %>%
  mutate_all(as.numeric)

# Network for all participants

S.total <- bctdf %>% dplyr::select(`Autonomous`:ncol(bctdf))
nwBCT <- bootnet::estimateNetwork(S.total, default="EBICglasso")

# Plot correlations (minmax crowds the diagonal as it plots the minimum and maximum values for each variable).
labs <- colnames(S.total)
corrgram::corrgram(S.total, 
         cor.method = "spearman", 
         # diag.panel=panel.minmax, 
         # lower.panel=panel.shade, 
         # lower.panel=panel.ellipse,
         # lower.panel=panel.cor,
         upper.panel=corrgram::panel.conf,
         lower.panel=corrgram::panel.conf,
         outer.labels=list(
           bottom=list(labels=labs,cex=.75, srt=60),
           left=list(labels=labs,cex=.75, srt=30))
         )

# Create means for filling nodes
piefill <- S.total %>%
  dplyr::select(-Autonomous, -Controlled) %>%
  data.frame() %>% 
  summarise_all(funs(mean(., na.rm = TRUE) / 6)) 

piefill$Autonomous <- median(S.total$Autonomous, na.rm = TRUE) / 5
piefill$Controlled <- median(S.total$Controlled, na.rm = TRUE) / 5

piefill <- piefill %>% select(Autonomous, Controlled, everything())

# Plot network
plot(nwBCT, layout = "spring", label.scale = FALSE, title = "GGM, BCTs & motivation", label.cex = 0.75,
     pie = piefill, 
     color = "skyblue",
     pieBorder = 1)

# Combine items further:
bctdf2 <- bctdf %>% rowwise %>% 
  dplyr::mutate('goals and plans' = mean(c(`goal setting`, `implementation plan`), na.rm = TRUE)) %>% 
  dplyr::mutate('barriers identified\nand planned for' = mean(c(`barrier identification`, `coping planning`), na.rm = TRUE)) %>% 
  dplyr::select(-`goal setting`, -`implementation plan`, -`barrier identification`, -`coping planning`) %>% 
  data.frame

S.total2 <- bctdf2 %>% dplyr::select(`Autonomous`:ncol(bctdf2))
nwBCT2 <- bootnet::estimateNetwork(S.total2, default="EBICglasso")

# Create means for filling nodes
piefill2 <- S.total2 %>%
  dplyr::select(-Autonomous, -Controlled) %>%
  data.frame() %>% 
  summarise_all(funs(mean(., na.rm = TRUE) / 6)) 

piefill2$Autonomous <- median(S.total$Autonomous, na.rm = TRUE) / 5
piefill2$Controlled <- median(S.total$Controlled, na.rm = TRUE) / 5

piefill2 <- piefill2 %>% select(Autonomous, Controlled, everything())

# Plot network
plot(nwBCT2, layout = "spring", label.scale = FALSE, title = "GGM, BCTs & motivation", label.cex = 0.75,
     pie = piefill2, 
     color = "skyblue",
     pieBorder = 1)

```



#### Stability and robustness

Robustness test 

```{r bct-robustness}

qgraph::centralityPlot(nwBCT)
qgraph::centralityPlot(nwBCT2)

# BCTboot1 <- bootnet::bootnet(nwBCT, nBoots = 2500)
# BCTboot2 <- bootnet::bootnet(nwBCT2, nBoots = 2500)
# save(BCTboot1, file = "BCTboot1.Rdata")
# save(BCTboot2, file = "BCTboot2.Rdata")

load("BCTboot1.Rdata")
load("BCTboot2.Rdata")

plot(BCTboot1, labels = TRUE, order = "sample")

plot(BCTboot2, labels = TRUE, order = "sample")

autEdges <- summary(BCTboot1, statistics = "edge", rank = TRUE) %>% 
  dplyr::arrange(mean) %>% 
  dplyr::filter(stringr::str_detect(node1, 'Autonomous')) %>% # str_detect(id, 'Autonomous|Controlled') for both
  dplyr::filter(!(node2 == 'Controlled')) %>% 
  data.frame() %>% 
  dplyr::select(CIlower, mean, CIupper, node2)

contEdges <- summary(BCTboot1, statistics = "edge", rank = TRUE) %>% 
  dplyr::arrange(mean) %>% 
  dplyr::filter(stringr::str_detect(node1, 'Controlled')) %>% # str_detect(id, 'Autonomous|Controlled') for both
  data.frame() %>% 
  dplyr::select(CIlower, mean, CIupper, node2)

userfriendlyscience::diamondPlot(autEdges, 
            ciCols = c("CIlower", "mean", "CIupper"), 
            color = viridis::viridis(2, end = 0.8)[1], 
            alpha = 0.3, 
            yLabels = autEdges$node2, 
            fixedSize = 0.3, 
            xlab = NULL) +
  userfriendlyscience::diamondPlot(contEdges, 
              ciCols = c("CIlower", "mean", "CIupper"), 
              color = viridis::viridis(2, end = 0.8)[2], 
              alpha = 0.3, 
              yLabels = autEdges$node2, 
              fixedSize = 0.3, 
              xlab = NULL, 
              returnLayerOnly = TRUE) +
  geom_rect(aes(xmin=Inf, xmax=Inf, ymin=Inf, ymax=Inf, fill = "Controlled"), 
            colour=NA, alpha=0.05) + # Create invisible rectangle for legend
  geom_rect(aes(xmin=Inf, xmax=Inf, ymin=Inf, ymax=Inf, fill = "Autonomous"), 
            colour=NA, alpha=0.05) + # Create invisible rectangle for legend
  scale_fill_manual('Connected node',
                      values = viridis::viridis(2, end = 0.8)[1:2],  
                      guide = guide_legend(override.aes = list(alpha = 1))) +
  ggtitle("Relative strengths of edges containing autonomous \nor controlled motivation (all items)")
  
# Combined items

autEdges <- summary(BCTboot2, statistics = "edge", rank = TRUE) %>% 
  dplyr::arrange(mean) %>% 
  dplyr::filter(stringr::str_detect(node1, 'Autonomous')) %>% # str_detect(id, 'Autonomous|Controlled') for both
  dplyr::filter(!(node2 == 'Controlled')) %>% 
  data.frame() %>% 
  dplyr::select(CIlower, mean, CIupper, node2)

contEdges <- summary(BCTboot2, statistics = "edge", rank = TRUE) %>% 
  dplyr::arrange(mean) %>% 
  dplyr::filter(stringr::str_detect(node1, 'Controlled')) %>% # str_detect(id, 'Autonomous|Controlled') for both
  data.frame() %>% 
  dplyr::select(CIlower, mean, CIupper, node2)

userfriendlyscience::diamondPlot(autEdges, 
            ciCols = c("CIlower", "mean", "CIupper"), 
            color = viridis::viridis(2, end = 0.8)[1], 
            alpha = 0.3, 
            yLabels = autEdges$node2, 
            fixedSize = 0.3, 
            xlab = NULL) +
  userfriendlyscience::diamondPlot(contEdges, 
              ciCols = c("CIlower", "mean", "CIupper"), 
              color = viridis::viridis(2, end = 0.8)[2], 
              alpha = 0.3, 
              yLabels = autEdges$node2, 
              fixedSize = 0.3, 
              xlab = NULL, 
              returnLayerOnly = TRUE) +
  geom_rect(aes(xmin=Inf, xmax=Inf, ymin=Inf, ymax=Inf, fill = "Controlled"), 
            colour=NA, alpha=0.05) + # Create invisible rectangle for legend
  geom_rect(aes(xmin=Inf, xmax=Inf, ymin=Inf, ymax=Inf, fill = "Autonomous"), 
            colour=NA, alpha=0.05) + # Create invisible rectangle for legend
  scale_fill_manual('Connected node',
                      values = viridis::viridis(2, end = 0.8)[1:2],  
                      guide = guide_legend(override.aes = list(alpha = 1))) +
  ggtitle("Relative strengths of edges containing autonomous \nor controlled motivation (combined items)")

# summary(BCTboot1, statistics = "edge", rank = TRUE) %>% 
#   dplyr::arrange(mean) %>% 
#   dplyr::filter(stringr::str_detect(id, 'Controlled')) %>%
#   data.frame() %>% 
#   dplyr::select(CIlower, mean, CIupper, id) %>% 
#   userfriendlyscience::diamondPlot(ciCols = c("CIlower", "mean", "CIupper"), ylabels = id)

```

#### Add PA

```{r bct-pa-motivation-ggm}

nItems_PA <- 20

bctdf_PA <- df %>% dplyr::select(id,
  intervention,
  group,
  school,
  girl,
  'MVPA' = paAccelerometer_T1,
  'Autonomous' = PA_autonomous_T1,
  'Controlled' = PA_controlled_T1,
  'goal setting' = PA_agrbct_01_T1,
  'implementation plan' = PA_agrbct_02_T1,
  'plan by other' = PA_agrbct_03_T1,
  'reminder of plan' = PA_agrbct_04_T1,
  'subgoals' = PA_agrbct_05_T1,
  'new PA options' = PA_agrbct_06_T1,
  'barrier identification' = PA_agrbct_07_T1,
  'coping planning' = PA_agrbct_08_T1,
  'PA identity' = PA_agrbct_09_T1,
  'PA life values' = PA_agrbct_10_T1,
  'positive consequences' = PA_frqbct_01_T1,
  'log on paper' = PA_frqbct_02_T1,
  'smartphone' = PA_frqbct_03_T1,
#  'mnemonic cues' = PA_frqbct_04_T1,
  'goal contrast' = PA_frqbct_05_T1,
  'relevance of PA' = PA_frqbct_06_T1,
  'changes at home' = PA_frqbct_07_T1,
  'social support' = PA_frqbct_08_T1,
  'failure contemplated' = PA_frqbct_09_T1) %>%
  rowwise() %>% 
  mutate( 
  #'has plan' = mean(c(`implementation plan`, `plan by other`), na.rm = TRUE),
  'monitored PA' = mean(c(`log on paper`, `smartphone`), na.rm = TRUE)) %>%
  dplyr::select(-`log on paper`, -`smartphone`) %>% 
  data.frame %>% 
  mutate_all(as.numeric)

# Network for all participants

S.total_PA <- bctdf_PA %>% dplyr::select(`MVPA`:ncol(bctdf_PA))
nwBCT_PA <- bootnet::estimateNetwork(S.total_PA, default="EBICglasso")

labs <- colnames(S.total_PA)

# Create means for filling nodes
piefill <- S.total_PA %>% 
    mutate(Autonomous = Autonomous * 6/5, # Transform these from scale 1-5 to 1-6
         Controlled = Controlled * 6/5) %>% 
  dplyr::select(-contains("MVPA")) %>% 
  summarise_all(funs(median(., na.rm = TRUE) / 6)) 

piefill$MVPA <- median(S.total_PA$MVPA, na.rm = TRUE) / (60*24) 

piefill <- piefill %>% dplyr::select(MVPA, everything())

# Plot network
plot(nwBCT_PA, layout = "spring", label.scale = FALSE, title = "GGM: PA, BCTs & motivation", label.cex = 0.75,
     pie = piefill, 
     color = "skyblue",
     pieBorder = 1)

# Combine items further:
bctdf_PA2 <- bctdf_PA %>% rowwise %>% 
  mutate('goals and plans' = mean(c(`goal.setting`, `implementation.plan`), na.rm = TRUE)) %>% 
  mutate('barriers identified\nand planned for' = mean(c(`barrier.identification`, `coping.planning`), na.rm = TRUE)) %>% 
  dplyr::select(-`goal.setting`, -`implementation.plan`, -`barrier.identification`, -`coping.planning`) %>% 
  data.frame

S.total_PA2 <- bctdf_PA2 %>% dplyr::select(MVPA:ncol(bctdf_PA2))
nwBCT_PA2 <- bootnet::estimateNetwork(S.total_PA2, default="EBICglasso")

# Create means for filling nodes
piefill_PA2 <- S.total_PA2 %>% 
  dplyr::select(-contains("MVPA")) %>%
  mutate(Autonomous = Autonomous * 6/5, # Transform these from scale 1-5 to 1-6
         Controlled = Controlled * 6/5) %>% 
  summarise_all(funs(median(., na.rm = TRUE) / 6)) 

piefill_PA2$MVPA <- median(S.total_PA2$MVPA, na.rm = TRUE) / (60*24) 

piefill_PA2 <- piefill_PA2 %>% dplyr::select(MVPA, everything())


# Plot network
plot(nwBCT_PA2, layout = "spring", label.scale = FALSE, title = "GGM: PA BCTs & motivation", label.cex = 0.75,
     pie = piefill_PA2, 
     color = "skyblue",
     pieBorder = 1)


```



## Demonstrating the Ising network

... in PA, autonomous motivation, and top-5 BCTs

Variables are binarised:
* If one reports not using the BCT, they get a zero, otherwise a 1
* If one reports not having done no MVPA during the last week, they get a zero, otherwise a 1
* On the autonomous motivation sum score, if one reports lower agreement than 3 (indicating "sometimes true for me") on average, they get a zero, otherwise a 1

We include the top 5 BCTs according to their bivariate Spearman correlations with self-reported PA. Self-report instead of accelerometer due to higher sample size and accounting for e.g. gym.

1. I have tried out new ways for me to be physically active.
2. I have personally made a specific plan ("what, where, how") to implement my PA.
3. I have a PA plan, which has been made by someone else, e.g. my sports club (e.g. a workout schedule).
4. I have set PA goals for myself.
5. I have broken down larger PA goals to smaller subgoals.

When a person has tried out a new PA way to be physically active, they have almost (because question time scales don't overlap completely) by definition done MVPA lately. Therefore, we substitute this with:

6. I have compared my actualized PA with the PA goal I have set.

```{r ising-demo-pa-autmot-top5bcts}


top5Bcts_df <- df %>% dplyr::select(
  MVPA = padaysLastweek_T1,
  Autonomous = PA_autonomous_T1, 
  'goal contrast' = PA_frqbct_05_T1,
  'implementation plan' = PA_agrbct_02_T1,
  'plan by other' = PA_agrbct_03_T1,
  'goal setting' = PA_agrbct_01_T1,
  'subgoals' = PA_agrbct_05_T1) %>% 
 mutate(
  'MVPA' = ifelse(`MVPA` == 0, 0, 1),
  'Autonomous' = ifelse(`Autonomous` < 3, 0, 1),
  'goal contrast' = ifelse(`goal contrast` == 1, 0, 1),
  'implementation plan' = ifelse(`implementation plan` == 1, 0, 1),
  'plan by other' = ifelse(`plan by other` == 1, 0, 1),
  'goal setting' = ifelse(`goal setting` == 1, 0, 1),
  'subgoals' = ifelse(`subgoals` == 1, 0, 1))  

allMeans <- top5Bcts_df %>%
  summarise_all(funs(mean(., na.rm = TRUE))) 

network_all <- bootnet::estimateNetwork(top5Bcts_df, default="IsingFit")

graph_cor <- qgraph::qgraph(qgraph::cor_auto(top5Bcts_df), graph = "cor", layout="spring", cut=0, 
                  label.scale = FALSE, edge.labels = TRUE, labels = names(top5Bcts_df),
                  pie = allMeans, pieBorder = 1, title = "Bivariate correlations")
graph_Ising <- plot(network_all, layout="spring", cut=0, label.scale = FALSE,
                  pie = allMeans, pieBorder = 1, title = "Ising model")

# maxedge <- max(c(graph_Ising$graphAttributes$Graph$maximum, 
#                  graph_cor$graphAttributes$Graph$maximum))

L <- qgraph::averageLayout(graph_cor, graph_Ising)

layout(matrix(1:2, nrow = 1, byrow = TRUE))
graph_cor <- qgraph::qgraph(qgraph::cor_auto(top5Bcts_df), graph = "cor", layout=L, cut=0, 
                  label.scale = FALSE, edge.labels = TRUE, labels = names(top5Bcts_df), label.cex = 0.8,
                  pie = allMeans, pieBorder = 1, title = "Bivariate correlations")
graph_Ising <- plot(network_all, layout=L, cut=0, label.scale = FALSE,
                  pie = allMeans, pieBorder = 1, title = "Ising model", label.cex = 0.8)

```

Centrality and stability:

```{r top5Bcts-stability}
Ising_centralityPlot <- qgraph::centralityPlot(graph_Ising)

qgraph::centrality(graph_Ising)$InDegree
scale(qgraph::centrality(graph_Ising)$InDegree)
qgraph::centrality(graph_Ising)$Closeness
qgraph::centrality(graph_Ising)$Betweenness

cor(qgraph::centrality(graph_Ising)$InDegree, qgraph::centrality(graph_Ising)$Betweenness, 
    method = "spearman") 

# bootnet_stability_top5Bcts <- bootnet::bootnet(network_all, nBoots=1000)
# save(bootnet_stability_top5Bcts, file = "bootnet_stability_top5Bcts.Rdata")
load("bootnet_stability_top5Bcts.Rdata")

plot(bootnet_stability_top5Bcts, labels = TRUE, order = "sample") 
plot(bootnet_stability_top5Bcts, "edge", plot = "difference", onlyNonZero = TRUE, order = "sample")

# bootnet_centrality_stability_top5Bcts <- bootnet::bootnet(network_all, nBoots=1000,nCores=8, type="case")
# save(bootnet_centrality_stability_top5Bcts, file = "bootnet_centrality_stability_top5Bcts.Rdata")
load("bootnet_centrality_stability_top5Bcts.Rdata")

plot(bootnet_centrality_stability_top5Bcts)
plot(bootnet_centrality_stability_top5Bcts, perNode=T, "strength")

bootnet::corStability(bootnet_centrality_stability_top5Bcts) 

```

### Heterogeneity check

```{r top5Bcts-heterogeneity}

top5Bcts_tracks_df <- df %>% dplyr::select(
  track,
  PA = padaysLastweek_T1,
  Autonomous = PA_autonomous_T1, 
  'new PA options' = PA_agrbct_06_T1,
  'implementation plan' = PA_agrbct_02_T1,
  'plan by other' = PA_agrbct_03_T1,
  'goal setting' = PA_agrbct_01_T1,
  'subgoals' = PA_agrbct_05_T1) %>% 
 mutate(
  'PA' = ifelse(`PA` == 0, 0, 1),
  'Autonomous' = ifelse(`Autonomous` < 3, 0, 1),
  'new PA options' = ifelse(`new PA options` == 1, 0, 1),
  'implementation plan' = ifelse(`implementation plan` == 1, 0, 1),
  'plan by other' = ifelse(`plan by other` == 1, 0, 1),
  'goal setting' = ifelse(`goal setting` == 1, 0, 1),
  'subgoals' = ifelse(`subgoals` == 1, 0, 1))

heterogeneity_Nur <- top5Bcts_tracks_df %>% 
  dplyr::filter(track == "Nur") %>% 
  dplyr::select(-track)
NurMeans <- heterogeneity_Nur %>%
  summarise_all(funs(mean(., na.rm = TRUE))) 

heterogeneity_HRC <- top5Bcts_tracks_df %>%
  dplyr::filter(track == "HRC") %>% 
  dplyr::select(-track)
HRCMeans <- heterogeneity_HRC %>%
  summarise_all(funs(mean(., na.rm = TRUE))) 

heterogeneity_BA <- top5Bcts_tracks_df %>% 
  dplyr::filter(track == "BA") %>% 
  dplyr::select(-track)
BAMeans <- heterogeneity_BA %>%
  summarise_all(funs(mean(., na.rm = TRUE))) 

heterogeneity_IT <- top5Bcts_tracks_df %>% 
  dplyr::filter(track == "IT") %>% 
  dplyr::select(-track)
ITMeans <- heterogeneity_IT %>%
  summarise_all(funs(mean(., na.rm = TRUE))) 

network_Nur <- bootnet::estimateNetwork(heterogeneity_Nur, default="IsingFit")
network_HRC <- bootnet::estimateNetwork(heterogeneity_HRC, default="IsingFit")
network_BA <- bootnet::estimateNetwork(heterogeneity_BA, default="IsingFit")
network_IT <- bootnet::estimateNetwork(heterogeneity_IT, default="IsingFit")

graph_Nur <- plot(network_Nur, layout="spring", cut=0, label.scale = FALSE,
                  pie = NurMeans, pieBorder = 1)
graph_HRC <- plot(network_HRC, layout="spring", cut=0, label.scale = FALSE,
                  pie = HRCMeans, pieBorder = 1)
graph_BA <- plot(network_BA, layout="spring", cut=0, label.scale = FALSE,
                  pie = BAMeans, pieBorder = 1)
graph_IT <- plot(network_IT, layout="spring", cut=0, label.scale = FALSE,
                  pie = ITMeans, pieBorder = 1)

maxedge <- max(c(graph_Nur$graphAttributes$Graph$maximum, 
                 graph_HRC$graphAttributes$Graph$maximum, 
                 graph_BA$graphAttributes$Graph$maximum, 
                 graph_IT$graphAttributes$Graph$maximum))

L <- qgraph::averageLayout(graph_Nur, graph_HRC, graph_BA, graph_IT)

layout(matrix(1:4, nrow = 2, byrow = TRUE))
graph_Nur <- plot(network_Nur, layout=L, cut=0, label.scale = FALSE, title = "Practical nurse", 
                  maximum = maxedge, pie = NurMeans, pieBorder = 1)
graph_HRC <- plot(network_HRC, layout=L, cut=0, label.scale = FALSE, title = "HRC",
                  maximum = maxedge, pie = HRCMeans, pieBorder = 1)
graph_BA <- plot(network_BA, layout=L, cut=0, label.scale = FALSE, title = "BA", 
                 maximum = maxedge, pie = BAMeans, pieBorder = 1)
graph_IT <- plot(network_IT, layout=L, cut=0, label.scale = FALSE, title = "IT",
                 maximum = maxedge, pie = ITMeans, pieBorder = 1)

### similarity: statistical
cor(qgraph::centrality(network_Nur)$InDegree, qgraph::centrality(network_IT)$InDegree)

cor(network_Nur$graph[lower.tri(network_Nur$graph)], network_IT$graph[lower.tri(network_Nur$graph)], method="spearman")

### difference: statistical
# nct_results_top5Bcts <- NetworkComparisonTest::NCT(heterogeneity_Nur, heterogeneity_IT, it=1000, binary.data=FALSE, paired=FALSE, test.edges=TRUE,
# edges='all', progressbar=TRUE)

# save(nct_results_top5Bcts, file="nct_results_top5Bcts.Rdata")
# alternatively, load 
load("nct_results_top5Bcts.Rdata")

```

```{r top5bcts-nct-results, results = "asis"}

top5Bcts_tracks_df %>% dplyr::group_by(track) %>% summarise(n = n()) %>% 
  papaja::apa_table()

nct_results_top5Bcts$nwinv.pval
nct_results_top5Bcts$glstrinv.pval
nct_results_top5Bcts$einv.pvals
sum(nct_results_top5Bcts$einv.pvals$"p-value" < 0.05)


```

# BCT-SDT Regression analyses

Here's the classical linear model.

```{r bct-sdt-regression, results = "asis"}

bctdf <- df %>% dplyr::select(id,
  intervention,
  group,
  school,
  girl,
  'Autonomous' = PA_autonomous_T1,
  'Controlled' = PA_controlled_T1,
  'Intrinsic' = PA_intrinsic_T1,
  'Identified' = PA_identified_T1,
  'Integrated' = PA_integrated_T1,
  'Introjected' = PA_introjected_T1,
  'Extrinsic' = PA_extrinsic_T1,
  'goal setting' = PA_agrbct_01_T1,
  'implementation plan' = PA_agrbct_02_T1,
  'plan by other' = PA_agrbct_03_T1,
  'reminder of plan' = PA_agrbct_04_T1,
  'subgoals' = PA_agrbct_05_T1,
  'new PA options' = PA_agrbct_06_T1,
  'barrier identification' = PA_agrbct_07_T1,
  'coping planning' = PA_agrbct_08_T1,
  'PA identity' = PA_agrbct_09_T1,
  'PA life values' = PA_agrbct_10_T1,
  'positive consequences' = PA_frqbct_01_T1,
  'log on paper' = PA_frqbct_02_T1,
  'smartphone' = PA_frqbct_03_T1,
#  'mnemonic cues' = PA_frqbct_04_T1,
  'goal contrast' = PA_frqbct_05_T1,
  'relevance of PA' = PA_frqbct_06_T1,
  'changes at home' = PA_frqbct_07_T1,
  'social support' = PA_frqbct_08_T1,
  'failure contemplated' = PA_frqbct_09_T1) %>%
  rowwise() %>% 
  mutate( 
  #'has plan' = mean(c(`implementation plan`, `plan by other`), na.rm = TRUE),
  'monitored PA' = mean(c(`log on paper`, `smartphone`), na.rm = TRUE)) %>%
  dplyr::select(-`log on paper`, -`smartphone`) %>% 
  data.frame # %>% 
  # mutate_all(as.numeric)

outcomevars <- c('Autonomous', 
  'Controlled', 
  'Intrinsic',
  'Identified', 
  'Integrated', 
  'Introjected',
  'Extrinsic')

for (i in outcomevars) {
m <- lm(paste0(i, " ~ 
  goal.setting +
  implementation.plan +
  plan.by.other +
  reminder.of.plan +
  subgoals +
  new.PA.options +
  barrier.identification +
  coping.planning +
  PA.identity +
  PA.life.values +
  positive.consequences"), 
  data = bctdf)

cat("\n\nEstimates for", i, "regulation", sep = " ")
summary(m) %>% broom::tidy() %>% dplyr::arrange(desc(estimate)) %>% papaja::apa_table() 
}


```

# PA determinants: unregularised correlations visualised

```{r pa-determinants-correlations-raw}
# Network without motivation variables
data <- df %>% dplyr::select('PA' = paAccelerometer_T1, 'SB' = sitLieAccelerometer_T1,
'fat%' = fatpct_T1,'action planning' = PA_actionplan_T1, 'coping planning' = PA_copingplan_T1, 'frequency-related BCTs' = PA_frqbct_T1, 'agreement-related BCTs' = PA_agrbct_T1, 'amotivation' = PA_amotivation_T1, 'autonomous motivation' = PA_autonomous_T1, 'controlled motivation' = PA_controlled_T1, 'descriptive norm' = PA_dnorm_T1, 'injunctive norm' = PA_inorm_T1, 'intention' = PA_intention_T1, 'outcome expectations' = PA_outcomeExpectations_T1, 'self-efficacy / PBC' = PA_sePbc_T1, 'perceived opportunities' = PA_opportunities_T1) %>% 
  mutate_all(as.numeric)

names <- df %>% dplyr::select('PA' = paAccelerometer_T1, 'SB' = sitLieAccelerometer_T1,
'fat%' = fatpct_T1,'action planning' = PA_actionplan_T1, 'coping planning' = PA_copingplan_T1, 'frequency-related BCTs' = PA_frqbct_T1, 'agreement-related BCTs' = PA_agrbct_T1, 'amotivation' = PA_amotivation_T1, 'autonomous motivation' = PA_autonomous_T1, 'controlled motivation' = PA_controlled_T1, 'descriptive norm' = PA_dnorm_T1, 'injunctive norm' = PA_inorm_T1, 'intention' = PA_intention_T1, 'outcome expectations' = PA_outcomeExpectations_T1, 'self-efficacy / PBC' = PA_sePbc_T1, 'perceived opportunities' = PA_opportunities_T1) %>% names

# Spinglass algorithm detects communities. Tutorial here: http://psych-networks.com/r-tutorial-identify-communities-items-networks/

cormatrix <- cor_auto(data) 

piefill <- data %>%
  summarise_all(funs(mean(., na.rm = TRUE))) %>% 
  mutate_at(vars(PA, SB),
            funs(. / (24*60))) %>% # proportion of day used doing the behaviour
  mutate_at(vars(`action planning`, `coping planning`),
            funs(. / 4)) %>% 
  mutate_at(vars(6:ncol(data)),
            funs(. / 7)) %>% 
  mutate_at(vars(`fat%`),
            funs(. / 100))  

nodeColors <- c(rep(viridis::viridis(7, begin = 0.3, end = 1)[1], 2), # PA, SB
                rep(viridis::viridis(7, begin = 0.3, end = 1)[2], 1), # fat
                rep(viridis::viridis(7, begin = 0.3, end = 1)[3], 2), # Action, coping planning
                rep(viridis::viridis(7, begin = 0.3, end = 1)[4], 2), # 2x bcts
                rep(viridis::viridis(7, begin = 0.3, end = 1)[5], 3), # Motivations
                rep(viridis::viridis(7, begin = 0.3, end = 1)[6], 2), # norms
                rep(viridis::viridis(7, begin = 0.3, end = 1)[7], 1), # intention
                rep(viridis::viridis(7, begin = 0.3, end = 1)[6], 3)) # OE, SE/PBC, Opportunities


qgraph(cor_auto(data), layout = "spring", labels = TRUE, 
       # groups = group.spinglass, 
     color=nodeColors,
     label.cex = 0.75,
     label.scale = TRUE,
     pie = piefill, 
     color = "skyblue",
     nodeNames = names,
     pieBorder = 1,
     legend.cex = 0.4,
     theme = "colorblind",
     edge.labels = TRUE,
     edge.label.cex = 0.75,
     minimum = 0.1,
     title = "Bivariate correlations of PA determinants (<0.1 not shown)")


```

<!-- Out of a hundred iterations, spinglass algorithm found `  table(matrix_spinglass)[[1]]` instances of ` table(matrix_spinglass)[1] %>% names` communities, `  table(matrix_spinglass)[[2]]` instances of `  table(matrix_spinglass)[2] %>% names` communities, and `  table(matrix_spinglass)[[3]]` instances of `  table(matrix_spinglass)[3] %>% names` communities. Thus, a random seed which found four communities was chosen.   -->

## Symptom network: all

```{r symptoms-all}

sympdf <- df %>% dplyr::select(id,
  intervention,
  group,
  school,
  girl,
  "Neck and shoulder pain" = symptom_neckShoulderPain_T1,
  "Lower back pain" = symptom_lowerBackPain_T1,
  "Stomach ache" = symptom_stomachAche_T1,
  "Tension or nervousness" = symptom_tensionNervousness_T1,
  "Irritability or anger bursts" = symptom_irritabilityAngerbursts_T1,
  "Difficulty with sleep" = symptom_sleepDifficulty_T1,
  "Headache" = symptom_headAche_T1,
  "Tiredness or faintness" = symptom_tirednessFaintness_T1,
  "Fat pct" = fatpct_T1,
  "PA" = paAccelerometer_T1,
  "SB" = sitLieAccelerometer_T1
) %>% 
  mutate(
    'Neck and shoulder pain' = ifelse(`Neck and shoulder pain` == 1, 0, 1),
    'Lower back pain' = ifelse(`Lower back pain` == 1, 0, 1),
    'Stomach ache' = ifelse(`Stomach ache` == 1, 0, 1),
    'Tension or nervousness' = ifelse(`Tension or nervousness` == 1, 0, 1),
    'Irritability or anger bursts' = ifelse(`Irritability or anger bursts` == 1, 0, 1),
    'Difficulty with sleep' = ifelse(`Difficulty with sleep` == 1, 0, 1),
    'Headache' = ifelse(`Headache` == 1, 0, 1),
    'Tiredness or faintness' = ifelse(`Tiredness or faintness` == 1, 0, 1),
    'Fat pct' = `Fat pct` / 100) %>% 
  data.frame

S.all <- sympdf %>% dplyr::select(6:ncol(sympdf)) %>% na.omit(.) 

nwAll <- bootnet::estimateNetwork(S.all, default="mgm")

allmeans <- sympdf %>%  
  summarise_at(vars(6:16),
  funs(mean(., na.rm = TRUE))) %>%  
  mutate_at(vars(PA, SB),
            funs(. / (24*60)))  # proportion of day used doing the behaviour


plot(nwAll, label.scale = FALSE, title = "All", label.cex = 0.75, 
     pie = allmeans, 
     color = "skyblue",
     pieBorder = 1)


```


## Symptom network: boys and girls

```{r symptoms-boygirl}

sympdf <- df %>% dplyr::select(id,
  intervention,
  group,
  school,
  girl,
  "Neck and shoulder pain" = symptom_neckShoulderPain_T1,
  "Lower back pain" = symptom_lowerBackPain_T1,
  "Stomach ache" = symptom_stomachAche_T1,
  "Tension or nervousness" = symptom_tensionNervousness_T1,
  "Irritability or anger bursts" = symptom_irritabilityAngerbursts_T1,
  "Difficulty with sleep" = symptom_sleepDifficulty_T1,
  "Headache" = symptom_headAche_T1,
  "Tiredness or faintness" = symptom_tirednessFaintness_T1,
  "Fat pct" = fatpct_T1,
  "PA" = paAccelerometer_T1,
  "SB" = sitLieAccelerometer_T1
) %>% 
  mutate(
    'Neck and shoulder pain' = ifelse(`Neck and shoulder pain` == 1, 0, 1),
    'Lower back pain' = ifelse(`Lower back pain` == 1, 0, 1),
    'Stomach ache' = ifelse(`Stomach ache` == 1, 0, 1),
    'Tension or nervousness' = ifelse(`Tension or nervousness` == 1, 0, 1),
    'Irritability or anger bursts' = ifelse(`Irritability or anger bursts` == 1, 0, 1),
    'Difficulty with sleep' = ifelse(`Difficulty with sleep` == 1, 0, 1),
    'Headache' = ifelse(`Headache` == 1, 0, 1),
    'Tiredness or faintness' = ifelse(`Tiredness or faintness` == 1, 0, 1),
    'Fat pct' = `Fat pct` / 100) %>% 
  data.frame

S.boys <- sympdf %>% filter(girl == "boy") %>% dplyr::select(6:ncol(sympdf)) %>% na.omit(.) 
S.girls <- sympdf %>% filter(girl == "girl") %>% dplyr::select(6:ncol(sympdf)) %>% na.omit(.)
nwBoys <- bootnet::estimateNetwork(S.boys, default="mgm")
nwGirls <- bootnet::estimateNetwork(S.girls, default="mgm")

girlmeans <- sympdf %>% group_by(girl) %>% 
  summarise_at(vars(5:15),
  funs(mean(., na.rm = TRUE))) %>% 
  filter(girl == "girl") %>% 
  mutate_at(vars(PA, SB),
            funs(. / (24*60))) %>% # proportion of day used doing the behaviour
  dplyr::select(-1)

boymeans <- sympdf %>% group_by(girl) %>% 
  summarise_at(vars(5:15),
  funs(mean(., na.rm = TRUE))) %>% 
  filter(girl == "boy") %>% 
  mutate_at(vars(PA, SB),
            funs(. / (24*60))) %>% # proportion of day used doing the behaviour
  dplyr::select(-1)


layout(t(1:2))
plot(nwGirls, label.scale = FALSE, title = "Girls", label.cex = 0.75,
     pie = girlmeans, 
     color = "skyblue",
     pieBorder = 1)

plot(nwBoys, label.scale = FALSE, title = "Boys", label.cex = 0.75, 
     pie = boymeans, 
     color = "skyblue",
     pieBorder = 1)


```

## symptom network: educational tracks

```{r, include = FALSE, eval = FALSE}
library(bootnet)
library(qgraph)
library(tidyverse)

sympdf <- df %>% dplyr::select(id,
  intervention,
  track,
  school,
  girl,
  "Neck and shoulder pain" = symptom_neckShoulderPain_T1,
  "Lower back pain" = symptom_lowerBackPain_T1,
  "Stomach ache" = symptom_stomachAche_T1,
  "Tension or nervousness" = symptom_tensionNervousness_T1,
  "Irritability or anger bursts" = symptom_irritabilityAngerbursts_T1,
  "Difficulty with sleep" = symptom_sleepDifficulty_T1,
  "Headache" = symptom_headAche_T1,
  "Tiredness or faintness" = symptom_tirednessFaintness_T1,
  "Fat pct" = fatpct_T1,
  "PA" = paAccelerometer_T1,
  "SB" = sitLieAccelerometer_T1
) %>% 
  mutate(
    'Neck and shoulder pain' = ifelse(`Neck and shoulder pain` == 1, 0, 1),
    'Lower back pain' = ifelse(`Lower back pain` == 1, 0, 1),
    'Stomach ache' = ifelse(`Stomach ache` == 1, 0, 1),
    'Tension or nervousness' = ifelse(`Tension or nervousness` == 1, 0, 1),
    'Irritability or anger bursts' = ifelse(`Irritability or anger bursts` == 1, 0, 1),
    'Difficulty with sleep' = ifelse(`Difficulty with sleep` == 1, 0, 1),
    'Headache' = ifelse(`Headache` == 1, 0, 1),
    'Tiredness or faintness' = ifelse(`Tiredness or faintness` == 1, 0, 1),
    'Fat pct' = `Fat pct` / 100) %>% 
  data.frame

# S.other <- sympdf %>% filter(track == "Other") %>% dplyr::select(6:ncol(sympdf)) %>% na.omit(.)
# S.it <- sympdf %>% filter(track == "Business IT") %>% dplyr::select(6:ncol(sympdf))
# S.admin <- sympdf %>% filter(track == "Business Admin") %>% dplyr::select(6:ncol(sympdf))
# S.hrc <- sympdf %>% filter(track == "HRC") %>% dplyr::select(6:ncol(sympdf))
# S.nursing <- sympdf %>% filter(track == "Nursing") %>% dplyr::select(6:ncol(sympdf))

# S.other <- sympdf %>% filter(track == 1) %>% dplyr::select(6:ncol(sympdf))
S.it <- sympdf %>% filter(track == 2) %>% dplyr::select(6:ncol(sympdf))
S.admin <- sympdf %>% filter(track == 3) %>% dplyr::select(6:ncol(sympdf))
S.hrc <- sympdf %>% filter(track == 4) %>% dplyr::select(6:ncol(sympdf))
S.nursing <- sympdf %>% filter(track == 5) %>% dplyr::select(6:ncol(sympdf))

# nwOther <- bootnet::estimateNetwork(S.other, default="mgm")
nwIt <- bootnet::estimateNetwork(S.it, default="mgm")
nwAdmin <- bootnet::estimateNetwork(S.admin, default="mgm")
nwHrc <- bootnet::estimateNetwork(S.hrc, default="mgm")
nwNursing <- bootnet::estimateNetwork(S.nursing, default="mgm")

# othermeans <- sympdf %>% group_by(track) %>% 
#   summarise_at(vars(5:15),
#   funs(mean(., na.rm = TRUE))) %>% 
#   filter(track == "Other") %>% 
#   mutate_at(vars(PA, SB),
#             funs(. / (24*60))) %>% # proportion of day used doing the behaviour
#   dplyr::select(-1)

# itmeans <- sympdf %>% group_by(track) %>% 
#   summarise_at(vars(5:15),
#   funs(mean(., na.rm = TRUE))) %>% 
#   filter(track == "Business IT") %>% 
#   mutate_at(vars(PA, SB),
#             funs(. / (24*60))) %>% # proportion of day used doing the behaviour
#   dplyr::select(-1)

itmeans <- sympdf %>% group_by(track) %>% 
  summarise_at(vars(5:15),
  funs(mean(., na.rm = TRUE))) %>% 
  filter(track == 2) %>% 
  mutate_at(vars(PA, SB),
            funs(. / (24*60))) %>% # proportion of day used doing the behaviour
  dplyr::select(-1)

# adminmeans <- sympdf %>% group_by(track) %>% 
#   summarise_at(vars(5:15),
#   funs(mean(., na.rm = TRUE))) %>% 
#   filter(track == "Business Admin") %>% 
#   mutate_at(vars(PA, SB),
#             funs(. / (24*60))) %>% # proportion of day used doing the behaviour
#   dplyr::select(-1)

adminmeans <- sympdf %>% group_by(track) %>% 
  summarise_at(vars(5:15),
  funs(mean(., na.rm = TRUE))) %>% 
  filter(track == 3) %>% 
  mutate_at(vars(PA, SB),
            funs(. / (24*60))) %>% # proportion of day used doing the behaviour
  dplyr::select(-1)

# hrcmeans <- sympdf %>% group_by(track) %>% 
#   summarise_at(vars(5:15),
#   funs(mean(., na.rm = TRUE))) %>% 
#   filter(track == "HRC") %>% 
#   mutate_at(vars(PA, SB),
#             funs(. / (24*60))) %>% # proportion of day used doing the behaviour
#   dplyr::select(-1)

hrcmeans <- sympdf %>% group_by(track) %>% 
  summarise_at(vars(5:15),
  funs(mean(., na.rm = TRUE))) %>% 
  filter(track == 4) %>% 
  mutate_at(vars(PA, SB),
            funs(. / (24*60))) %>% # proportion of day used doing the behaviour
  dplyr::select(-1)

# nursingmeans <- sympdf %>% group_by(track) %>% 
#   summarise_at(vars(5:15),
#   funs(mean(., na.rm = TRUE))) %>% 
#   filter(track == "Nursing") %>% 
#   mutate_at(vars(PA, SB),
#             funs(. / (24*60))) %>% # proportion of day used doing the behaviour
#   dplyr::select(-1)

nursingmeans <- sympdf %>% group_by(track) %>% 
  summarise_at(vars(5:15),
  funs(mean(., na.rm = TRUE))) %>% 
  filter(track == 5) %>% 
  mutate_at(vars(PA, SB),
            funs(. / (24*60))) %>% # proportion of day used doing the behaviour
  dplyr::select(-1)

averagelayout <- qgraph::averageLayout(nwIt, nwAdmin, nwHrc, nwNursing)
# plot(nwOther, label.scale = FALSE, title = "Girls", label.cex = 0.75,
#      pie = othermeans, 
#      color = "skyblue",
#      pieBorder = 1)

layout(t(1:4))
plot(nwIt, label.scale = FALSE, title = "Business IT", layout = averagelayout, label.cex = 0.75, 
     pie = itmeans, 
     color = "skyblue",
     pieBorder = 1)

plot(nwAdmin, label.scale = FALSE, title = "Business admin", layout = averagelayout, label.cex = 0.75, 
     pie = adminmeans, 
     color = "skyblue",
     pieBorder = 1)

plot(nwHrc, label.scale = FALSE, title = "Hotel, restaurant and catering", layout = averagelayout, label.cex = 0.75, 
     pie = hrcmeans, 
     color = "skyblue",
     pieBorder = 1)

plot(nwNursing, label.scale = FALSE, title = "Nursing", layout = averagelayout, label.cex = 0.75, 
     pie = nursingmeans, 
     color = "skyblue",
     pieBorder = 1)




```


```{r, include = FALSE, eval = FALSE}

colfill <- c(1,2,3,4,5)

# Create data frame
densplot <- d
levels(densplot$intervention) <- list("Intervention" = "1", "Control" = "0")
levels(densplot$girl) <- list("Girl" = "1", "Boy" = "0")

# This gives side-by-side plots
layout(t(1:2), 1)

# Intervention vs. control
# Choose only the variables needed and drop NA
dens <- densplot %>% dplyr::select(fatpct_T1, intervention) %>% 
  filter(complete.cases(.))

# Set random number generator for reproducibility of bootstrap test of equal densities
set.seed(10)

# Make plot
sm.fatpct_T1_1 <- sm.density.compare2(as.numeric(dens$fatpct_T1), as.factor(dens$intervention), xlab="Percentage", col=colfill, lty=c(1,2), bandcol='LightGray', model="equal", lwd=(c(2,2)))
legend("topright", levels(dens$intervention), fill=c(1, 2))

# Girls vs. boys
# Choose only the variables needed and drop NA
dens <- densplot %>% dplyr::select(fatpct_T1, girl) %>% 
  filter(complete.cases(.))

# Set random number generator for reproducibility of bootstrap test of equal densities
set.seed(10)

# Make plot
sm.fatpct_T1_2 <- sm.density.compare2(as.numeric(dens$fatpct_T1), as.factor(dens$girl), xlab="Percentage", col=colfill, lty=c(1,2), bandcol='LightGray', model="equal", lwd=(c(2,2)))
legend("topright", levels(dens$girl), fill=c(1, 2))

sm.fatpct_T1_2 <- sm.density.compare2(as.numeric(dens$fatpct_T1), as.factor(dens$girl), xlab="Percentage", col=colfill, lty=c(1,2), bandcol='LightGray', model="equal", lwd=(c(2,2)))
legend("topright", levels(dens$girl), fill=c(1, 2))
```



# Physical activity network

```{r, include = FALSE, eval = FALSE}

data <- df %>% dplyr::select(PA = paAccelerometer_T1, actCop = actcop_T1, BCT = frqbct_T1, amot = amotivation_T1, auton = autonomous_T1, cont = controlled_T1, dnorm = dnorm_T1, fatpct = fatpct_T1, inorm = inorm_T1, intent = intention_T1, outcomeExpectations = outcomeExpectations_T1, opp = opportunities_T1, sePbc = sePbc_T1) %>% data.frame() 

# Spinglass algorithm detects communities. Tutorial here: http://psych-networks.com/r-tutorial-identify-communities-items-networks/

qgraph(cor_auto(data), layout="spring")

cormatrix <- cor_auto(data1)

graph1 <- qgraph(cormatrix, graph="glasso", layout="spring", sampleSize = nrow(data),
              vsize=7, cut=0, maximum=.45, border.width=1.5)

g = as.igraph(graph1, attributes=TRUE)

sgc <- spinglass.community(g)

sgc$membership

group.spinglass<- list(c(1, 2, 3, 5, 10), 
                       c(4, 6, 8), 
                       c(7, 9), 
                       c(11, 12, 13))

set.seed(2)

network1 <- bootnet::estimateNetwork(data1, default="EBICglasso")

#bladibla <- qgraph::averageLayout(network1$graph, network2$graph)

# layout(t(1:2))
# graph1 <- plot(network1, layout=bladibla, cut=0)
# graph2 <- plot(network2, layout=bladibla, cut=0)
# graph1 <- plot(network1, cut=0)
# graph2 <- plot(network2, cut=0)

plot(network1, layout = "spring", labels = TRUE, groups = group.spinglass, color=c("olivedrab2", "orange", "mediumpurple1", "lightblue"))


```

### PA network without SDT motivations

```{r, include = FALSE, eval = FALSE}
# Network without motivation variables
data <- df %>% dplyr::select(PA = paAccelerometer_T1, actCop = PA_actcop_T1, BCT = PA_frqbct_T1, amot = PA_amotivation_T1, auton = PA_autonomous_T1, cont = PA_controlled_T1, dnorm = PA_dnorm_T1, fatpct = fatpct_T1, inorm = PA_inorm_T1, intent = PA_intention_T1, outcomeExpectations = PA_outcomeExpectations_T1, opp = PA_opportunities_T1, sePbc = PA_sePbc_T1) %>% data.frame() %>% 
  dplyr::select(-auton, -cont, -amot)

# Spinglass algorithm detects communities. Tutorial here: http://psych-networks.com/r-tutorial-identify-communities-items-networks/

cormatrix <- cor_auto(data)

graph1<-qgraph(cormatrix, graph="glasso", layout="spring", sampleSize = nrow(data),
              vsize=7, cut=0, maximum=.45, border.width=1.5)

g = as.igraph(graph1, attributes=TRUE)

sgc <- spinglass.community(g)

sgc$membership

# Without SDT motivations
group.spinglass<- list(c(1, 2, 3, 7), 
                       c(4, 6), 
                       c(5), 
                       c(8, 9, 10))

set.seed(2)

network1 <- bootnet::estimateNetwork(data, default="EBICglasso")

plot(network1, layout = "spring", labels = TRUE, groups = group.spinglass, color=c("olivedrab2", "orange", "mediumpurple1", "lightblue"))

```

### PA network without BCTs and SDT

```{r, include = FALSE, eval = FALSE}
# Network without motivation variables
data <- df %>% dplyr::select(PA = paAccelerometer_T1, 'action and coping planning' = PA_actcop_T1, 'Frequency-related BCTs' = PA_frqbct_T1, 'amotivation' = PA_amotivation_T1, 'autonomous motivation' = PA_autonomous_T1, 'controlled motivation' = PA_controlled_T1, 'descriptive norm' = PA_dnorm_T1, 'injunctive norm' = PA_inorm_T1, "fat pct" = fatpct_T1, 'intention' = PA_intention_T1, 'outcome expectations' = PA_outcomeExpectations_T1, 'Self-efficacy / PBC' = PA_sePbc_T1, 'perceived opportunities' = PA_opportunities_T1) %>% 
            dplyr::select(-`autonomous motivation`, -`controlled motivation`, -`amotivation`, -`Frequency-related BCTs`) %>% 
  data.frame

# Spinglass algorithm detects communities. Tutorial here: http://psych-networks.com/r-tutorial-identify-communities-items-networks/

cormatrix <- cor_auto(data)

graph1 <- qgraph(cormatrix, graph="glasso", layout="spring", sampleSize = nrow(data),
              vsize=7, cut=0, maximum=.45, border.width=1.5)

g = as.igraph(graph1, attributes=TRUE)

set.seed(4)

sgc <- spinglass.community(g)

sgc$membership

# Without SDT motivations

group.spinglass<- list(c(1, 2, 6), 
                       c(3, 4), 
                       c(5),
                       c(7, 8, 9))

network1 <- bootnet::estimateNetwork(data, default="EBICglasso")

piefill <- data %>%
  summarise_all(funs(mean(., na.rm = TRUE))) %>% 
  mutate_at(vars(PA),
            funs(. / (24*60))) %>% # proportion of day used doing the behaviour
  mutate_at(vars(action.and.coping.planning),
            funs(. / 4)) %>% 
  mutate_at(vars(3, 4, 6, 7, 8, 9),
            funs(. / 7)) %>% 
  mutate_at(vars(5),
            funs(. / 100))  

plot(network1, layout = "spring", labels = TRUE, groups = group.spinglass, color=c("olivedrab2", "orange", "mediumpurple1", "lightblue"),
     label.cex = 0.75,
     label.scale = FALSE,
     pie = piefill, 
     color = "skyblue",
     pieBorder = 1)


plot(nwBoys, label.scale = FALSE, title = "Boys", label.cex = 0.75, 
     pie = boymeans, 
     color = "skyblue",
     pieBorder = 1)
```

### PA network without BCTs and SDT, intention, PA, fat%

```{r, include = FALSE, eval = FALSE}
# Network without motivation variables
data <- df %>% dplyr::select(PA = paAccelerometer_T1, 'action and coping planning' = PA_actcop_T1, 'Frequency-related BCTs' = PA_frqbct_T1, 'amotivation' = PA_amotivation_T1, 'autonomous motivation' = PA_autonomous_T1, 'controlled motivation' = PA_controlled_T1, 'descriptive norm' = PA_dnorm_T1, 'injunctive norm' = PA_inorm_T1, "fat pct" = fatpct_T1, 'intention' = PA_intention_T1, 'outcome expectations' = PA_outcomeExpectations_T1, 'Self-efficacy / PBC' = PA_sePbc_T1, 'perceived opportunities' = PA_opportunities_T1) %>% 
            dplyr::select(-`autonomous motivation`, -`controlled motivation`, -`amotivation`, -`Frequency-related BCTs`, -PA, -`intention`, -`fat pct`) %>% 
  data.frame

# Spinglass algorithm detects communities. Tutorial here: http://psych-networks.com/r-tutorial-identify-communities-items-networks/

cormatrix <- cor_auto(data)

graph1 <- qgraph(cormatrix, graph="glasso", layout="spring", sampleSize = nrow(data),
              vsize=7, cut=0, maximum=.45, border.width=1.5)

g = as.igraph(graph1, attributes=TRUE)

set.seed(1)

sgc <- spinglass.community(g)

sgc$membership

group.spinglass<- list(c(1, 4:6), 
                       c(2, 3))

# Estimate and plot graph


network1 <- bootnet::estimateNetwork(data, default="EBICglasso")

piefill <- data %>%
  summarise_all(funs(mean(., na.rm = TRUE))) %>%
  mutate_at(vars(action.and.coping.planning),
            funs(. / 4)) %>% 
  mutate_at(vars(2:6),
            funs(. / 7))

plot(network1, layout = "spring", labels = TRUE, groups = group.spinglass, color=c("olivedrab2", "orange", "mediumpurple1", "lightblue"),
     label.cex = 0.75,
     label.scale = FALSE,
     pie = piefill, 
     color = "skyblue",
     pieBorder = 1)


```

## Robustness test 

```{r, include = FALSE, eval = FALSE}

Network1 <- bootnet::estimateNetwork(data1, default = "EBICglasso")
plot(Network1, layout = "spring", labels = TRUE)

qgraph::centralityPlot(Network1)

boot1 <- bootnet::bootnet(Network1, nBoots = 2500, nCores = 2)

plot(boot1, labels = TRUE, order = "sample")

Network2 <- bootnet::estimateNetwork(data1, default = "pcor")
plot(Network2, layout = "spring", labels = TRUE)

boot2 <- bootnet::bootnet(Network2, nBoots = 2500, nCores = 2)

qgraph::centralityPlot(Network)
qgraph::centralityPlot(Network2)
```

## Centrality stability

```{r, eval = FALSE}
boot2 <- bootnet::bootnet(Network1, nBoots = 2500, type = "case", nCores = 2)
bootnet::corStability(boot2)

plot(boot2)

differenceTest(boot1, "auton", "intent",  measure = c("strength", "closeness", "betweenness"))

plot(boot1, "edge", plot = "difference", onlyNonZero = TRUE, order = "sample")

plot(boot1, "strength")
plot(boot1, "betweenness")
plot(boot1, "closeness")
```

## Network comparison test: girls and boys

```{r, include = FALSE, eval = FALSE}

# here goes your data; call it "data"
data <- df %>% dplyr::select(paT1, girl, actcop_T1, frqbct_T1, amotivation_T1, autonomous_T1, controlled_T1, dnorm_T1, fatpct_T1, inorm_T1, intention_T1, outcomeExpectations_T1, opportunities_T1, sePbc_T1) 

### Split data into girls and boys
data1 <- data %>% filter(girl == "girl") %>% dplyr::select(-girl) %>% as.data.frame

data2 <- data %>% filter(girl == "boy") %>% dplyr::select(-girl) %>% as.data.frame

# ---------------------------------------------------------------------------------------
# ---------- 3. NCT ------------------------------------------------------------------
# ---------------------------------------------------------------------------------------


### estimate networks and compare visually; use averageLayout function, then plot via layout(t(1:2))
network1 <- bootnet::estimateNetwork(data1, default="EBICglasso")
network2 <- bootnet::estimateNetwork(data2, default="EBICglasso")

bladibla <- qgraph::averageLayout(network1$graph, network2$graph)

layout(t(1:2))
graph1 <- plot(network1, layout=bladibla, cut=0)
graph2 <- plot(network2, layout=bladibla, cut=0)

### run NCT 

nct_results <- NetworkComparisonTest::NCT(data1, data2, it=1000, binary.data=FALSE, paired=TRUE, test.edges=TRUE, edges='all', progressbar=TRUE)

nct_results$nwinv.pval  # p value of network structure diff test
nct_results$glstrinv.pval  # p value of global connectivity diff test
nct_results$einv.pvals     #p values testing diffs for all individual edges
sum(nct_results$einv.pvals$"p-value" < 0.05)  # how many edges are different

```

## Robustness test 
```{r, eval = FALSE}
data <- data %>% dplyr::select(BCT = agrbct_T1,
    AUT = autonomous_T1,
    Intn = intention_T1,
    PBC = pbc_T1,
    outcomeExpectations = outcomeExpectations_T1,
    DNorm = norm_T1)

Network <- bootnet::estimateNetwork(data, default = "EBICglasso")

boot1 <- bootnet::bootnet(Network, nBoots = 2500, nCores = 2)

plot(boot1, labels = TRUE, order = "sample")

plot(Network, layout = "spring", labels = TRUE)

Network2 <- bootnet::estimateNetwork(data, default = "pcor")
plot(Network2, layout = "spring", labels = TRUE)

boot1 <- bootnet::bootnet(Network2, nBoots = 2500, nCores = 2)

qgraph::centralityPlot(Network)
qgraph::centralityPlot(Network2)
```

# Centrality stability

```{r, eval = FALSE}
boot2 <- bootnet::bootnet(Network, nBoots = 2500, type = "case", nCores = 2)
bootnet::corStability(boot2)

plot(boot2)

differenceTest(boot1, "AUT", "Intn",  measure = c("strength", "closeness", "betweenness"))

plot(boot1, "edge", plot = "difference", onlyNonZero = TRUE, order = "sample")

plot(boot1, "strength")
plot(boot1, "betweenness")
plot(boot1, "closeness")
```

# PA motivation examined

```{r, include = FALSE, eval = FALSE}
nItems <- 18
regulations.df <- lmi %>% dplyr::select(id = ID,
  intervention = ryhmä,
  group = ryhmäkoodi_korjattu,
  school = Aineisto.1,
  girl = Kys0013.1,
  PA_amotivation_02_T1 = Kys0086.1,
  PA_amotivation_01_T1 = Kys0082.1,
  PA_amotivation_03_T1 = Kys0096.1,
  PA_amotivation_04_T1 = Kys0097.1,
  PA_extrinsic_01_T1 = Kys0080.1,
  PA_extrinsic_02_T1 = Kys0081.1,
  PA_extrinsic_03_T1 = Kys0083.1,
  PA_introjected_01_T1 = Kys0084.1,
  PA_introjected_02_T1 = Kys0085.1,
  PA_identified_01_T1 = Kys0087.1,
  PA_identified_02_T1 = Kys0088.1,
  PA_identified_03_T1 = Kys0090.1,
  PA_integrated_01_T1 = Kys0089.1,
  PA_integrated_02_T1 = Kys0092.1,
  PA_integrated_03_T1 = Kys0094.1,
  PA_intrinsic_01_T1 = Kys0091.1,
  PA_intrinsic_02_T1 = Kys0093.1,
  PA_intrinsic_03_T1 = Kys0095.1
)

regulations.df <- regulations.df %>% dplyr::mutate(group = ifelse(group == "", NA, group))

# Fix intervention and gender variables
regulations.df <- regulations.df %>% dplyr::mutate(intervention = ifelse(intervention == 1, 1, 0),
                         intervention = factor(intervention),
            girl = ifelse(girl == 2, 1, 0),
            girl = factor(girl, levels = c("1", "0")),
            school = factor(school, levels = c("1", "2", "3", "4", "5")))


motiGirls <- regulations.df %>% dplyr::select(id,
  intervention,
  group,
  school,
  girl,
  PA_amotivation_02_T1,
  PA_amotivation_01_T1,
  PA_amotivation_03_T1,
  PA_amotivation_04_T1,
  PA_extrinsic_01_T1,
  PA_extrinsic_02_T1,
  PA_extrinsic_03_T1,
  PA_introjected_01_T1,
  PA_introjected_02_T1,
  PA_identified_01_T1,
  PA_identified_02_T1,
  PA_identified_03_T1,
  PA_integrated_01_T1,
  PA_integrated_02_T1,
  PA_integrated_03_T1,
  PA_intrinsic_01_T1,
  PA_intrinsic_02_T1,
  PA_intrinsic_03_T1) %>%
 tidyr::gather(key = Variable, value = Value, 6:ncol(.)) %>%
  filter(girl == "1") %>% 
 ggplot(aes(x = Value, y = Variable, group = Variable)) +
  ggridges::geom_density_ridges2(aes(fill = Variable), stat = "binline", binwidth = 1, scale = 0.95) +
  scale_x_continuous(breaks = c(1:6), expand = c(0, 0),
                     name = "") +
  scale_y_discrete(expand = c(0.01, 0), name = "", labels = NULL) +
  ggridges::scale_fill_cyclical(values = c("darkolivegreen2", "darkolivegreen4")) +
  labs(title = "Girls") +
  guides(y = "none") +
  ggridges::theme_ridges(grid = FALSE) +
  theme(axis.title.x = element_text(hjust = 0.5),
        axis.title.y = element_text(hjust = 0.5),
        plot.title = element_text(hjust = 0.5),
        axis.text=element_text(size=10)) +
coord_cartesian(xlim = c(0.5, 5.5))

motiBoys <- regulations.df %>% dplyr::select(id,
  intervention,
  group,
  school,
  girl,
  PA_amotivation_02_T1,
  PA_amotivation_01_T1,
  PA_amotivation_03_T1,
  PA_amotivation_04_T1,
  PA_extrinsic_01_T1,
  PA_extrinsic_02_T1,
  PA_extrinsic_03_T1,
  PA_introjected_01_T1,
  PA_introjected_02_T1,
  PA_identified_01_T1,
  PA_identified_02_T1,
  PA_identified_03_T1,
  PA_integrated_01_T1,
  PA_integrated_02_T1,
  PA_integrated_03_T1,
  PA_intrinsic_01_T1,
  PA_intrinsic_02_T1,
  PA_intrinsic_03_T1) %>%
 tidyr::gather(key = Variable, value = Value, 6:ncol(.)) %>%
  filter(girl == "0") %>% 
 ggplot(aes(x = Value, y = Variable, group = Variable)) +
  ggridges::geom_density_ridges2(aes(fill = Variable), stat = "binline", binwidth = 1, scale = 0.95) +
  scale_x_continuous(breaks = c(1:6), expand = c(0, 0),
                     name = "") +
  scale_y_discrete(expand = c(0.01, 0), name = "", labels = NULL) +
  ggridges::scale_fill_cyclical(values = c("darkolivegreen2", "darkolivegreen4")) +
  labs(title = "Boys") +
  guides(y = "none") +
  ggridges::theme_ridges(grid = FALSE) +
  theme(axis.title.x = element_text(hjust = 0.5),
        axis.title.y = element_text(hjust = 0.5),
        plot.title = element_text(hjust = 0.5),
        axis.text=element_text(size=10)) +
coord_cartesian(xlim = c(0.5, 5.5))

motiInt <- regulations.df %>% dplyr::select(id,
  intervention,
  group,
  school,
  girl,
  PA_amotivation_02_T1,
  PA_amotivation_01_T1,
  PA_amotivation_03_T1,
  PA_amotivation_04_T1,
  PA_extrinsic_01_T1,
  PA_extrinsic_02_T1,
  PA_extrinsic_03_T1,
  PA_introjected_01_T1,
  PA_introjected_02_T1,
  PA_identified_01_T1,
  PA_identified_02_T1,
  PA_identified_03_T1,
  PA_integrated_01_T1,
  PA_integrated_02_T1,
  PA_integrated_03_T1,
  PA_intrinsic_01_T1,
  PA_intrinsic_02_T1,
  PA_intrinsic_03_T1) %>%
 tidyr::gather(key = Variable, value = Value, 6:ncol(.)) %>%
  filter(intervention == "1") %>% 
 ggplot(aes(x = Value, y = Variable, group = Variable)) +
  ggridges::geom_density_ridges2(aes(fill = Variable), stat = "binline", binwidth = 1, scale = 0.95) +
  scale_x_continuous(breaks = c(1:6), expand = c(0, 0),
                     name = "") +
  scale_y_discrete(expand = c(0.01, 0), name = "") +
  ggridges::scale_fill_cyclical(values = c("deepskyblue", "deepskyblue4")) +
  labs(title = "Intervention") +
  guides(y = "none") +
  ggridges::theme_ridges(grid = FALSE) +
  theme(axis.title.x = element_text(hjust = 0.5),
        axis.title.y = element_text(hjust = 0.5),
        axis.text=element_text(size=10)) +
coord_cartesian(xlim = c(0.5, 5.5))

motiCont <- regulations.df %>% dplyr::select(id,
  intervention,
  group,
  school,
  girl,
  PA_amotivation_02_T1,
  PA_amotivation_01_T1,
  PA_amotivation_03_T1,
  PA_amotivation_04_T1,
  PA_extrinsic_01_T1,
  PA_extrinsic_02_T1,
  PA_extrinsic_03_T1,
  PA_introjected_01_T1,
  PA_introjected_02_T1,
  PA_identified_01_T1,
  PA_identified_02_T1,
  PA_identified_03_T1,
  PA_integrated_01_T1,
  PA_integrated_02_T1,
  PA_integrated_03_T1,
  PA_intrinsic_01_T1,
  PA_intrinsic_02_T1,
  PA_intrinsic_03_T1) %>%
 tidyr::gather(key = Variable, value = Value, 6:ncol(.)) %>%
  filter(intervention == "0") %>% 
 ggplot(aes(x = Value, y = Variable, group = Variable)) +
  ggridges::geom_density_ridges2(aes(fill = Variable), stat = "binline", binwidth = 1, scale = 0.95) +
  scale_x_continuous(breaks = c(1:6), expand = c(0, 0),
                     name = "") +
  scale_y_discrete(expand = c(0.01, 0), name = "", labels = NULL) +
  ggridges::scale_fill_cyclical(values = c("deepskyblue", "deepskyblue4")) +
  labs(title = "Control") +
  guides(y = "none") +
  ggridges::theme_ridges(grid = FALSE) +
  theme(axis.title.x = element_text(hjust = 0.5),
        axis.title.y = element_text(hjust = 0.5),
        axis.text=element_text(size=10)) +
coord_cartesian(xlim = c(0.5, 5.5))

#grid.arrange(motiInt, motiGirls, motiCont, motiBoys, ncol = 2)

# ("Seldom or never", "About once a month", "About once a week", "Almost daily")

# This draws all histograms next to each other:
grid::grid.newpage()
grid::grid.draw(cbind(ggplotGrob(motiInt), ggplotGrob(motiCont), ggplotGrob(motiGirls), ggplotGrob(motiBoys), size = "last"))

```

## Motivational regulations network

```{r, include = FALSE, eval = FALSE}
## TEE TÄNNE PIEFILL? tummempi sama väri tai opacity?

# Was going to do fused graphical lasso, but the items not normal...

# s1 <- regulations.df %>% filter(school == 1) %>% dplyr::select(6:ncol(regulations.df)) # %>% na.omit(.) 
# s2 <- regulations.df %>% filter(school == 2) %>% dplyr::select(6:ncol(regulations.df)) # %>% na.omit(.)
# s3 <- regulations.df %>% filter(school == 3) %>% dplyr::select(6:ncol(regulations.df)) # %>% na.omit(.) 
# s4 <- regulations.df %>% filter(school == 4) %>% dplyr::select(6:ncol(regulations.df)) # %>% na.omit(.)
# s5 <- regulations.df %>% filter(school == 5) %>% dplyr::select(6:ncol(regulations.df)) # %>% na.omit(.)
# 
# network2 <- EstimateGroupNetwork(list("1" = s1,
#                                       "2" = s2,
#                                       "3" = s3,
#                                       "4" = s4,
#                                       "5" = s5),
#                                  n = c(nrow(s1), nrow(s2), nrow(s3), nrow(s4), nrow(s5)))
# 
regulations.df <- regulations.df %>% mutate(
PA_amotivation_02_T1 = ifelse(PA_amotivation_02_T1 == 1, 0, 1),
PA_amotivation_01_T1 = ifelse(PA_amotivation_01_T1 == 1, 0, 1),
PA_amotivation_03_T1 = ifelse(PA_amotivation_03_T1 == 1, 0, 1),
PA_amotivation_04_T1 = ifelse(PA_amotivation_04_T1 == 1, 0, 1),
PA_extrinsic_01_T1 = ifelse(PA_extrinsic_01_T1 == 1, 0, 1),
PA_extrinsic_02_T1 = ifelse(PA_extrinsic_02_T1 == 1, 0, 1),
PA_extrinsic_03_T1 = ifelse(PA_extrinsic_03_T1 == 1, 0, 1),
PA_introjected_01_T1 = ifelse(PA_introjected_01_T1 == 1, 0, 1),
PA_introjected_02_T1 = ifelse(PA_introjected_02_T1 == 1, 0, 1),
PA_identified_01_T1 = ifelse(PA_identified_01_T1 == 1, 0, 1),
PA_identified_02_T1 = ifelse(PA_identified_02_T1 == 1, 0, 1),
PA_identified_03_T1 = ifelse(PA_identified_03_T1 == 1, 0, 1),
PA_integrated_01_T1 = ifelse(PA_integrated_01_T1 == 1, 0, 1),
PA_integrated_02_T1 = ifelse(PA_integrated_02_T1 == 1, 0, 1),
PA_integrated_03_T1 = ifelse(PA_integrated_03_T1 == 1, 0, 1),
PA_intrinsic_01_T1 = ifelse(PA_intrinsic_01_T1 == 1, 0, 1),
PA_intrinsic_02_T1 = ifelse(PA_intrinsic_02_T1 == 1, 0, 1),
PA_intrinsic_03_T1 = ifelse(PA_intrinsic_03_T1 == 1, 0, 1))


### GIRLS AND BOYS

S.boys <- regulations.df %>% filter(girl == "boy") %>% dplyr::select(6:ncol(regulations.df)) # %>% na.omit(.) 
S.girls <- regulations.df %>% filter(girl == "girl") %>% dplyr::select(6:ncol(regulations.df)) # %>% na.omit(.)
nwBoys <- bootnet::estimateNetwork(S.boys, default="IsingFit")
nwGirls <- bootnet::estimateNetwork(S.girls, default="IsingFit")

data1 <- regulations.df %>% dplyr::select(6:ncol(regulations.df))
names(data1) <- c(paste0(rep("Amoti", 4), 1:4),
                paste0(rep("Extri", 3), 1:3),
                paste0(rep("Intro", 2), 1:2),
                paste0(rep("Ident", 3), 1:3),
                paste0(rep("Integ", 3), 1:3),
                paste0(rep("Intri", 3), 1:3))
nwAll <- bootnet::estimateNetwork(data1, default="IsingFit")

# Create means for filling nodes
girlmeans <- regulations.df %>% group_by(girl) %>% 
  summarise_at(vars(5:(5+nItems-1)),
  funs(mean(., na.rm = TRUE))) %>% 
  filter(girl == "girl") %>% 
  dplyr::select(-1)

boymeans <- regulations.df %>% group_by(girl) %>% 
  summarise_at(vars(5:(5+nItems-1)),
  funs(mean(., na.rm = TRUE))) %>% 
  filter(girl == "boy") %>% 
  dplyr::select(-1)

# Find average layout for comparability and plot graphs next to each other

Layout <- qgraph::averageLayout(nwGirls, nwBoys)


layout(t(1:2))
plot(nwGirls, layout = Layout, label.scale = FALSE, title = "Girls", label.cex = 0.75,
     pie = girlmeans, 
     color = "skyblue",
     pieBorder = 1)

plot(nwBoys, layout = Layout, label.scale = FALSE, title = "Boys", label.cex = 0.75, 
     pie = boymeans, 
     color = "skyblue",
     pieBorder = 1)

itemNames <- c('I can\'t see why I should bother exercising',
  'I do not see why I should have to exercise',
  ' I do not see the point in exercising',
  ' I think exercising is a waste of time',
  ' I exercise because other people say I should',
  ' I exercise because others will not be pleased with me if I do not',
  ' I feel under pressure from my friends/family to exercise',
  ' I feel guilty when I do not exercise',
  ' I feel like a failure when I have not exercised in a while',
  ' I think it is important to make the effort to exercise regularly',
  ' I value the benefits of exercise',
  ' it is important to me to exercise regularly',
  ' I exercise because it is consistent with my life goals.',
  ' I consider exercise consistent with my values.',
  ' I consider exercise a fundamental part of who I am.',
  ' I get pleasure and satisfaction from participating in exercise',
  ' I exercise because it is fun',
  ' I enjoy my exercise sessions')

itemGroups <- c(rep("Amotivation", 4),
                rep("Extrinsic", 3),
                rep("Introjected", 2),
                rep("Identified", 3),
                rep("Integrated", 3),
                rep("Intrinsic", 3))


plot(nwAll, groups = itemGroups, nodeNames = itemNames, legend.cex = 0.25)


```

